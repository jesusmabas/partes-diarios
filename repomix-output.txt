This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.firebaserc
.gitignore
cors.json
firebase.json
firestore.indexes.json
firestore.rules
functions/index.js
functions/package.json
package.json
public/index.html
public/manifest.json
public/robots.txt
README.md
src/App.css
src/App.js
src/App.test.js
src/components/CompressedImage.js
src/components/DailyReportForm.js
src/components/Dashboard.css
src/components/Dashboard.js
src/components/dashboard/Dashboard.css
src/components/dashboard/KPICards.js
src/components/dashboard/ProjectCostChart.js
src/components/dashboard/TimelineChart.js
src/components/DashboardView.js
src/components/DebugFirebase.js
src/components/FixedReportForm.js
src/components/ImageUploader.css
src/components/ImageUploader.js
src/components/LaborForm.js
src/components/LoginForm.js
src/components/MaterialsForm.js
src/components/PDFExportExample.js
src/components/ProjectForm.js
src/components/ProjectSelector.js
src/components/ProjectsViewer.js
src/components/ReportPDFGenerator.js
src/components/ReportsViewer.js
src/components/WorkPerformedForm.js
src/firebase.js
src/hooks/useDailyReports.js
src/hooks/useFormValidation.js
src/hooks/useLabor.js
src/hooks/useProjects.js
src/hooks/useQueryProjects.js
src/hooks/useQueryReports.js
src/hooks/useStorage.js
src/index.css
src/index.js
src/logo.svg
src/ReportPDF.js
src/reportWebVitals.js
src/setupTests.js
src/storageService.js
src/utils/formatters.js
src/utils/PdfDownload.js
src/utils/validationSchemas.js
storage.rules

================================================================
Files
================================================================

================
File: .firebaserc
================
{
  "projects": {
    "default": "partesdiarios-bbcc1",
    "test": "partesdiarios-bbcc1",
    "partes-diarios": "partesdiarios-bbcc1"
  },
  "targets": {},
  "etags": {}
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


.env
*.log
.vercel

/00

================
File: cors.json
================
[
  {
    "origin": ["https://partes-diarios.vercel.app", "http://localhost:3000"],
    "method": ["GET", "PUT", "POST", "DELETE"],
    "maxAgeSeconds": 3600,
    "headers": ["Content-Type", "Authorization"]
  }
]

================
File: firebase.json
================
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "functions": {
    "source": "functions",
    "runtime": "nodejs18"
  }
}

================
File: firestore.indexes.json
================
{
  "indexes": [
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "weekNumber", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "weekNumber", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "reportDate", "order": "ASCENDING" },
        { "fieldPath": "projectId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "reportDate", "order": "DESCENDING" },
        { "fieldPath": "projectId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "folder", "order": "ASCENDING" },
        { "fieldPath": "fileName", "order": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}

================
File: firestore.rules
================
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Regla básica: cualquier usuario autenticado puede leer/escribir
    // Esta es una configuración balanceada entre seguridad y facilidad de desarrollo
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
    
    // Definimos reglas específicas para debug_collection (que usamos en pruebas)
    match /debug_collection/{document} {
      allow read, write: if request.auth != null;
    }
  }
}

================
File: functions/index.js
================
const { onCall } = require("firebase-functions/v2/https");
const { onDocumentCreated } = require("firebase-functions/v2/firestore");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore } = require("firebase-admin/firestore");

// Inicializar la aplicación
initializeApp();
const db = getFirestore();

// Configuración común para todas las funciones
const functionConfig = {
  region: "us-central1", // Definir región explícitamente
  minInstances: 0,
  maxInstances: 10
};

// El resto del código de validación permanece igual...
const isRequired = (value) => value !== undefined && value !== null && value !== '';
const isNumber = (value) => !isNaN(parseFloat(value)) && isFinite(value);
const isPositiveNumber = (value) => isNumber(value) && parseFloat(value) >= 0;
const isValidTime = (value) => !value || /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value);
const isValidDate = (value) => isRequired(value) && !isNaN(Date.parse(value));

// Validadores específicos del servidor
const isAuthenticated = (context) => !!context.auth;
const isOwner = async (userId, resourcePath) => {
  try {
    const docSnap = await db.doc(resourcePath).get();
    return docSnap.exists && docSnap.data().userId === userId;
  } catch (error) {
    return false;
  }
};

// Funciones de validación (se mantienen igual)
const validateProject = (data) => {
  // El código de validación se mantiene igual...
  const errors = {};
  
  if (!isRequired(data.id)) {
    errors.id = 'El ID es obligatorio';
  } else if (!/^[a-zA-Z0-9-_]+$/.test(data.id)) {
    errors.id = 'El ID solo puede contener letras, números, guiones y guiones bajos';
  }
  
  if (!isRequired(data.client)) errors.client = 'El cliente es obligatorio';
  if (!isRequired(data.address)) errors.address = 'La dirección es obligatoria';
  
  if (!isRequired(data.nifNie)) {
    errors.nifNie = 'El NIF/NIE es obligatorio';
  } else if (!/^[0-9XYZ][0-9]{7}[A-Z]$/.test(data.nifNie)) {
    errors.nifNie = 'El NIF/NIE debe tener un formato válido';
  }
  
  if (!isRequired(data.type)) {
    errors.type = 'El tipo es obligatorio';
  } else if (!['hourly', 'fixed'].includes(data.type)) {
    errors.type = 'El tipo debe ser "hourly" o "fixed"';
  }
  
  if (data.type === 'hourly') {
    if (!isPositiveNumber(data.officialPrice)) {
      errors.officialPrice = 'El precio por hora del oficial debe ser un número positivo';
    }
    
    if (!isPositiveNumber(data.workerPrice)) {
      errors.workerPrice = 'El precio por hora del peón debe ser un número positivo';
    }
  } else if (data.type === 'fixed') {
    if (!isPositiveNumber(data.budgetAmount)) {
      errors.budgetAmount = 'El importe del presupuesto debe ser un número positivo';
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

const validateDailyReport = async (data) => {
  // El código de validación se mantiene igual...
  const errors = {};
  
  if (!isValidDate(data.reportDate)) {
    errors.reportDate = 'La fecha debe ser válida';
  }
  
  if (!isRequired(data.projectId)) {
    errors.projectId = 'El ID del proyecto es obligatorio';
  } else {
    // Verificar que el proyecto existe
    const projectDoc = await db.collection('projects').doc(data.projectId).get();
    if (!projectDoc.exists) {
      errors.projectId = 'El proyecto no existe';
    } else {
      const projectType = projectDoc.data().type;
      
      // Validaciones específicas según el tipo de proyecto
      if (projectType === 'hourly') {
        // Validar datos de mano de obra si es proyecto por horas
        if (!data.labor) {
          errors.labor = 'Los datos de mano de obra son obligatorios para proyectos por horas';
        } else {
          if (!isValidTime(data.labor.officialEntry)) {
            errors['labor.officialEntry'] = 'La hora de entrada del oficial debe tener un formato válido';
          }
          
          if (!isValidTime(data.labor.officialExit)) {
            errors['labor.officialExit'] = 'La hora de salida del oficial debe tener un formato válido';
          }
          
          if (!isValidTime(data.labor.workerEntry)) {
            errors['labor.workerEntry'] = 'La hora de entrada del peón debe tener un formato válido';
          }
          
          if (!isValidTime(data.labor.workerExit)) {
            errors['labor.workerExit'] = 'La hora de salida del peón debe tener un formato válido';
          }
        }
      } else if (projectType === 'fixed') {
        // Validar importe facturado si es proyecto de presupuesto cerrado
        if (!isPositiveNumber(data.invoicedAmount)) {
          errors.invoicedAmount = 'El importe facturado debe ser un número positivo';
        }
      }
    }
  }
  
  // Validar trabajo realizado
  if (!data.workPerformed) {
    errors.workPerformed = 'Los datos de trabajo realizado son obligatorios';
  } else if (!isRequired(data.workPerformed.description)) {
    errors['workPerformed.description'] = 'La descripción del trabajo realizado es obligatoria';
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

// Funciones Cloud con región explícita
exports.createProject = onCall(
  functionConfig, 
  async (request) => {
    const data = request.data;
    const context = request.auth;

    console.log("Datos recibidos:", JSON.stringify(data));
    console.log("Contexto de auth:", context ? JSON.stringify(context) : "No autenticado");
    // Verificar autenticación
    if (!context) {
      throw new Error('El usuario debe estar autenticado para crear proyectos');
    }
    
    // Validar datos
    const validationResult = validateProject(data);
    if (!validationResult.isValid) {
      throw new Error(JSON.stringify({
        message: 'Datos de proyecto inválidos',
        details: validationResult.errors
      }));
    }
    
    try {
      // Verificar que no existe un proyecto con el mismo ID
      const existingProjects = await db.collection('projects')
        .where('id', '==', data.id)
        .get();
      
      if (!existingProjects.empty) {
        throw new Error(JSON.stringify({
          message: `Ya existe un proyecto con el ID ${data.id}`
        }));
      }
      
      // Agregar ID de usuario
      const projectData = {
        ...data,
        userId: context.uid,
        createdAt: new Date()
      };
      
      // Crear proyecto
      const docRef = await db.collection('projects').add(projectData);
      
      return { 
        id: docRef.id,
        success: true,
        message: 'Proyecto creado correctamente'
      };
    } catch (error) {
      // Parsear el mensaje de error si es un JSON
      try {
        const errorData = JSON.parse(error.message);
        throw new Error(errorData.message);
      } catch (parseError) {
        throw new Error(error.message);
      }
    }
  }
);

exports.createDailyReport = onCall(
  functionConfig,
  async (request) => {
    const data = request.data;
    const context = request.auth;
    
    // Verificar autenticación
    if (!context) {
      throw new Error('El usuario debe estar autenticado para crear partes diarios');
    }
    
    try {
      // Validar datos
      const validationResult = await validateDailyReport(data);
      if (!validationResult.isValid) {
        throw new Error(JSON.stringify({
          message: 'Datos de parte diario inválidos',
          details: validationResult.errors
        }));
      }
      
      // Agregar ID de usuario y timestamp
      const reportData = {
        ...data,
        userId: context.uid,
        createdAt: new Date()
      };
      
      // Crear parte diario
      const docRef = await db.collection('dailyReports').add(reportData);
      
      return { 
        id: docRef.id,
        success: true,
        message: 'Parte diario creado correctamente'
      };
    } catch (error) {
      // Parsear el mensaje de error si es un JSON
      try {
        const errorData = JSON.parse(error.message);
        throw new Error(errorData.message);
      } catch (parseError) {
        throw new Error(error.message);
      }
    }
  }
);

// Trigger para validación en tiempo real - también con región específica
exports.validateOnCreate = onDocumentCreated(
  {
    document: '{collection}/{docId}',
    region: 'us-central1' // Especificamos la misma región aquí
  },
  async (event) => {
    const snapshot = event.data;
    if (!snapshot) return;

    const collection = event.params.collection;
    const data = snapshot.data();
    
    // Solo procesar colecciones específicas
    if (['projects', 'dailyReports'].includes(collection)) {
      let validationResult;
      
      if (collection === 'projects') {
        validationResult = validateProject(data);
      } else if (collection === 'dailyReports') {
        validationResult = await validateDailyReport(data);
      }
      
      // Si hay errores, registrarlos y potencialmente revertir la operación
      if (validationResult && !validationResult.isValid) {
        console.error(`Validation failed for ${collection}/${snapshot.id}:`, validationResult.errors);
        
        // Opcionalmente: Marcar el documento como inválido en lugar de eliminarlo
        await snapshot.ref.update({
          _validationErrors: validationResult.errors,
          _validationStatus: 'invalid'
        });
      }
    }
  }
);

================
File: functions/package.json
================
{
  "name": "functions",
  "description": "Cloud Functions para la aplicación Partes Diarios",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
  "firebase-admin": "^12.0.0",
  "firebase-functions": "^5.1.0"
},
  "private": true
}

================
File: package.json
================
{
  "name": "partes-diarios",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@react-pdf/renderer": "^4.2.2",
    "@tanstack/react-query": "^5.67.3",
    "file-saver": "^2.0.5",
    "firebase": "^11.4.0",
    "html2canvas": "^1.4.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-firebase-hooks": "^5.1.1",
    "react-scripts": "5.0.1",
    "recharts": "^2.10.3",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "eslint-config-react-app": "^7.0.1",
    "semver": "^7.5.3",
    "shell-quote": "^1.7.3",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "preinstall": "npx npm-force-resolutions"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "resolutions": {
    "postcss": "8.4.31",
    "tough-cookie": "4.1.3",
    "webpack-dev-middleware": "5.3.4",
    "request": "2.88.2",
    "shell-quote": "1.7.3",
    "semver": "7.5.3",
    "nth-check": "2.1.1"
  }
}

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
<title>alqatifa - Partes de trabajo</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: public/manifest.json
================
{
  "short_name": "alqatifa",
  "name": "alqatifa - Partes de trabajo",
   "icons": [
     {
       "src": "favicon.png",
       "sizes": "64x64 32x32 24x24 16x16",
       "type": "image/png"
     },
     {
       "src": "favicon.png",  // También puedes tener versiones más grandes
       "type": "image/png",
       "sizes": "192x192"
     },
     {
       "src": "favicon.png", //  Versión más grande
       "type": "image/png",
       "sizes": "512x512"
     }
   ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: README.md
================
HEAD
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)
=======
# partes-diarios
2189e9e73a0a5b38d0ed3eb8542ce620c56ab919

================
File: src/App.css
================
/* Declaración de fuentes personalizadas */
@font-face {
  font-family: 'Atkinson Hyperlegible';
  src: url('../public/fonts/Atkinson-Hyperlegible-Regular-102.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Cormorant';
  src: url('../public/fonts/Cormorant-Bold.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Quitar la importación anterior de Roboto */
/* @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"); */

.App {
  font-family: "Atkinson Hyperlegible", sans-serif;
  min-height: 100vh;
  background-color: #f5f7fa;
  padding: 20px 0;
}

/* Aplicar Cormorant a todos los encabezados con tamaños aumentados */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cormorant", serif;
}

/* Tamaños específicos para los headings */
h1 {
  font-size: 2.5rem; /* 40px */
}

h2 {
  font-size: 2.1rem; /* 33.6px */
}

h3 {
  font-size: 1.8rem; /* 28.8px */
}

h4 {
  font-size: 1.5rem; /* 24px */
}

h5 {
  font-size: 1.25rem; /* 20px */
}

h6 {
  font-size: 1.1rem; /* 17.6px */
}

.app-header {
  text-align: center;
  margin-bottom: 20px;
}

.app-logo {
  width: 211.5px; /* Mitad de 423px */
  height: 76px; /* Mitad de 152px */
}

.app-container {
  max-width: 1140px;
  margin: 0 auto;
  padding: 0 20px;
  width: 100%;
  box-sizing: border-box;
}

.tab-buttons {
  display: flex;
  gap: 10px;
  margin-bottom: 30px;
}

.tab-buttons button {
  padding: 10px 20px;
  background-color: #2c3e50; /* Color temporal, lo cambiaremos */
  color: white;
  border: none;
  border-radius: 0; /* Bordes rectos */
  cursor: pointer;
  transition: background-color 0.3s ease;
  font-weight: 500;
}

.tab-buttons button:hover {
  background-color: #8D432D; /* Color de acento en hover */
}

.tab-buttons button.active {
  background-color: #8D432D; /* Color de acento para pestaña activa */
}

main {
  background-color: white;
  padding: 30px;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* MODIFICACIÓN: Ajuste para todos los campos de formulario */
input,
select,
textarea {
  padding: 10px;
  margin-top: 5px;
  width: 100%;
  max-width: 100%; /* Cambiado de 400px a 100% */
  box-sizing: border-box; /* CLAVE: incluye padding y border en el ancho total */
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

/* NUEVO: Estilo específico para formularios de login */
.login-form {
  max-width: 400px;
  margin: 0 auto;
}

button {
  padding: 12px 20px;
  background-color: #8D432D; /* Color de acento para botones primarios */
  color: white;
  border: none;
  border-radius: 0; /* Bordes rectos */
  cursor: pointer;
  transition: background-color 0.3s ease;
  font-weight: 500;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono más oscuro del color de acento para hover */
}

h3 {
  margin-top: 30px;
  color: #2c3e50;
  font-weight: 500;
  /* El tamaño se controla ahora con los estilos generales de headings */
}

.error-message {
  color: #e74c3c;
  margin: 5px 0;
  font-size: 14px;
}

.success-message {
  color: #27ae60;
  margin: 5px 0;
  font-size: 14px;
}

.photo-container,
.material-item {
  display: flex;
  align-items: center;
  gap: 15px;
  margin: 10px 0;
  padding: 10px;
  background-color: #fafafa;
  border-radius: 5px;
}

/* Estilos para ReportsViewer */
.reports-viewer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.filter-section {
  margin-bottom: 20px;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border-left: 4px solid #8D432D;
}

.filter-section label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #2c3e50;
  font-size: 1.1rem;
}

.filter-section select {
  margin-bottom: 20px;
}

.date-range {
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.date-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 200px;
}

.date-field label {
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

/* MODIFICACIÓN: Asegurar que los inputs de fecha respeten el ancho */
.date-field input {
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

.report-card {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  margin-bottom: 20px;
}

.edit-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.edit-form button {
  background-color: #8D432D; /* Color de acento para botones en edición */
  border-radius: 0; /* Bordes rectos */
}

.edit-form button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono más oscuro para hover */
}

.photos-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.modal {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
}

.modal button {
  background-color: #8D432D; /* Color de acento para botones en modal */
  border-radius: 0; /* Bordes rectos */
}

.modal button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono más oscuro para hover */
}

/* Estilos para ProjectsViewer */
.projects-viewer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.project-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  margin-bottom: 20px;
}

.project-form input {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

.project-form button {
  background-color: #8D432D; /* Color de acento para botones en formulario */
  border-radius: 0; /* Bordes rectos */
}

.project-form button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono más oscuro para hover */
}

.projects-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.project-card {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.project-card button {
  background-color: #8D432D; /* Color de acento para botones en tarjetas */
  border-radius: 0; /* Bordes rectos */
}

.project-card button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono más oscuro para hover */
}

.edit-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

/* Nuevo estilo para títulos de sección */
.section-title {
  margin-top: 40px;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #8D432D;
  color: #2c3e50;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .app-container {
    padding: 0 15px;
  }

  .tab-buttons {
    flex-direction: column;
    gap: 10px;
  }

  .tab-buttons button {
    width: 100%;
  }

  main {
    padding: 20px;
  }

  input,
  select,
  textarea {
    max-width: 100%;
  }

  .report-card,
  .project-card,
  .project-form {
    padding: 15px;
  }

  .date-range {
    flex-direction: column;
    gap: 15px;
  }

  .date-field {
    min-width: 100%;
  }
}

================
File: src/App.js
================
// src/App.js (Modificado para integrar el Dashboard)
import React, { useState, useEffect } from "react";
import DailyReportForm from "./components/DailyReportForm";
import ReportsViewer from "./components/ReportsViewer";
import ProjectsViewer from "./components/ProjectsViewer";
import Dashboard from "./components/Dashboard"; // Importar el nuevo componente
import LoginForm from "./components/LoginForm";
import { getAuth, onAuthStateChanged } from "firebase/auth";
import { app } from './firebase';
import "./App.css";
import "./components/Dashboard.css"; // Importar los estilos del Dashboard
import DebugFirebase from './components/DebugFirebase';


function App() {
  const [activeTab, setActiveTab] = useState("partes"); // Cambiado a "partes" como tab inicial
  const [user, setUser] = useState(null);

  const auth = getAuth(app);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
    });
    return () => unsubscribe();
  }, [auth]);

  return (
    <div className="App">
      <header className="app-header">
        <img src="/assets/logo.png" alt="Logo" className="app-logo" />
      </header>
      <div className="app-container">
        <nav className="tab-buttons">
  <button
    className={activeTab === "partes" ? "active" : ""}
    onClick={() => setActiveTab("partes")}
  >
    Partes
  </button>
  <button
    className={activeTab === "informes" ? "active" : ""}
    onClick={() => setActiveTab("informes")}
  >
    Informes
  </button>
  <button
    className={activeTab === "proyectos" ? "active" : ""}
    onClick={() => setActiveTab("proyectos")}
  >
    Proyectos
  </button>
  <button
    className={activeTab === "dashboard" ? "active" : ""}
    onClick={() => setActiveTab("dashboard")}
  >
    Dashboard
  </button>
</nav>
        <main>
          {user ? (
            <>
              {activeTab === "dashboard" ? (
                <Dashboard />
              ) : activeTab === "partes" ? (
                <DailyReportForm userId={user.uid} />
              ) : activeTab === "informes" ? (
                <ReportsViewer />
              ) : (
                <ProjectsViewer />
              )}
            </>
          ) : (
            <LoginForm />
          )}
        </main>
      </div>
    </div>
  );
}

export default App;

================
File: src/App.test.js
================
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

================
File: src/components/CompressedImage.js
================
import React, { useState, useEffect } from "react";
import { Image as PDFImage, View, Text } from "@react-pdf/renderer";

// Componente para comprimir imágenes antes de mostrarlas en el PDF
const CompressedImage = ({ src, style, maxWidth = 600, maxHeight = 500, quality = 0.6 }) => {
  const [compressedSrc, setCompressedSrc] = useState(null);
  const [error, setError] = useState(false);

  useEffect(() => {
    const compressImage = async () => {
      if (!src || typeof src !== "string" || !src.startsWith("http")) {
        setError(true);
        return;
      }

      try {
        // Crear un elemento de imagen para cargar la imagen original
        const img = new Image();
        img.crossOrigin = "Anonymous"; // Necesario para imágenes de otros dominios

        img.onload = () => {
          // Crear un canvas para redimensionar y comprimir la imagen
          const canvas = document.createElement("canvas");
          
          // Calcular las nuevas dimensiones manteniendo la proporción
          let width = img.width;
          let height = img.height;
          
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }
          
          if (height > maxHeight) {
            width = (width * maxHeight) / height;
            height = maxHeight;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // Dibujar la imagen redimensionada en el canvas
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, width, height);
          
          // Convertir el canvas a una URL de datos con la calidad especificada
          const compressedDataUrl = canvas.toDataURL("image/jpeg", quality);
          setCompressedSrc(compressedDataUrl);
        };

        img.onerror = () => {
          setError(true);
        };

        // Iniciar la carga de la imagen
        img.src = src;
      } catch (error) {
        console.error("Error al comprimir imagen:", error);
        setError(true);
      }
    };

    compressImage();
  }, [src, maxWidth, maxHeight, quality]);

  if (error) {
    return (
      <View style={{ ...style, backgroundColor: "#f0f0f0", padding: 5 }}>
        <Text style={{ fontSize: 10, textAlign: "center" }}>Imagen no disponible</Text>
      </View>
    );
  }

  return compressedSrc ? <PDFImage src={compressedSrc} style={style} /> : null;
};

export default CompressedImage;

================
File: src/components/DailyReportForm.js
================
import React, { useState, useCallback } from "react";
import { addDoc, collection } from "firebase/firestore";
import { db } from "../firebase";
import ProjectSelector from "./ProjectSelector";
import LaborForm from "./LaborForm";
import MaterialsForm from "./MaterialsForm";
import WorkPerformedForm from "./WorkPerformedForm";
import FixedReportForm from "./FixedReportForm";
import { useLabor } from "../hooks/useLabor";
import { useProjects } from "../hooks/useProjects";
import { formatNumber, getWeekNumber } from "../utils/formatters";

const DailyReportForm = ({ userId }) => { // Recibe userId
  const [selectedProject, setSelectedProject] = useState(null);
  const [report, setReport] = useState({
    reportDate: new Date().toISOString().split("T")[0],
    labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
    materials: [],
    workPerformed: { description: "", photos: [], invoicedAmount: 0 },
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");
  const { projects } = useProjects();
  const laborData = useLabor(report.labor, selectedProject);

  const handleDateChange = useCallback((e) => {
    setReport((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  }, []);

  const handleLaborChange = useCallback((newLabor) => {
    setReport((prev) => ({ ...prev, labor: newLabor }));
  }, []);

  const handleMaterialsChange = useCallback((newMaterials) => {
    setReport((prev) => ({ ...prev, materials: newMaterials }));
  }, []);

  const handleWorkPerformedChange = useCallback((newWorkPerformed) => {
    setReport((prev) => ({ ...prev, workPerformed: { ...prev.workPerformed, ...newWorkPerformed } }));
  }, []);

  const handleInvoicedChange = useCallback((e) => {
    const value = parseFloat(e.target.value) || 0;
    setReport((prev) => ({
      ...prev,
      workPerformed: { ...prev.workPerformed, invoicedAmount: value },
    }));
  }, []);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!selectedProject || !report.reportDate) {
            setErrorMessage("Por favor, completa todos los campos requeridos.");
            setSuccessMessage("");
            return;
        }

        setIsSubmitting(true);
        setErrorMessage("");
        setSuccessMessage("");

        // Inicializa reportData con valores comunes:
        let reportData = {
            projectId: selectedProject.id,
            weekNumber: getWeekNumber(report.reportDate),
            reportDate: report.reportDate,
            workPerformed: report.workPerformed,
            userId: userId, // Usa el userId que recibiste como prop
        };

        if (selectedProject.type === "hourly") {
            // CALCULO DEL TOTAL *ANTES* DE AÑADIRLO AL OBJETO
            const totalMaterialsCost = report.materials.reduce((sum, m) => sum + (m.cost || 0), 0);

            reportData = {
                ...reportData, // Incluye los datos comunes
                labor: { ...report.labor, ...laborData },
                materials: report.materials,
                totalMaterialsCost: totalMaterialsCost, // Usa la variable calculada
                totalCost: laborData.totalLaborCost + totalMaterialsCost,
            };


        } else if (selectedProject.type === "fixed") {
            reportData = { //MUY IMPORTANTE, ASIGNAR A REPORTDATA
                ...reportData,
                invoicedAmount: report.workPerformed.invoicedAmount || 0, // Añadido aquí y se guarda en la BD
            };
        }

        try {
            await addDoc(collection(db, "dailyReports"), reportData);
            setSuccessMessage("Parte guardado correctamente!");
            setReport({
                reportDate: new Date().toISOString().split("T")[0],
                labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
                materials: [],
                workPerformed: { description: "", photos: [], invoicedAmount: 0 }, // Resetear invoicedAmount
            });
            setSelectedProject(null);

        } catch (err) {
            setErrorMessage(`Error al guardar: ${err.message}`);
        } finally {
            setIsSubmitting(false);
        }
    };


  const project = projects.find((p) => p.id === selectedProject?.id);

  return (
    <form onSubmit={handleSubmit}>
      {errorMessage && <p className="error-message">{errorMessage}</p>}
      {successMessage && <p className="success-message">{successMessage}</p>}
      <ProjectSelector onProjectSelect={setSelectedProject} selectedProject={selectedProject} />
      {selectedProject && (
        <>
          <div>
            <label>Fecha del parte</label>
            <input
              type="date"
              name="reportDate"
              value={report.reportDate}
              onChange={handleDateChange}
              required
            />
          </div>
          {project.type === "hourly" ? (
            <>
              <LaborForm labor={report.labor} onLaborChange={handleLaborChange} project={selectedProject} />
              <MaterialsForm
                materials={report.materials}
                onMaterialsChange={handleMaterialsChange}
                projectId={selectedProject.id}
                reportDate={report.reportDate}
              />
            </>
          ) : (
            <FixedReportForm
              workPerformed={report.workPerformed}
              onWorkPerformedChange={handleWorkPerformedChange}
              projectId={selectedProject.id}
              reportDate={report.reportDate}
              onInvoicedChange={handleInvoicedChange}
              invoicedAmount={report.workPerformed.invoicedAmount}
            />
          )}
          <WorkPerformedForm
            workPerformed={report.workPerformed}
            onWorkPerformedChange={handleWorkPerformedChange}
            projectId={selectedProject.id}
            reportDate={report.reportDate}
          />
          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Guardando..." : "Guardar parte"}
          </button>
        </>
      )}
    </form>
  );
};

export default DailyReportForm;

================
File: src/components/Dashboard.css
================
/* src/components/Dashboard.css */

.dashboard {
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
}

/* Métricas en tarjetas */
.metrics-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.metric-card {
  background-color: white;
  border-radius: 8px;
  padding: 15px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.metric-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.metric-icon {
  font-size: 24px;
  margin-bottom: 5px;
}

.metric-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #2c3e50;
  margin: 5px 0;
}

.metric-label {
  font-size: 0.9rem;
  color: #7f8c8d;
}

/* Filtros y selectores */
.dashboard-filter {
  margin-bottom: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 15px;
  border-left: 4px solid #8D432D;
}

.dashboard-filter h3 {
  margin-bottom: 15px;
  color: #2c3e50;
  font-weight: 500;
}

.filter-group {
  margin-bottom: 15px;
}

.filter-group label {
  display: block;
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

.project-selector {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin-bottom: 10px;
  font-size: 14px;
}

/* Estilos para el filtro de fechas (reusados de ReportsViewer) */
.date-range {
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 10px;
  flex-wrap: wrap;
}

.date-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 200px;
}

.date-field label {
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

.date-field input {
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

/* Contenedores de gráficos */
.chart-container, 
.dashboard-section {
  background-color: white;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.chart-wrapper {
  margin-top: 15px;
  margin-bottom: 15px;
  width: 100%;
  /* Importante: permite que el contenedor se adapte al gráfico */
  height: auto;
  overflow: hidden;
}

/* Botones de pestaña para cambiar entre gráficos */
.chart-tab-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 15px;
}

.chart-tab-buttons button {
  flex: 1;
  min-width: calc(50% - 8px);
  padding: 8px 10px;
  background-color: #f0f0f0;
  color: #333;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 13px;
  text-align: center;
  transition: background-color 0.2s;
}

.chart-tab-buttons button.active {
  background-color: #8D432D;
  color: white;
}

/* Tabla de resumen de datos */
.data-summary-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
  margin-top: 15px;
}

.data-summary-table th,
.data-summary-table td {
  padding: 8px;
  text-align: right;
  border-bottom: 1px solid #eee;
}

.data-summary-table th {
  font-weight: bold;
  background-color: #f5f5f5;
  color: #333;
  text-align: center;
}

.data-summary-table td:first-child {
  text-align: left;
}

.data-summary-table tfoot tr {
  font-weight: bold;
  background-color: #f9f9f9;
}

.data-summary-table tfoot td {
  border-top: 2px solid #ddd;
}

/* Dashboard Loading */
.dashboard-loading {
  text-align: center;
  padding: 40px 0;
  color: #666;
  font-style: italic;
}

/* Optimizaciones específicas para móviles */
@media (max-width: 768px) {
  .metrics-container {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .chart-tab-buttons {
    flex-wrap: wrap;
  }
  
  .chart-tab-buttons button {
    flex: 0 0 calc(50% - 5px);
    font-size: 12px;
    padding: 8px 5px;
  }
  
  /* Ajustes para los gráficos en móvil */
  .recharts-cartesian-axis-tick-value {
    font-size: 10px;
  }
  
  /* Reducir el padding en móviles */
  .chart-container, 
  .dashboard-section {
    padding: 10px;
  }
  
  /* Ajustar la tabla */
  .data-summary-table {
    font-size: 12px;
  }
  
  .data-summary-table th,
  .data-summary-table td {
    padding: 5px;
  }
}

/* Ultra pequeñas pantallas (menos de 380px) */
@media (max-width: 380px) {
  .metrics-container {
    grid-template-columns: 1fr;
  }
  
  .metric-card {
    display: flex;
    align-items: center;
    text-align: left;
    padding: 10px;
  }
  
  .metric-icon {
    margin-right: 10px;
    margin-bottom: 0;
  }
  
  .metric-value {
    margin-right: 10px;
  }
  
  .metric-label {
    margin-left: auto;
  }
  
  .chart-tab-buttons button {
    flex: 0 0 100%;
  }
}

================
File: src/components/Dashboard.js
================
// src/components/Dashboard.js
import React, { useState, useEffect, useMemo } from "react";
import { useDailyReports } from "../hooks/useDailyReports";
import { useProjects } from "../hooks/useProjects";
import { formatCurrency, formatNumber } from "../utils/formatters";
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
  LineChart, Line, AreaChart, Area
} from "recharts";

/**
 * Dashboard optimizado para móviles que muestra métricas y gráficos de proyectos
 */
const Dashboard = () => {
  const { allReports } = useDailyReports();
  const { projects } = useProjects();
  const [selectedProject, setSelectedProject] = useState("");
  const [chartType, setChartType] = useState("costes"); // costes, lineas, area, facturacion
  const [loading, setLoading] = useState(true);
  const [dateRange, setDateRange] = useState({ 
    startDate: "", 
    endDate: new Date().toISOString().split("T")[0] // Fecha actual como fecha final por defecto
  });

  // Establecer el primer proyecto como seleccionado por defecto cuando se cargan
  useEffect(() => {
    if (projects.length > 0 && !selectedProject) {
      setSelectedProject(projects[0]?.id || "");
    }
    if (projects.length > 0 && allReports.length > 0) {
      setLoading(false);
    }
  }, [projects, allReports, selectedProject]);

  // Calcular métricas generales
  const dashboardMetrics = useMemo(() => {
    const totalProjects = projects.length;
    
    let totalReports = 0;
    let totalHours = 0;
    let totalCosts = 0;
    let totalMaterials = 0;
    
    // Filtrar informes por fecha si están establecidas
    let filteredReports = [...allReports];
    
    if (dateRange.startDate && dateRange.endDate) {
      const startDate = new Date(dateRange.startDate);
      const endDate = new Date(dateRange.endDate);
      endDate.setHours(23, 59, 59, 999); // Incluir todo el día final
      
      filteredReports = filteredReports.filter(report => {
        const reportDate = new Date(report.reportDate);
        return reportDate >= startDate && reportDate <= endDate;
      });
    }

    filteredReports.forEach(report => {
      totalReports++;
      
      // Sumar horas (solo si existen)
      if (report.labor) {
        totalHours += (report.labor.officialHours || 0) + (report.labor.workerHours || 0);
      }
      
      // Sumar costes
      if (report.totalCost) {
        totalCosts += report.totalCost;
      } else if (report.labor) {
        totalCosts += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
      }
      
      // Sumar materiales
      totalMaterials += report.totalMaterialsCost || 0;
    });

    return {
      totalProjects,
      totalReports,
      totalHours,
      totalCosts,
      totalMaterials
    };
  }, [allReports, projects, dateRange]);

  // Preparar datos para gráficos por proyecto
  const chartData = useMemo(() => {
    if (!selectedProject) return [];

    // Filtrar reportes del proyecto seleccionado y por fecha
    let projectReports = allReports.filter(
      report => report.projectId === selectedProject
    );
    
    // Aplicar filtro de fechas si están definidas
    if (dateRange.startDate && dateRange.endDate) {
      const startDate = new Date(dateRange.startDate);
      const endDate = new Date(dateRange.endDate);
      endDate.setHours(23, 59, 59, 999); // Incluir todo el día final
      
      projectReports = projectReports.filter(report => {
        const reportDate = new Date(report.reportDate);
        return reportDate >= startDate && reportDate <= endDate;
      });
    }

    // Agrupar por fecha (semana o mes)
    const grouped = projectReports.reduce((acc, report) => {
      const date = new Date(report.reportDate);
      const weekKey = `Sem ${report.weekNumber}/${date.getFullYear()}`;
      
      if (!acc[weekKey]) {
        acc[weekKey] = {
          period: weekKey,
          costs: 0,
          materials: 0,
          labor: 0,
          invoiced: 0
        };
      }
      
      // Sumar costes para cada categoría
      const reportCost = report.totalCost || 
        ((report.labor?.totalLaborCost || 0) + (report.totalMaterialsCost || 0));
      
      acc[weekKey].costs += reportCost;
      acc[weekKey].materials += report.totalMaterialsCost || 0;
      acc[weekKey].labor += report.labor?.totalLaborCost || 0;
      acc[weekKey].invoiced += report.invoicedAmount || 0;
      
      return acc;
    }, {});

    // Convertir a array y ordenar por fecha
    return Object.values(grouped).sort((a, b) => {
      const aNum = parseInt(a.period.split(' ')[1].split('/')[0]);
      const bNum = parseInt(b.period.split(' ')[1].split('/')[0]);
      return aNum - bNum;
    });
  }, [allReports, selectedProject, dateRange]);

  // Preparar datos para el gráfico de proyectos
  const projectCostData = useMemo(() => {
    // Aplicar filtro de fecha a todos los reportes
    let filteredReports = [...allReports];
    
    if (dateRange.startDate && dateRange.endDate) {
      const startDate = new Date(dateRange.startDate);
      const endDate = new Date(dateRange.endDate);
      endDate.setHours(23, 59, 59, 999); // Incluir todo el día final
      
      filteredReports = filteredReports.filter(report => {
        const reportDate = new Date(report.reportDate);
        return reportDate >= startDate && reportDate <= endDate;
      });
    }
    
    return projects.map(project => {
      const projectReports = filteredReports.filter(
        report => report.projectId === project.id
      );
      
      let totalCost = 0;
      projectReports.forEach(report => {
        if (report.totalCost) {
          totalCost += report.totalCost;
        } else if (report.labor) {
          totalCost += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
        } else if (report.invoicedAmount) {
          totalCost += report.invoicedAmount || 0;
        }
      });
      
      return {
        name: project.id,
        value: totalCost
      };
    }).sort((a, b) => b.value - a.value).slice(0, 5); // Top 5 proyectos
  }, [allReports, projects, dateRange]);

  const handleProjectChange = (e) => {
    setSelectedProject(e.target.value);
  };
  
  const handleDateRangeChange = (e) => {
    setDateRange((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  };

  if (loading) {
    return <div className="dashboard-loading">Cargando datos...</div>;
  }

  return (
    <div className="dashboard">
      <h2 className="section-title">Dashboard</h2>
      
      {/* Tarjetas de métricas */}
      <div className="metrics-container">
        <div className="metric-card">
          <div className="metric-icon">📊</div>
          <div className="metric-value">{dashboardMetrics.totalProjects}</div>
          <div className="metric-label">Proyectos</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-icon">📝</div>
          <div className="metric-value">{dashboardMetrics.totalReports}</div>
          <div className="metric-label">Partes</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-icon">⏱️</div>
          <div className="metric-value">{formatNumber(dashboardMetrics.totalHours)}</div>
          <div className="metric-label">Horas</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-icon">💰</div>
          <div className="metric-value">€{formatNumber(dashboardMetrics.totalCosts)}</div>
          <div className="metric-label">Costes</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-icon">🔧</div>
          <div className="metric-value">€{formatNumber(dashboardMetrics.totalMaterials)}</div>
          <div className="metric-label">Materiales</div>
        </div>
      </div>
      
      {/* Filtros - Proyecto y Fechas */}
      <div className="dashboard-filter">
        <h3>Filtros</h3>
        
        {/* Selector de proyecto */}
        <div className="filter-group">
          <label htmlFor="project-select">Proyecto:</label>
          <select 
            id="project-select"
            value={selectedProject} 
            onChange={handleProjectChange}
            className="project-selector"
          >
            {projects.map(project => (
              <option key={project.id} value={project.id}>
                {project.id} - {project.client}
              </option>
            ))}
          </select>
        </div>
        
        {/* Filtro de fechas */}
        <div className="date-range">
          <div className="date-field">
            <label htmlFor="start-date">Fecha inicial:</label>
            <input 
              id="start-date"
              type="date" 
              name="startDate" 
              value={dateRange.startDate} 
              onChange={handleDateRangeChange}
            />
          </div>
          <div className="date-field">
            <label htmlFor="end-date">Fecha final:</label>
            <input 
              id="end-date"
              type="date" 
              name="endDate" 
              value={dateRange.endDate} 
              onChange={handleDateRangeChange}
            />
          </div>
        </div>
      </div>
      
      {/* Gráfico de barras del proyecto seleccionado */}
      <div className="chart-container">
        <div className="chart-tab-buttons">
          <button 
            className={chartType === "costes" ? "active" : ""}
            onClick={() => setChartType("costes")}
          >
            Coste Total
          </button>
          <button 
            className={chartType === "desglose" ? "active" : ""}
            onClick={() => setChartType("desglose")}
          >
            Desglose
          </button>
        </div>
        
        <div className="chart-wrapper">
          {chartType === "costes" && (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart
                data={projectCostData}
                margin={{ top: 20, right: 10, left: 10, bottom: 60 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="name" 
                  angle={-45} 
                  textAnchor="end"
                  height={60}
                  interval={0}
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, "Coste Total"]}
                  labelFormatter={(value) => `Proyecto: ${value}`}
                />
                <Bar 
                  dataKey="value" 
                  fill="#8D432D" 
                  name="Coste Total" 
                />
              </BarChart>
            </ResponsiveContainer>
          )}
          
          {chartType === "desglose" && (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart
                data={chartData}
                margin={{ top: 20, right: 10, left: 10, bottom: 30 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="period" 
                  interval={0}
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, ""]}
                />
                <Legend />
                <Bar dataKey="labor" name="Mano de Obra" fill="#2c3e50" />
                <Bar dataKey="materials" name="Materiales" fill="#8D432D" />
              </BarChart>
            </ResponsiveContainer>
          )}
        </div>
      </div>
      
      {/* Tendencias temporales */}
      <div className="dashboard-section">
        <h3>Tendencias Temporales</h3>
        <div className="chart-tab-buttons">
          <button 
            className={chartType === "lineas" ? "active" : ""}
            onClick={() => setChartType("lineas")}
          >
            Líneas
          </button>
          <button 
            className={chartType === "area" ? "active" : ""}
            onClick={() => setChartType("area")}
          >
            Área
          </button>
          <button 
            className={chartType === "facturacion" ? "active" : ""}
            onClick={() => setChartType("facturacion")}
          >
            Facturación
          </button>
          <button 
            className={chartType === "costes" ? "active" : ""}
            onClick={() => setChartType("costes")}
          >
            Costes
          </button>
        </div>
        
        <div className="chart-wrapper">
          {chartType === "lineas" && (
            <ResponsiveContainer width="100%" height={300}>
              <LineChart
                data={chartData}
                margin={{ top: 20, right: 10, left: 10, bottom: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="period" 
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, ""]}
                />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="costs" 
                  name="Costes Totales" 
                  stroke="#8D432D" 
                  activeDot={{ r: 8 }} 
                />
                <Line 
                  type="monotone" 
                  dataKey="labor" 
                  name="Mano de Obra" 
                  stroke="#2c3e50" 
                />
                <Line 
                  type="monotone" 
                  dataKey="materials" 
                  name="Materiales" 
                  stroke="#7A3624" 
                />
              </LineChart>
            </ResponsiveContainer>
          )}
          
          {chartType === "area" && (
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart
                data={chartData}
                margin={{ top: 20, right: 10, left: 10, bottom: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="period" 
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, ""]}
                />
                <Legend />
                <Area 
                  type="monotone" 
                  dataKey="costs" 
                  name="Costes Totales" 
                  stroke="#8D432D" 
                  fill="#8D432D" 
                  fillOpacity={0.3} 
                />
              </AreaChart>
            </ResponsiveContainer>
          )}
          
          {chartType === "facturacion" && (
            <ResponsiveContainer width="100%" height={300}>
              <LineChart
                data={chartData}
                margin={{ top: 20, right: 10, left: 10, bottom: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="period" 
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, ""]}
                />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="invoiced" 
                  name="Facturado" 
                  stroke="#27ae60" 
                  strokeWidth={2}
                  activeDot={{ r: 8 }} 
                />
              </LineChart>
            </ResponsiveContainer>
          )}
          
          {chartType === "costes" && (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart
                data={chartData}
                margin={{ top: 20, right: 10, left: 10, bottom: 20 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="period" 
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  tickFormatter={(value) => `€${value}`}
                  width={60}
                />
                <Tooltip 
                  formatter={(value) => [`€${formatNumber(value)}`, ""]}
                />
                <Legend />
                <Bar 
                  dataKey="costs" 
                  name="Costes Totales" 
                  fill="#8D432D" 
                />
                <Bar 
                  dataKey="labor" 
                  name="Mano de Obra" 
                  fill="#2c3e50" 
                />
                <Bar 
                  dataKey="materials" 
                  name="Materiales" 
                  fill="#7A3624" 
                />
              </BarChart>
            </ResponsiveContainer>
          )}
        </div>
      </div>
      
      {/* Resumen de datos */}
      <div className="dashboard-section">
        <h3>Resumen de Datos</h3>
        <table className="data-summary-table">
          <thead>
            <tr>
              <th>Periodo</th>
              <th>Mano de Obra</th>
              <th>Materiales</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            {chartData.slice(-5).map((item, index) => (
              <tr key={index}>
                <td>{item.period}</td>
                <td>{formatCurrency(item.labor)}</td>
                <td>{formatCurrency(item.materials)}</td>
                <td>{formatCurrency(item.costs)}</td>
              </tr>
            ))}
          </tbody>
          <tfoot>
            <tr>
              <td>TOTAL</td>
              <td>{formatCurrency(chartData.reduce((sum, item) => sum + item.labor, 0))}</td>
              <td>{formatCurrency(chartData.reduce((sum, item) => sum + item.materials, 0))}</td>
              <td>{formatCurrency(chartData.reduce((sum, item) => sum + item.costs, 0))}</td>
            </tr>
          </tfoot>
        </table>
      </div>
    </div>
  );
};

export default Dashboard;

================
File: src/components/dashboard/Dashboard.css
================
/* src/components/dashboard/Dashboard.css */

/* Contenedor principal */
.dashboard-view {
  padding: 20px 0;
}

/* Estilos para los filtros */
.dashboard-view .filter-section {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 30px;
  padding: 15px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border-left: 4px solid #8D432D;
}

.dashboard-view .project-filter {
  flex: 1;
  min-width: 250px;
}

.dashboard-view .date-range {
  display: flex;
  gap: 20px;
  flex: 1;
  min-width: 250px;
}

.dashboard-view .date-field {
  flex: 1;
}

/* Estilos para KPI Cards */
.kpi-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 30px;
}

.kpi-card {
  flex: 1;
  min-width: 180px;
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.kpi-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.kpi-icon {
  font-size: 2rem;
  margin-right: 15px;
  color: #8D432D;
}

.kpi-content h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  color: #2c3e50;
}

.kpi-content p {
  margin: 5px 0 0;
  color: #7f8c8d;
  font-size: 0.9rem;
}

/* Estilos para los gráficos */
.dashboard-charts {
  display: flex;
  flex-direction: column;
  gap: 30px;
  margin-bottom: 30px;
}

.chart-container {
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.chart-wrapper {
  width: 100%;
}

.empty-chart-message {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  background-color: #f9f9f9;
  border-radius: 8px;
  color: #7f8c8d;
}

/* Controles de gráficos */
.chart-controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
}

.chart-type-buttons,
.metric-type-buttons {
  display: flex;
  gap: 10px;
}

.chart-controls button {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s ease;
  color: #2c3e50;
}

.chart-controls button:hover {
  background-color: #e0e0e0;
}

.chart-controls button.active {
  background-color: #8D432D;
  color: white;
}

/* Estilos para el tooltip personalizado */
.custom-tooltip {
  background-color: rgba(255, 255, 255, 0.9);
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.tooltip-label {
  margin: 0 0 5px;
  font-weight: bold;
  color: #2c3e50;
}

.tooltip-client {
  margin: 5px 0 0;
  font-style: italic;
  color: #7f8c8d;
}

/* Resumen de datos */
.summary-section {
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.summary-content {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 15px;
}

.summary-content p {
  margin: 0;
  color: #2c3e50;
}

/* Responsive design */
@media (max-width: 768px) {
  .kpi-container {
    gap: 15px;
  }

  .kpi-card {
    min-width: 100%;
    padding: 15px;
  }
  
  .chart-controls {
    flex-direction: column;
    gap: 10px;
  }
  
  .summary-content {
    grid-template-columns: 1fr;
  }
  
  .dashboard-view .filter-section {
    flex-direction: column;
  }
  
  .dashboard-view .date-range {
    flex-direction: column;
    gap: 10px;
  }
}

================
File: src/components/dashboard/KPICards.js
================
// src/components/dashboard/KPICards.js
import React from "react";
import { formatCurrency, formatNumber } from "../../utils/formatters";

const KPICards = ({ kpis }) => {
  const {
    totalProjects,
    totalReports,
    totalLabor,
    totalMaterials,
    totalInvoiced,
    totalHours
  } = kpis;

  return (
    <div className="kpi-container">
      <div className="kpi-card">
        <div className="kpi-icon">📊</div>
        <div className="kpi-content">
          <h3>{totalProjects}</h3>
          <p>Proyectos</p>
        </div>
      </div>
      
      <div className="kpi-card">
        <div className="kpi-icon">📝</div>
        <div className="kpi-content">
          <h3>{totalReports}</h3>
          <p>Partes</p>
        </div>
      </div>
      
      <div className="kpi-card">
        <div className="kpi-icon">⏱️</div>
        <div className="kpi-content">
          <h3>{formatNumber(totalHours)}</h3>
          <p>Horas</p>
        </div>
      </div>
      
      <div className="kpi-card">
        <div className="kpi-icon">💰</div>
        <div className="kpi-content">
          <h3>{formatCurrency(totalLabor + totalMaterials)}</h3>
          <p>Costes</p>
        </div>
      </div>
      
      {totalInvoiced > 0 && (
        <div className="kpi-card">
          <div className="kpi-icon">💼</div>
          <div className="kpi-content">
            <h3>{formatCurrency(totalInvoiced)}</h3>
            <p>Facturado</p>
          </div>
        </div>
      )}
      
      <div className="kpi-card">
        <div className="kpi-icon">🔧</div>
        <div className="kpi-content">
          <h3>{formatCurrency(totalMaterials)}</h3>
          <p>Materiales</p>
        </div>
      </div>
    </div>
  );
};

export default React.memo(KPICards);

================
File: src/components/dashboard/ProjectCostChart.js
================
// src/components/dashboard/ProjectCostChart.js
import React, { useState } from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer
} from "recharts";
import { formatCurrency } from "../../utils/formatters";

const ProjectCostChart = ({ data }) => {
  const [chartType, setChartType] = useState("cost"); // 'cost' o 'breakdown'

  // Si no hay datos, mostrar mensaje
  if (!data || data.length === 0) {
    return (
      <div className="empty-chart-message">
        <p>No hay datos disponibles para mostrar en el gráfico.</p>
      </div>
    );
  }

  // Ordenar proyectos por costo total (descendente)
  const sortedData = [...data].sort((a, b) => b.totalCost - a.totalCost);
  
  // Limitar a los 10 proyectos más costosos para mejor visualización
  const topProjects = sortedData.slice(0, 10);

  // Configurar tooltip personalizado
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div className="custom-tooltip">
          <p className="tooltip-label">{`Proyecto: ${label}`}</p>
          {payload.map((entry, index) => (
            <p key={index} style={{ color: entry.color }}>
              {`${entry.name}: ${formatCurrency(entry.value)}`}
            </p>
          ))}
          {chartType === "cost" && (
            <p className="tooltip-client">
              {`Cliente: ${data.find((item) => item.id === label)?.client || "Desconocido"}`}
            </p>
          )}
        </div>
      );
    }
    return null;
  };

  return (
    <div className="chart-wrapper">
      <div className="chart-controls">
        <button
          className={chartType === "cost" ? "active" : ""}
          onClick={() => setChartType("cost")}
        >
          Coste Total
        </button>
        <button
          className={chartType === "breakdown" ? "active" : ""}
          onClick={() => setChartType("breakdown")}
        >
          Desglose
        </button>
      </div>

      <ResponsiveContainer width="100%" height={400}>
        <BarChart
          data={topProjects}
          margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis
            dataKey="id"
            angle={-45}
            textAnchor="end"
            height={80}
            interval={0}
          />
          <YAxis
            tickFormatter={(value) => `€${value}`}
            width={70}
          />
          <Tooltip content={<CustomTooltip />} />
          <Legend />

          {chartType === "cost" ? (
            <Bar
              dataKey="totalCost"
              name="Coste Total"
              fill="#8D432D"
              radius={[4, 4, 0, 0]}
            />
          ) : (
            <>
              <Bar
                dataKey="laborCost"
                name="Mano de Obra"
                stackId="a"
                fill="#8D432D"
              />
              <Bar
                dataKey="materialsCost"
                name="Materiales"
                stackId="a"
                fill="#2C3E50"
              />
              <Bar
                dataKey="invoicedAmount"
                name="Facturado"
                fill="#27AE60"
                radius={[4, 4, 0, 0]}
              />
            </>
          )}
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
};

export default React.memo(ProjectCostChart);

================
File: src/components/dashboard/TimelineChart.js
================
// src/components/dashboard/TimelineChart.js
import React, { useState } from "react";
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer
} from "recharts";
import { formatCurrency } from "../../utils/formatters";

const TimelineChart = ({ data }) => {
  const [chartType, setChartType] = useState("line"); // 'line' o 'area'
  const [metricType, setMetricType] = useState("cost"); // 'cost' o 'invoiced'

  // Si no hay datos, mostrar mensaje
  if (!data || data.length === 0) {
    return (
      <div className="empty-chart-message">
        <p>No hay datos disponibles para mostrar en el gráfico.</p>
      </div>
    );
  }

  // Configurar tooltip personalizado
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div className="custom-tooltip">
          <p className="tooltip-label">{`${label}`}</p>
          {payload.map((entry, index) => (
            <p key={index} style={{ color: entry.color }}>
              {`${entry.name}: ${formatCurrency(entry.value)}`}
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  return (
    <div className="chart-wrapper">
      <div className="chart-controls">
        <div className="chart-type-buttons">
          <button
            className={chartType === "line" ? "active" : ""}
            onClick={() => setChartType("line")}
          >
            Líneas
          </button>
          <button
            className={chartType === "area" ? "active" : ""}
            onClick={() => setChartType("area")}
          >
            Área
          </button>
        </div>
        <div className="metric-type-buttons">
          <button
            className={metricType === "cost" ? "active" : ""}
            onClick={() => setMetricType("cost")}
          >
            Costes
          </button>
          <button
            className={metricType === "invoiced" ? "active" : ""}
            onClick={() => setMetricType("invoiced")}
          >
            Facturación
          </button>
        </div>
      </div>

      <ResponsiveContainer width="100%" height={400}>
        {chartType === "line" ? (
          <LineChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="weekLabel" />
            <YAxis
              tickFormatter={(value) => `€${value}`}
              width={70}
            />
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            
            {metricType === "cost" ? (
              <>
                <Line
                  type="monotone"
                  dataKey="totalCost"
                  name="Coste Total"
                  stroke="#8D432D"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                  activeDot={{ r: 6 }}
                />
                <Line
                  type="monotone"
                  dataKey="laborCost"
                  name="Mano de Obra"
                  stroke="#2C3E50"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
                <Line
                  type="monotone"
                  dataKey="materialsCost"
                  name="Materiales"
                  stroke="#3498DB"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              </>
            ) : (
              <Line
                type="monotone"
                dataKey="invoicedAmount"
                name="Facturado"
                stroke="#27AE60"
                strokeWidth={2}
                dot={{ r: 4 }}
                activeDot={{ r: 6 }}
              />
            )}
          </LineChart>
        ) : (
          <AreaChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="weekLabel" />
            <YAxis
              tickFormatter={(value) => `€${value}`}
              width={70}
            />
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            
            {metricType === "cost" ? (
              <>
                <Area
                  type="monotone"
                  dataKey="laborCost"
                  name="Mano de Obra"
                  stackId="1"
                  stroke="#2C3E50"
                  fill="#2C3E50"
                />
                <Area
                  type="monotone"
                  dataKey="materialsCost"
                  name="Materiales"
                  stackId="1"
                  stroke="#3498DB"
                  fill="#3498DB"
                />
              </>
            ) : (
              <Area
                type="monotone"
                dataKey="invoicedAmount"
                name="Facturado"
                stroke="#27AE60"
                fill="#27AE60"
              />
            )}
          </AreaChart>
        )}
      </ResponsiveContainer>
    </div>
  );
};

export default React.memo(TimelineChart);

================
File: src/components/DashboardView.js
================
// src/components/DashboardView.js
import React, { useState, useMemo } from "react";
import { useDailyReports } from "../hooks/useDailyReports";
import { useProjects } from "../hooks/useProjects";
import ProjectCostChart from "./dashboard/ProjectCostChart";
import TimelineChart from "./dashboard/TimelineChart";
import KPICards from "./dashboard/KPICards";
import ProjectSelector from "./ProjectSelector";
import { formatCurrency } from "../utils/formatters";

const DashboardView = () => {
  const [dateRange, setDateRange] = useState({
    startDate: new Date(new Date().setMonth(new Date().getMonth() - 1)).toISOString().split("T")[0],
    endDate: new Date().toISOString().split("T")[0]
  });
  const [selectedProjectId, setSelectedProjectId] = useState("");
  
  const { allReports, loading: reportsLoading, error: reportsError } = useDailyReports();
  const { projects, loading: projectsLoading, error: projectsError } = useProjects();

  // Manejar cambios en el rango de fechas
  const handleDateRangeChange = (e) => {
    const { name, value } = e.target;
    setDateRange((prev) => ({ ...prev, [name]: value }));
  };

  // Manejar cambio de proyecto seleccionado
  const handleProjectSelect = (project) => {
    setSelectedProjectId(project?.id || "");
  };

  // Filtrar reportes por fecha y/o proyecto
  const filteredReports = useMemo(() => {
    let filtered = allReports;

    // Filtrar por fecha
    if (dateRange.startDate && dateRange.endDate) {
      const start = new Date(dateRange.startDate);
      const end = new Date(dateRange.endDate);
      end.setHours(23, 59, 59, 999); // Incluir todo el día final

      filtered = filtered.filter((report) => {
        const reportDate = new Date(report.reportDate);
        return reportDate >= start && reportDate <= end;
      });
    }

    // Filtrar por proyecto si hay uno seleccionado
    if (selectedProjectId) {
      filtered = filtered.filter((report) => report.projectId === selectedProjectId);
    }

    return filtered;
  }, [allReports, dateRange, selectedProjectId]);

  // Calcular KPIs
  const kpis = useMemo(() => {
    const totalProjects = selectedProjectId 
      ? 1 
      : [...new Set(filteredReports.map(r => r.projectId))].length;

    let totalLabor = 0;
    let totalMaterials = 0;
    let totalInvoiced = 0;
    let totalHours = 0;

    filteredReports.forEach(report => {
      // Sumar mano de obra para proyectos por hora
      if (report.labor) {
        totalLabor += report.labor.totalLaborCost || 0;
        totalHours += (report.labor.officialHours || 0) + (report.labor.workerHours || 0);
      }
      
      // Sumar materiales
      totalMaterials += report.totalMaterialsCost || 0;
      
      // Sumar facturado para proyectos de presupuesto cerrado
      if (report.invoicedAmount) {
        totalInvoiced += report.invoicedAmount;
      }
    });

    // Total general (labor + materiales o facturación)
    const totalCost = totalLabor + totalMaterials;
    const totalReports = filteredReports.length;

    return {
      totalProjects,
      totalReports,
      totalLabor,
      totalMaterials,
      totalCost,
      totalInvoiced,
      totalHours
    };
  }, [filteredReports, selectedProjectId]);

  // Datos para el gráfico de costos por proyecto
  const projectCostData = useMemo(() => {
    if (selectedProjectId) return [];
    
    const projectCosts = {};
    
    // Inicializar todos los proyectos con valores a cero
    projects.forEach(project => {
      projectCosts[project.id] = {
        id: project.id,
        client: project.client,
        type: project.type,
        laborCost: 0,
        materialsCost: 0,
        invoicedAmount: 0,
        totalCost: 0
      };
    });
    
    // Sumar costos por proyecto
    filteredReports.forEach(report => {
      const projectId = report.projectId;
      if (!projectCosts[projectId]) return;
      
      if (report.labor) {
        projectCosts[projectId].laborCost += report.labor.totalLaborCost || 0;
      }
      
      projectCosts[projectId].materialsCost += report.totalMaterialsCost || 0;
      
      if (report.invoicedAmount) {
        projectCosts[projectId].invoicedAmount += report.invoicedAmount;
      }
      
      // Calcular costo total dependiendo del tipo de proyecto
      if (projectCosts[projectId].type === "hourly") {
        projectCosts[projectId].totalCost = 
          projectCosts[projectId].laborCost + projectCosts[projectId].materialsCost;
      } else {
        projectCosts[projectId].totalCost = projectCosts[projectId].invoicedAmount;
      }
    });
    
    // Convertir a array y filtrar proyectos sin datos
    return Object.values(projectCosts)
      .filter(project => project.totalCost > 0 || project.invoicedAmount > 0);
  }, [filteredReports, projects, selectedProjectId]);

  // Datos para el gráfico de tendencias temporales
  const timelineData = useMemo(() => {
    if (filteredReports.length === 0) return [];
    
    // Agrupar reportes por semana
    const weeklyData = {};
    
    filteredReports.forEach(report => {
      const date = new Date(report.reportDate);
      // Crear clave para la semana (año-semana)
      const weekKey = `${date.getFullYear()}-W${report.weekNumber}`;
      
      if (!weeklyData[weekKey]) {
        weeklyData[weekKey] = {
          weekLabel: `Sem ${report.weekNumber}/${date.getFullYear()}`,
          laborCost: 0,
          materialsCost: 0,
          invoicedAmount: 0,
          date: date, // Para ordenar cronológicamente
        };
      }
      
      // Sumar costos por semana
      if (report.labor) {
        weeklyData[weekKey].laborCost += report.labor.totalLaborCost || 0;
      }
      
      weeklyData[weekKey].materialsCost += report.totalMaterialsCost || 0;
      
      if (report.invoicedAmount) {
        weeklyData[weekKey].invoicedAmount += report.invoicedAmount;
      }
    });
    
    // Convertir a array y ordenar por fecha
    return Object.values(weeklyData)
      .sort((a, b) => a.date - b.date)
      .map(item => ({
        ...item,
        totalCost: item.laborCost + item.materialsCost
      }));
  }, [filteredReports]);

  // Si hay errores, mostrarlos
  if (reportsError || projectsError) {
    return (
      <div className="error-message">
        {reportsError && <p>Error al cargar reportes: {reportsError}</p>}
        {projectsError && <p>Error al cargar proyectos: {projectsError}</p>}
      </div>
    );
  }

  return (
    <div className="dashboard-view">
      <h2>Dashboard Analítico</h2>
      
      {/* Filtros */}
      <div className="filter-section">
        <div className="project-filter">
          <ProjectSelector 
            onProjectSelect={handleProjectSelect} 
            selectedProject={projects.find(p => p.id === selectedProjectId)}
          />
        </div>
        
        <div className="date-range">
          <div className="date-field">
            <label>Fecha de inicio:</label>
            <input 
              type="date" 
              name="startDate" 
              value={dateRange.startDate} 
              onChange={handleDateRangeChange} 
            />
          </div>
          <div className="date-field">
            <label>Fecha de fin:</label>
            <input 
              type="date" 
              name="endDate" 
              value={dateRange.endDate} 
              onChange={handleDateRangeChange} 
            />
          </div>
        </div>
      </div>
      
      {/* Indicadores de carga */}
      {(reportsLoading || projectsLoading) && <p>Cargando datos del dashboard...</p>}
      
      {/* KPIs */}
      <KPICards kpis={kpis} />
      
      {/* Gráficos */}
      <div className="dashboard-charts">
        {/* Gráfico de costos por proyecto (solo visible cuando no hay proyecto seleccionado) */}
        {!selectedProjectId && (
          <div className="chart-container">
            <h3 className="section-title">Costos por Proyecto</h3>
            <ProjectCostChart data={projectCostData} />
          </div>
        )}
        
        {/* Gráfico de tendencias temporales */}
        <div className="chart-container">
          <h3 className="section-title">Tendencias Temporales</h3>
          <TimelineChart data={timelineData} />
        </div>
      </div>
      
      {/* Resumen de datos */}
      <div className="summary-section">
        <h3 className="section-title">Resumen de Datos</h3>
        <div className="summary-content">
          <p><strong>Período:</strong> {new Date(dateRange.startDate).toLocaleDateString()} - {new Date(dateRange.endDate).toLocaleDateString()}</p>
          <p><strong>Proyectos analizados:</strong> {kpis.totalProjects}</p>
          <p><strong>Partes diarios:</strong> {kpis.totalReports}</p>
          
          {kpis.totalLabor > 0 && (
            <p><strong>Coste mano de obra:</strong> {formatCurrency(kpis.totalLabor)}</p>
          )}
          
          {kpis.totalMaterials > 0 && (
            <p><strong>Coste materiales:</strong> {formatCurrency(kpis.totalMaterials)}</p>
          )}
          
          {kpis.totalInvoiced > 0 && (
            <p><strong>Total facturado:</strong> {formatCurrency(kpis.totalInvoiced)}</p>
          )}
          
          {selectedProjectId && (
            <p><strong>Proyecto seleccionado:</strong> {selectedProjectId}</p>
          )}
        </div>
      </div>
    </div>
  );
};

export default React.memo(DashboardView);

================
File: src/components/DebugFirebase.js
================
// src/components/DebugFirebase.js
import React, { useState } from 'react';
import { getAuth } from 'firebase/auth';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { collection, addDoc, getDocs } from 'firebase/firestore';
import { db } from '../firebase';

const DebugFirebase = () => {
  const [result, setResult] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  const [testMode, setTestMode] = useState('direct'); // 'direct' o 'function'

  // Prueba de la conexión directa a Firestore
  const testDirectFirestore = async () => {
    setLoading(true);
    setError(null);
    setResult(null);
    
    try {
      // 1. Obtener estado de autenticación
      const auth = getAuth();
      const user = auth.currentUser;
      
      if (!user) {
        throw new Error("No hay usuario autenticado. Inicia sesión primero.");
      }
      
      console.log("Usuario autenticado:", {
        uid: user.uid,
        email: user.email,
        isAnonymous: user.isAnonymous
      });
      
      // 2. Intentar escritura directa
      const docRef = await addDoc(collection(db, "debug_collection"), {
        testField: "Esto es una prueba directa a Firestore",
        timestamp: new Date(),
        userId: user.uid
      });
      
      console.log("Documento escrito con ID:", docRef.id);
      
      // 3. Intentar lectura
      const querySnapshot = await getDocs(collection(db, "debug_collection"));
      const docs = [];
      querySnapshot.forEach((doc) => {
        docs.push({ id: doc.id, ...doc.data() });
      });
      
      setResult({
        writeSuccessful: true,
        documentId: docRef.id,
        readSuccessful: true,
        readResults: docs,
        user: {
          uid: user.uid,
          email: user.email
        }
      });
      
    } catch (err) {
      console.error("Error en prueba directa:", err);
      setError(err.toString());
    } finally {
      setLoading(false);
    }
  };
  
  // Prueba de Cloud Functions
  const testCloudFunction = async () => {
    setLoading(true);
    setError(null);
    setResult(null);
    
    try {
      // 1. Obtener estado de autenticación
      const auth = getAuth();
      const user = auth.currentUser;
      
      if (!user) {
        throw new Error("No hay usuario autenticado. Inicia sesión primero.");
      }
      
      // 2. Probar Cloud Function createProject
      const functions = getFunctions();
      const createProject = httpsCallable(functions, 'createProject');
      
      const testProject = {
        id: `test-${Date.now()}`,
        client: "Cliente de Prueba",
        address: "Dirección de Prueba",
        nifNie: "12345678Z",
        type: "hourly",
        officialPrice: 20,
        workerPrice: 15
      };
      
      const result = await createProject(testProject);
      
      setResult({
        functionCallSuccessful: true,
        functionResult: result.data,
        user: {
          uid: user.uid,
          email: user.email
        }
      });
      
    } catch (err) {
      console.error("Error en prueba de Cloud Function:", err);
      setError(err.toString());
    } finally {
      setLoading(false);
    }
  };
  
  const handleTest = () => {
    if (testMode === 'direct') {
      testDirectFirestore();
    } else {
      testCloudFunction();
    }
  };
  
  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <h2>Depuración de Firebase</h2>
      
      <div style={{ marginBottom: '20px' }}>
        <label>
          <input 
            type="radio"
            value="direct"
            checked={testMode === 'direct'}
            onChange={() => setTestMode('direct')}
          /> 
          Prueba directa a Firestore
        </label>
        <label style={{ marginLeft: '20px' }}>
          <input 
            type="radio"
            value="function"
            checked={testMode === 'function'}
            onChange={() => setTestMode('function')}
          /> 
          Prueba de Cloud Function
        </label>
      </div>
      
      <button 
        onClick={handleTest}
        disabled={loading}
        style={{ 
          padding: '10px 20px',
          backgroundColor: '#4CAF50',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: loading ? 'not-allowed' : 'pointer'
        }}
      >
        {loading ? 'Ejecutando prueba...' : 'Ejecutar prueba'}
      </button>
      
      {error && (
        <div style={{ 
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#ffebee',
          border: '1px solid #ffcdd2',
          borderRadius: '4px',
          color: '#c62828'
        }}>
          <h3>Error:</h3>
          <pre style={{ whiteSpace: 'pre-wrap' }}>{error}</pre>
        </div>
      )}
      
      {result && (
        <div style={{ 
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#e8f5e9',
          border: '1px solid #c8e6c9',
          borderRadius: '4px',
          color: '#2e7d32'
        }}>
          <h3>Resultado:</h3>
          <pre style={{ whiteSpace: 'pre-wrap' }}>{JSON.stringify(result, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

export default DebugFirebase;

================
File: src/components/FixedReportForm.js
================
import React, { useCallback } from "react";
import { formatCurrency } from "../utils/formatters";
import ImageUploader from "./ImageUploader"; // Importamos nuestro nuevo componente

const FixedReportForm = ({ workPerformed, onWorkPerformedChange, projectId, reportDate, onInvoicedChange, invoicedAmount }) => {
  const handleDescriptionChange = useCallback((e) => {
    onWorkPerformedChange({ ...workPerformed, description: e.target.value });
  }, [workPerformed, onWorkPerformedChange]);

  // Manejador para las imágenes subidas o eliminadas
  const handleImagesChange = useCallback(
    ({ type, images, id }) => {
      if (type === 'add' && images && images.length > 0) {
        // Añadir nuevas imágenes
        onWorkPerformedChange({
          ...workPerformed,
          photos: [...(workPerformed.photos || []), ...images],
        });
      } else if (type === 'remove' && id) {
        // Eliminar una imagen existente
        onWorkPerformedChange({
          ...workPerformed,
          photos: (workPerformed.photos || []).filter((p) => p.id !== id),
        });
      }
    },
    [workPerformed, onWorkPerformedChange]
  );

  return (
    <div className="fixed-report-form">
      <h3>Trabajos realizados (Presupuesto cerrado)</h3>
      <textarea
        value={workPerformed.description || ""}
        onChange={handleDescriptionChange}
        placeholder="Descripción de los trabajos realizados"
      />
      
      {/* Reemplazamos el input file por nuestro ImageUploader */}
      <ImageUploader
        onImagesUploaded={handleImagesChange}
        folder="photos"
        prefix={`${projectId}_${reportDate}`}
        maxFiles={10}
        acceptedTypes="image/*"
        existingImages={workPerformed.photos || []}
      />
      
      <div>
        <label>Facturado (€)</label>
        <input
          type="number"
          value={invoicedAmount || 0}
          onChange={onInvoicedChange}
          min="0"
          step="0.01"
          placeholder="Importe facturado"
        />
        {invoicedAmount > 0 && <p>Importe facturado: {formatCurrency(invoicedAmount)}</p>}
      </div>
    </div>
  );
};

export default React.memo(FixedReportForm);

================
File: src/components/ImageUploader.css
================
.image-uploader {
  margin: 20px 0;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

.drop-area {
  border: 2px dashed #ccc;
  border-radius: 5px;
  padding: 30px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #f9f9f9;
}

.drop-area.dragging {
  background-color: #e6f7ff;
  border-color: #8D432D;
}

.drop-area:hover {
  background-color: #f0f0f0;
  border-color: #999;
}

.drop-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.upload-icon {
  font-size: 2rem;
  color: #8D432D;
}

.file-info {
  font-size: 0.85rem;
  color: #666;
  margin-top: 5px;
}

.preview-container {
  margin-top: 20px;
}

.previews {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-top: 10px;
  margin-bottom: 15px;
}

.preview-item {
  position: relative;
  width: 150px;
  border-radius: 5px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  background-color: white;
}

.preview-item img {
  width: 100%;
  height: 120px;
  object-fit: cover;
  display: block;
}

.preview-info {
  padding: 8px;
  font-size: 0.8rem;
}

.file-name {
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}

.file-size {
  color: #666;
  font-size: 0.75rem;
}

.remove-button {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
}

.remove-button:hover {
  background-color: rgba(255, 0, 0, 0.7);
}

.upload-button {
  padding: 10px 15px;
  background-color: #8D432D;
  color: white;
  border: none;
  border-radius: 0;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s ease;
  display: block;
  margin-top: 10px;
}

.upload-button:hover:not(:disabled) {
  background-color: #7A3624;
}

.upload-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.upload-errors {
  margin-top: 15px;
  padding: 10px;
  background-color: #fff0f0;
  border-left: 4px solid #e74c3c;
  border-radius: 3px;
}

.error-message {
  color: #e74c3c;
  margin: 5px 0;
  font-size: 0.9rem;
}

.upload-progress {
  font-size: 0.75rem;
  color: #4caf50;
}

.upload-progress.error {
  color: #e74c3c;
}

.existing-images {
  margin-top: 20px;
}

/* Estilos responsivos */
@media (max-width: 768px) {
  .previews {
    justify-content: center;
  }
  
  .preview-item {
    width: 130px;
  }
  
  .preview-item img {
    height: 100px;
  }
}

================
File: src/components/ImageUploader.js
================
import React, { useState, useCallback, useRef } from "react";
import { useStorage } from "../hooks/useStorage";
import "./ImageUploader.css"; // Añadiremos los estilos en un archivo separado

const ImageUploader = ({ 
  onImagesUploaded, 
  folder, 
  prefix, 
  maxFiles = 10, 
  acceptedTypes = "image/*",
  existingImages = []
}) => {
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [uploadProgress, setUploadProgress] = useState({});
  const [uploadErrors, setUploadErrors] = useState([]);
  const fileInputRef = useRef(null);
  
  // eslint-disable-next-line no-unused-vars
  const { uploadFile, uploading, error: uploadError } = useStorage();

  // Prevenir comportamiento por defecto para eventos de arrastrar y soltar
  const preventDefaults = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  // Procesar los archivos seleccionados
  const handleFiles = useCallback((newFiles) => {
    // Filtrar solo imágenes si es necesario
    const imageFiles = newFiles.filter(file => file.type.startsWith('image/'));
    
    // Verificar límite de archivos
    const totalFiles = files.length + imageFiles.length;
    if (totalFiles > maxFiles) {
      alert(`No puedes subir más de ${maxFiles} imágenes a la vez.`);
      return;
    }
    
    // Actualizar estado de archivos
    setFiles(prevFiles => [...prevFiles, ...imageFiles]);
    
    // Crear vistas previas
    imageFiles.forEach(file => {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviews(prevPreviews => [
          ...prevPreviews, 
          { id: Date.now() + Math.random(), file, preview: reader.result }
        ]);
      };
      reader.readAsDataURL(file);
    });
  }, [files, maxFiles]);

  // Manejar entrada en la zona de drop
  const handleDragEnter = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(true);
  }, [preventDefaults]);

  // Manejar salida de la zona de drop
  const handleDragLeave = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(false);
  }, [preventDefaults]);

  // Manejar el evento de soltar archivos
  const handleDrop = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(false);
    
    const droppedFiles = Array.from(e.dataTransfer.files);
    handleFiles(droppedFiles);
  }, [preventDefaults, handleFiles]);

  // Manejar selección de archivos desde el input
  const handleFileSelect = useCallback((e) => {
    const selectedFiles = Array.from(e.target.files);
    handleFiles(selectedFiles);
    // Limpiar el input para permitir seleccionar el mismo archivo de nuevo
    e.target.value = null;
  }, [handleFiles]);

  // Eliminar una imagen de la lista
  const handleRemoveFile = useCallback((id) => {
    setPreviews(prevPreviews => prevPreviews.filter(item => item.id !== id));
    // También actualizamos el array de archivos
    setFiles(prevFiles => {
      const previewToRemove = previews.find(p => p.id === id);
      if (previewToRemove) {
        return prevFiles.filter(f => f !== previewToRemove.file);
      }
      return prevFiles;
    });
  }, [previews]);

  // Eliminar una imagen ya subida
  const handleRemoveExistingImage = useCallback((id) => {
    if (onImagesUploaded && typeof onImagesUploaded === 'function') {
      onImagesUploaded({ type: 'remove', id });
    }
  }, [onImagesUploaded]);

  // Subir todas las imágenes
  const handleUploadAll = useCallback(async () => {
    if (files.length === 0) return;
    
    setUploadErrors([]);
    const uploadedImages = [];
    const newProgress = {};
    
    // Subir cada archivo individualmente
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const preview = previews.find(p => p.file === file);
      
      if (!preview) continue;
      
      try {
        newProgress[preview.id] = 0;
        setUploadProgress(prev => ({ ...prev, [preview.id]: 0 }));
        
        // Aquí usamos tu hook de useStorage
        const url = await uploadFile(file, folder, prefix);
        
        if (url) {
          uploadedImages.push({ id: Date.now() + i, url });
          newProgress[preview.id] = 100;
          setUploadProgress(prev => ({ ...prev, [preview.id]: 100 }));
        } else {
          setUploadErrors(prev => [...prev, `Error al subir ${file.name}`]);
          newProgress[preview.id] = -1;
          setUploadProgress(prev => ({ ...prev, [preview.id]: -1 }));
        }
      } catch (error) {
        console.error("Error al subir imagen:", error);
        setUploadErrors(prev => [...prev, `Error al subir ${file.name}: ${error.message}`]);
        newProgress[preview.id] = -1;
        setUploadProgress(prev => ({ ...prev, [preview.id]: -1 }));
      }
    }
    
    // Limpiar después de subir exitosamente
    if (uploadedImages.length > 0) {
      if (onImagesUploaded && typeof onImagesUploaded === 'function') {
        onImagesUploaded({ type: 'add', images: uploadedImages });
      }
      setFiles([]);
      setPreviews([]);
      setUploadProgress({});
    }
  }, [files, previews, uploadFile, folder, prefix, onImagesUploaded]);

  // Abrir el selector de archivos al hacer clic en el área de drop
  const openFileSelector = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="image-uploader">
      {/* Área para arrastrar y soltar */}
      <div 
        className={`drop-area ${isDragging ? 'dragging' : ''}`}
        onDragEnter={handleDragEnter}
        onDragOver={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={openFileSelector}
      >
        <input 
          type="file" 
          ref={fileInputRef}
          accept={acceptedTypes}
          multiple 
          onChange={handleFileSelect}
          style={{ display: 'none' }}
        />
        <div className="drop-message">
          <i className="upload-icon">📁</i>
          <p>Arrastra imágenes aquí o haz clic para seleccionarlas</p>
          <span className="file-info">Acepta múltiples imágenes (máx. {maxFiles})</span>
        </div>
      </div>
      
      {/* Vista previa de imágenes seleccionadas */}
      {previews.length > 0 && (
        <div className="preview-container">
          <h4>Imágenes seleccionadas ({previews.length})</h4>
          <div className="previews">
            {previews.map((item) => (
              <div key={item.id} className="preview-item">
                <img src={item.preview} alt="Vista previa" />
                <div className="preview-info">
                  <span className="file-name">{item.file.name}</span>
                  <span className="file-size">{(item.file.size / 1024).toFixed(1)} KB</span>
                  {uploadProgress[item.id] !== undefined && (
                    <div className={`upload-progress ${uploadProgress[item.id] === -1 ? 'error' : ''}`}>
                      {uploadProgress[item.id] === -1 ? 
                        'Error' : 
                        `${uploadProgress[item.id]}%`
                      }
                    </div>
                  )}
                </div>
                <button 
                  className="remove-button" 
                  onClick={() => handleRemoveFile(item.id)}
                  title="Eliminar"
                >
                  ×
                </button>
              </div>
            ))}
          </div>
          <button 
            className="upload-button" 
            onClick={handleUploadAll}
            disabled={uploading || previews.length === 0}
          >
            {uploading ? 'Subiendo...' : 'Subir todas las imágenes'}
          </button>
        </div>
      )}
      
      {/* Mostrar errores */}
      {uploadErrors.length > 0 && (
        <div className="upload-errors">
          <h4>Errores de carga</h4>
          <ul>
            {uploadErrors.map((error, index) => (
              <li key={index} className="error-message">{error}</li>
            ))}
          </ul>
        </div>
      )}
      
      {/* Imágenes ya subidas */}
      {existingImages && existingImages.length > 0 && (
        <div className="existing-images">
          <h4>Imágenes subidas ({existingImages.length})</h4>
          <div className="previews">
            {existingImages.map((image) => (
              <div key={image.id} className="preview-item">
                <img src={image.url} alt="Imagen subida" />
                <button 
                  className="remove-button" 
                  onClick={() => handleRemoveExistingImage(image.id)}
                  title="Eliminar"
                >
                  ×
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default ImageUploader;

================
File: src/components/LaborForm.js
================
import React, { useCallback, useEffect } from "react";
import { useLabor } from "../hooks/useLabor";
import { formatNumber, formatCurrency } from "../utils/formatters";

const LaborForm = ({ labor, onLaborChange, project }) => {
  const calculatedLabor = useLabor(labor, project);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    let newLabor = { ...labor, [name]: value };

    // Si se cambia una hora del oficial, copiar al peón automáticamente
    if (name === "officialEntry") {
      newLabor.workerEntry = value; // Copiar entrada del oficial al peón
    } else if (name === "officialExit") {
      newLabor.workerExit = value; // Copiar salida del oficial al peón
    }

    onLaborChange(newLabor);
  }, [labor, onLaborChange]);

  // Efecto para sincronizar las horas iniciales si ya existen
  useEffect(() => {
    if (labor.officialEntry && !labor.workerEntry) {
      onLaborChange({ ...labor, workerEntry: labor.officialEntry });
    }
    if (labor.officialExit && !labor.workerExit) {
      onLaborChange({ ...labor, workerExit: labor.officialExit });
    }
  }, [labor, onLaborChange]);

  return (
    <div className="labor-form">
      <h3>Mano de obra</h3>
      <div className="labor-row">
        <div className="labor-field">
          <label>Hora entrada oficial</label>
          <input
            type="time"
            name="officialEntry"
            value={labor.officialEntry}
            onChange={handleChange}
            className="time-input"
          />
        </div>
        <div className="labor-field">
          <label>Hora salida oficial</label>
          <input
            type="time"
            name="officialExit"
            value={labor.officialExit}
            onChange={handleChange}
            className="time-input"
          />
        </div>
      </div>
      <div className="labor-row">
        <div className="labor-field">
          <label>Hora entrada peón</label>
          <input
            type="time"
            name="workerEntry"
            value={labor.workerEntry}
            onChange={handleChange}
            className="time-input"
          />
        </div>
        <div className="labor-field">
          <label>Hora salida peón</label>
          <input
            type="time"
            name="workerExit"
            value={labor.workerExit}
            onChange={handleChange}
            className="time-input"
          />
        </div>
      </div>
      {project && (
        <div className="labor-summary">
          <p>
            Oficial: {formatNumber(calculatedLabor.officialHours)} h - {formatCurrency(calculatedLabor.officialCost)}
          </p>
          <p>
            Peón: {formatNumber(calculatedLabor.workerHours)} h - {formatCurrency(calculatedLabor.workerCost)}
          </p>
          <p>
            Total: {formatCurrency(calculatedLabor.totalLaborCost)}
          </p>
        </div>
      )}
    </div>
  );
};

export default React.memo(LaborForm);

================
File: src/components/LoginForm.js
================
// src/components/LoginForm.js
import React, { useState } from 'react';
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "firebase/auth";
import { app } from '../firebase'; // Importa 'app' desde tu archivo firebase.js

function LoginForm() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [isRegistering, setIsRegistering] = useState(false); // Controla si el usuario se registra o inicia sesión
    const [error, setError] = useState(null);
    const [user, setUser] = useState(null); // Almacena la información del usuario

    const auth = getAuth(app);

    // Lista blanca de correos electrónicos permitidos (¡Ajusta esto a tus necesidades!)
    const allowedEmails = ['info@alqatifa.com', 'jesusmabas@gmail.com']; // ¡Coma agregada!

    const handleSubmit = async (event) => {
        event.preventDefault();
        setError(null); // Limpia errores anteriores

        try {
            if (isRegistering) {
                // --- VERIFICACIÓN DE LISTA BLANCA (solo para registro) ---
                if (!allowedEmails.includes(email)) {
                    setError('Este correo electrónico no está autorizado para registrarse.');
                    return; // Detiene la ejecución si el correo no es válido
                }

                // --- REGISTRO (si el correo es válido) ---
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                setUser(userCredential.user);
                console.log("Usuario registrado:", userCredential.user);
            } else {
                // --- INICIO DE SESIÓN (sin cambios) ---
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                setUser(userCredential.user);
                console.log("Usuario logueado:", userCredential.user);
            }
        } catch (error) {
            setError(error.message); // Muestra el mensaje de error de Firebase
            console.error("Error:", error);
        }
    };

    const handleSignOut = async () => {
        try {
            await signOut(auth);
            setUser(null);
            console.log("Usuario deslogueado");
        } catch (error) {
            setError(error.message);
            console.error("Error al desloguear:", error);
        }
    };

    return (
        <div>
            {user ? ( // Muestra información del usuario si está logueado
                <div>
                    <p>Bienvenido, {user.email}</p>
                    <button onClick={handleSignOut}>Cerrar Sesión</button>
                </div>
            ) : (
                <form onSubmit={handleSubmit} className="login-form">
                    <h2>{isRegistering ? 'Registrarse' : 'Iniciar Sesión'}</h2>
                    {error && <p style={{ color: 'red' }}>{error}</p>}
                    <div>
                        <label htmlFor="email">Correo Electrónico:</label>
                        <input
                            type="email"
                            id="email"
                            value={email}
                            onChange={(e) => setEmail(e.target.value)}
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="password">Contraseña:</label>
                        <input
                            type="password"
                            id="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required
                        />
                    </div>
                    <button type="submit">{isRegistering ? 'Registrarse' : 'Iniciar Sesión'}</button>
                    <button type="button" onClick={() => setIsRegistering(!isRegistering)}>
                        {isRegistering ? '¿Ya tienes cuenta? Inicia Sesión' : '¿No tienes cuenta? Regístrate'}
                    </button>
                </form>
            )}
        </div>
    );
}

export default LoginForm;

================
File: src/components/MaterialsForm.js
================
import React, { useState, useCallback } from "react";
import { useStorage } from "../hooks/useStorage";
import { formatCurrency } from "../utils/formatters";

const MaterialsForm = ({ materials, onMaterialsChange, projectId, reportDate }) => {
  const [newMaterial, setNewMaterial] = useState({ description: "", cost: "" });
  const { uploadFile, uploading, error: uploadError } = useStorage();

  const handleInputChange = useCallback((e) => {
    // Muy importante, parsear el coste a Float.
    const { name, value } = e.target;
     const updatedValue = name === "cost" ? parseFloat(value) : value;
    setNewMaterial((prev) => ({ ...prev, [name]: updatedValue }));

  }, []);


    const handleAddMaterial = useCallback(async (e) => {
        const file = e.target.files[0];
        //Validar que se haya añadido una descripción y un coste
        if (!file || !newMaterial.description || !newMaterial.cost) {
            alert("Por favor, añade una descripción, un coste y una factura (PDF)");
        return; // Error manejado por uploadError
        }

        const url = await uploadFile(file, "invoices", `${projectId}_${reportDate}`);
        if (url) {
        const newMat = { id: Date.now(), description: newMaterial.description, cost: parseFloat(newMaterial.cost), invoiceUrl: url }; //Asegúrate de que sea Float
        onMaterialsChange([...materials, newMat]);
        setNewMaterial({ description: "", cost: "" });
        e.target.value = null;
        }
    }, [newMaterial, materials, onMaterialsChange, projectId, reportDate, uploadFile]);


  const handleRemoveMaterial = useCallback((id) => {
    onMaterialsChange(materials.filter((m) => m.id !== id));
  }, [materials, onMaterialsChange]);

  return (
    <div>
      <h3>Materiales</h3>
      <input
        type="text"
        name="description"
        placeholder="Descripción del material"
        value={newMaterial.description}
        onChange={handleInputChange}
      />
      <input
        type="number"
        name="cost"
        placeholder="Coste (€)"
        value={newMaterial.cost}
        onChange={handleInputChange}
        min="0"
        step="0.01"
      />
      <input type="file" accept=".pdf" onChange={handleAddMaterial} disabled={uploading} />
      {uploading && <p>Subiendo...</p>}
      {uploadError && <p className="error-message">Error: {uploadError}</p>}
      {materials.map((m) => (
        <div key={m.id} className="material-item">
          <p>
            {m.description} - {formatCurrency(m.cost)} (
            <a href={m.invoiceUrl} target="_blank" rel="noopener noreferrer">Ver PDF</a>)
          </p>
          <button onClick={() => handleRemoveMaterial(m.id)}>Eliminar</button>
        </div>
      ))}
    </div>
  );
};

export default React.memo(MaterialsForm);

================
File: src/components/PDFExportExample.js
================
// src/components/PDFExportExample.js
import React from 'react';
import { Document, Page, Text, View, StyleSheet } from '@react-pdf/renderer';
import PDFDownloadButton from '../utils/PdfDownload';

// Definir estilos para el PDF
const styles = StyleSheet.create({
  page: {
    flexDirection: 'column',
    backgroundColor: '#FFFFFF',
    padding: 30,
  },
  section: {
    margin: 10,
    padding: 10,
    flexGrow: 1,
  },
  title: {
    fontSize: 24,
    textAlign: 'center',
    fontFamily: 'Helvetica-Bold',
    marginBottom: 20,
  },
  text: {
    fontSize: 12,
    fontFamily: 'Helvetica',
    marginBottom: 10,
  },
  table: {
    display: 'table',
    width: 'auto',
    borderStyle: 'solid',
    borderWidth: 1,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    marginTop: 20,
  },
  tableRow: {
    flexDirection: 'row',
  },
  tableColHeader: {
    width: '25%',
    borderStyle: 'solid',
    borderWidth: 1,
    borderLeftWidth: 0,
    borderTopWidth: 0,
    backgroundColor: '#f0f0f0',
    padding: 5,
  },
  tableCol: {
    width: '25%',
    borderStyle: 'solid',
    borderWidth: 1,
    borderLeftWidth: 0,
    borderTopWidth: 0,
    padding: 5,
  },
  tableCellHeader: {
    fontFamily: 'Helvetica-Bold',
    fontSize: 10,
  },
  tableCell: {
    fontSize: 10,
  },
});

// Componente PDF Document
const MyDocument = ({ data = {}, title = 'Reporte' }) => (
  <Document>
    <Page size="A4" style={styles.page}>
      <View style={styles.section}>
        <Text style={styles.title}>{title}</Text>
        <Text style={styles.text}>Fecha: {new Date().toLocaleDateString()}</Text>
        <Text style={styles.text}>Generado por: {data.author || 'Usuario'}</Text>
        
        {data.items && data.items.length > 0 && (
          <View style={styles.table}>
            {/* Encabezados de tabla */}
            <View style={styles.tableRow}>
              <View style={styles.tableColHeader}>
                <Text style={styles.tableCellHeader}>ID</Text>
              </View>
              <View style={styles.tableColHeader}>
                <Text style={styles.tableCellHeader}>Nombre</Text>
              </View>
              <View style={styles.tableColHeader}>
                <Text style={styles.tableCellHeader}>Cantidad</Text>
              </View>
              <View style={styles.tableColHeader}>
                <Text style={styles.tableCellHeader}>Precio</Text>
              </View>
            </View>
            
            {/* Filas de datos */}
            {data.items.map((item, index) => (
              <View style={styles.tableRow} key={index}>
                <View style={styles.tableCol}>
                  <Text style={styles.tableCell}>{item.id}</Text>
                </View>
                <View style={styles.tableCol}>
                  <Text style={styles.tableCell}>{item.name}</Text>
                </View>
                <View style={styles.tableCol}>
                  <Text style={styles.tableCell}>{item.quantity}</Text>
                </View>
                <View style={styles.tableCol}>
                  <Text style={styles.tableCell}>{item.price}</Text>
                </View>
              </View>
            ))}
          </View>
        )}
        
        <Text style={[styles.text, { marginTop: 30 }]}>
          {data.summary || 'Este es un PDF de ejemplo generado con @react-pdf/renderer.'}
        </Text>
      </View>
    </Page>
  </Document>
);

// Componente de ejemplo que utiliza el botón de descarga
const PDFExportExample = () => {
  // Datos de ejemplo para el PDF
  const exampleData = {
    author: 'Administrador',
    items: [
      { id: '001', name: 'Item 1', quantity: 5, price: '€100.00' },
      { id: '002', name: 'Item 2', quantity: 3, price: '€75.50' },
      { id: '003', name: 'Item 3', quantity: 8, price: '€45.00' },
    ],
    summary: 'Este reporte muestra los items seleccionados con sus cantidades y precios.'
  };

  return (
    <div className="pdf-export-example">
      <h2>Exportar a PDF</h2>
      <p>Haga clic en el botón de abajo para generar y descargar un PDF de ejemplo:</p>
      
      <PDFDownloadButton
        Document={MyDocument}
        documentProps={{ data: exampleData, title: 'Reporte de Items' }}
        fileName="reporte-ejemplo.pdf"
        buttonProps={{ className: 'pdf-button' }}
      >
        Descargar Reporte PDF
      </PDFDownloadButton>
    </div>
  );
};

export default PDFExportExample;
export { MyDocument }; // Exportamos el componente Document para reutilizarlo

================
File: src/components/ProjectForm.js
================
// src/components/ProjectForm.js
import React, { useState } from "react";
import { getFunctions, httpsCallable } from "firebase/functions";
import useFormValidation from "../hooks/useFormValidation";
import { projectSchema } from "../utils/validationSchemas";
import { formatCurrency } from "../utils/formatters";

const ProjectForm = ({ onProjectAdded }) => {
  const [serverError, setServerError] = useState(null);
  const [serverSuccess, setServerSuccess] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Valores iniciales del formulario
  const initialValues = {
    id: "",
    client: "",
    address: "",
    nifNie: "",
    type: "hourly",
    officialPrice: 0,
    workerPrice: 0,
    budgetAmount: 0
  };

  // Usar nuestro hook personalizado para formularios
  const {
    values,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    hasError,
    getError,
    isValid
  } = useFormValidation(initialValues, projectSchema);

  // Función para manejar el envío del formulario
  const submitForm = async (formData) => {
    setIsSubmitting(true);
    setServerError(null);
    setServerSuccess(null);
    
    try {
      // Usar Cloud Functions para validación server-side
      const functions = getFunctions();
      const createProject = httpsCallable(functions, 'createProject');
      
      // Enviar datos para validación y creación
      const result = await createProject(formData);
      
      // Manejar respuesta exitosa
      setServerSuccess(result.data.message || 'Proyecto añadido correctamente');
      resetForm();
      
      // Notificar al componente padre
      if (onProjectAdded && typeof onProjectAdded === 'function') {
        onProjectAdded(result.data);
      }
    } catch (error) {
      // Manejar errores
      console.error("Error al crear proyecto:", error);
      setServerError(error.message || 'Error al crear el proyecto');
      
      // Si hay errores de validación específicos del servidor
      if (error.details && typeof error.details === 'object') {
        // Aquí se podrían mostrar errores específicos por campo
        setServerError(`Error de validación: ${Object.values(error.details).join(', ')}`);
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(submitForm)} className="project-form">
      {serverError && <p className="error-message">{serverError}</p>}
      {serverSuccess && <p className="success-message">{serverSuccess}</p>}

      {/* ID del Proyecto */}
      <div className="form-group">
        <label htmlFor="project-id">ID del proyecto</label>
        <input
          id="project-id"
          type="text"
          name="id"
          value={values.id}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('id') ? 'input-error' : ''}
          placeholder="Identificador único del proyecto"
        />
        {hasError('id') && <p className="error-message">{getError('id')}</p>}
      </div>

      {/* Cliente */}
      <div className="form-group">
        <label htmlFor="project-client">Cliente</label>
        <input
          id="project-client"
          type="text"
          name="client"
          value={values.client}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('client') ? 'input-error' : ''}
          placeholder="Nombre del cliente"
        />
        {hasError('client') && <p className="error-message">{getError('client')}</p>}
      </div>

      {/* Dirección */}
      <div className="form-group">
        <label htmlFor="project-address">Dirección</label>
        <input
          id="project-address"
          type="text"
          name="address"
          value={values.address}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('address') ? 'input-error' : ''}
          placeholder="Dirección del proyecto"
        />
        {hasError('address') && <p className="error-message">{getError('address')}</p>}
      </div>

      {/* NIF/NIE */}
      <div className="form-group">
        <label htmlFor="project-nifnie">NIF/NIE</label>
        <input
          id="project-nifnie"
          type="text"
          name="nifNie"
          value={values.nifNie}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('nifNie') ? 'input-error' : ''}
          placeholder="NIF o NIE del cliente"
        />
        {hasError('nifNie') && <p className="error-message">{getError('nifNie')}</p>}
      </div>

      {/* Tipo de Proyecto */}
      <div className="form-group">
        <label htmlFor="project-type">Tipo de proyecto</label>
        <select
          id="project-type"
          name="type"
          value={values.type}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('type') ? 'input-error' : ''}
        >
          <option value="hourly">Por horas</option>
          <option value="fixed">Presupuesto cerrado</option>
        </select>
        {hasError('type') && <p className="error-message">{getError('type')}</p>}
      </div>

      {/* Campos específicos según el tipo */}
      {values.type === "hourly" ? (
        <>
          <div className="form-group">
            <label htmlFor="project-official-price">Precio oficial (€/h)</label>
            <input
              id="project-official-price"
              type="number"
              name="officialPrice"
              value={values.officialPrice}
              onChange={handleChange}
              onBlur={handleBlur}
              className={hasError('officialPrice') ? 'input-error' : ''}
              min="0"
              step="0.01"
              placeholder="Precio por hora del oficial"
            />
            {hasError('officialPrice') && <p className="error-message">{getError('officialPrice')}</p>}
          </div>

          <div className="form-group">
            <label htmlFor="project-worker-price">Precio peón (€/h)</label>
            <input
              id="project-worker-price"
              type="number"
              name="workerPrice"
              value={values.workerPrice}
              onChange={handleChange}
              onBlur={handleBlur}
              className={hasError('workerPrice') ? 'input-error' : ''}
              min="0"
              step="0.01"
              placeholder="Precio por hora del peón"
            />
            {hasError('workerPrice') && <p className="error-message">{getError('workerPrice')}</p>}
          </div>
        </>
      ) : (
        <div className="form-group">
          <label htmlFor="project-budget">Importe presupuestado (€)</label>
          <input
            id="project-budget"
            type="number"
            name="budgetAmount"
            value={values.budgetAmount}
            onChange={handleChange}
            onBlur={handleBlur}
            className={hasError('budgetAmount') ? 'input-error' : ''}
            min="0"
            step="0.01"
            placeholder="Importe total presupuestado"
          />
          {hasError('budgetAmount') && <p className="error-message">{getError('budgetAmount')}</p>}
        </div>
      )}

      {/* Botón de envío */}
      <button
        type="submit"
        disabled={isSubmitting || !isValid}
        className={!isValid ? 'button-disabled' : ''}
      >
        {isSubmitting ? "Añadiendo..." : "Añadir proyecto"}
      </button>

      {/* Botón para resetear el formulario */}
      <button
        type="button"
        onClick={() => resetForm()}
        disabled={isSubmitting}
        className="button-secondary"
      >
        Limpiar formulario
      </button>
    </form>
  );
};

export default ProjectForm;

================
File: src/components/ProjectSelector.js
================
import React from "react";
import { useProjects } from "../hooks/useProjects";

const ProjectSelector = ({ onProjectSelect, selectedProject }) => {
  const { projects, loading, error } = useProjects();

  const handleChange = (e) => {
    const selectedProjectId = e.target.value; // Mejor legibilidad
    const project = projects.find((p) => p.id === selectedProjectId);
    onProjectSelect(project);
  };

  if (loading) return <p>Cargando proyectos...</p>;
  if (error) return <p className="error-message">Error: {error}</p>;

  return (
    <div>
      <label>ID del Proyecto</label>
      <select onChange={handleChange} value={selectedProject?.id || ""} required>
        <option value="">Selecciona un proyecto</option>
        {projects.map((p) => (
          <option key={p.id} value={p.id}>{p.id}</option>
        ))}
      </select>
      {selectedProject && (
        <div>
          <p>Dirección: {selectedProject.address}</p>
          <p>Cliente: {selectedProject.client}</p>
          <p>NIF/NIE: {selectedProject.nifNie}</p>
          {/* SÓLO MUESTRA PRECIOS SI ES POR HORAS */}
          {selectedProject.type === "hourly" && (
            <>
              <p>Precio oficial: {selectedProject.officialPrice} €/h</p>
              <p>Precio peón: {selectedProject.workerPrice} €/h</p>
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default React.memo(ProjectSelector);

================
File: src/components/ProjectsViewer.js
================
import React, { useState, useCallback } from "react";
import { useProjects } from "../hooks/useProjects";
import { formatCurrency } from "../utils/formatters";
import { useDailyReports } from "../hooks/useDailyReports";

const ProjectsViewer = () => {
  const { projects, loading, error, addProject, updateProject, deleteProject } = useProjects();
  const { allReports } = useDailyReports(); // Para calcular costes
  const [newProject, setNewProject] = useState({ id: "", client: "", address: "", nifNie: "", officialPrice: 0, workerPrice: 0, type: "hourly", budgetAmount: 0 });
  const [editingProjectId, setEditingProjectId] = useState(null);
  const [editedProject, setEditedProject] = useState(null);
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");

  const handleInputChange = useCallback((e) => {
    const { name, value } = e.target;
    if (editingProjectId) {
      setEditedProject((prev) => ({ ...prev, [name]: name === "officialPrice" || name === "workerPrice" || name === "budgetAmount" ? parseFloat(value) || 0 : value }));
    } else {
      setNewProject((prev) => ({ ...prev, [name]: name === "officialPrice" || name === "workerPrice" || name === "budgetAmount" ? parseFloat(value) || 0 : value }));
    }
  }, [editingProjectId]);

  const handleTypeChange = useCallback((e) => {
    if (editingProjectId) {
      setEditedProject((prev) => ({ ...prev, type: e.target.value, officialPrice: e.target.value === "hourly" ? prev.officialPrice : 0, workerPrice: e.target.value === "hourly" ? prev.workerPrice : 0 }));
    } else {
      setNewProject((prev) => ({ ...prev, type: e.target.value, officialPrice: e.target.value === "hourly" ? prev.officialPrice : 0, workerPrice: e.target.value === "hourly" ? prev.workerPrice : 0 }));
    }
  }, [editingProjectId]);

 const handleAddProject = async (e) => {
  e.preventDefault();
  if (!newProject.id || !newProject.client || !newProject.address || !newProject.nifNie || !newProject.type) {
    setErrorMessage("Por favor, completa todos los campos requeridos (ID, Cliente, Dirección, NIF/NIE, Tipo).");
    setSuccessMessage("");
    return;
  }

  try {
    // Crear una copia del proyecto con el ID recortado
    const trimmedProject = {
      ...newProject,
      id: newProject.id.trim()
    };
    await addProject(trimmedProject);  // Usamos la función del hook
    setNewProject({ id: "", client: "", address: "", nifNie: "", officialPrice: 0, workerPrice: 0, type: "hourly", budgetAmount: 0 });
    setSuccessMessage("Proyecto añadido correctamente!");
    setErrorMessage("");
  } catch (err) {
    setErrorMessage(`Error al añadir proyecto: ${err.message}`);
  }
};

  const startEditing = (project) => {
    setEditingProjectId(project.id);
    setEditedProject({ ...project });
  };

  const handleEditSubmit = async (e) => {
    e.preventDefault();
    if (!editedProject.id || !editedProject.client || !editedProject.address || !editedProject.nifNie || !editedProject.type) {
      setErrorMessage("Por favor, completa todos los campos requeridos (ID, Cliente, Dirección, NIF/NIE, Tipo).");
      return;
    }

    try {
      await updateProject(editedProject.id, editedProject); // Usamos la función del hook
      setEditingProjectId(null);
      setEditedProject(null);
      setSuccessMessage("Proyecto actualizado correctamente!");
      setErrorMessage("");
    } catch (err) {
      setErrorMessage(`Error al actualizar proyecto: ${err.message}`);
    }
  };

  const handleDelete = async (projectId) => {
    console.log("handleDelete llamado con projectId:", projectId);
    if (!window.confirm("¿Estás seguro de que quieres eliminar este proyecto? Esta acción no se puede deshacer.")) {
      console.log("Eliminación cancelada por el usuario");
      return; // <---  IMPORTANTE: Detener la ejecución si el usuario cancela.
    }

    try {
      console.log("Intentando eliminar proyecto:", projectId);
      await deleteProject(projectId); // Usamos la función del hook
      setSuccessMessage("Proyecto eliminado correctamente!");
      setErrorMessage(""); // Limpiar errores anteriores
    } catch (err) {
      console.error("Error en handleDelete:", err);
      setErrorMessage(`Error al eliminar proyecto: ${err.message}`);
      setSuccessMessage(""); // Limpiar mensaje de éxito si hay error
    }
  };

  const calculateProjectCosts = (projectId, projectType) => {
    if (projectType !== "hourly") return { laborCost: 0, materialsCost: 0, totalCost: 0 };
    const projectReports = allReports.filter((report) => report.projectId === projectId);
    let laborCost = 0;
    let materialsCost = 0;

    projectReports.forEach((report) => {
      laborCost += report.labor?.totalLaborCost || 0;
      materialsCost += report.totalMaterialsCost || 0;
    });

    return {
      laborCost,
      materialsCost,
      totalCost: laborCost + materialsCost,
    };
  };

  const calculateInvoicedTotal = (projectId) => {
    const projectReports = allReports.filter((report) => report.projectId === projectId && report.invoicedAmount);
    return projectReports.reduce((sum, report) => sum + (report.invoicedAmount || 0), 0);
  };

  if (loading) return <p>Cargando proyectos...</p>;
  if (error) return <p className="error-message">Error: {error}</p>;

  return (
    <div className="projects-viewer">
      <h2>Proyectos</h2>
      {errorMessage && <p className="error-message">{errorMessage}</p>}
      {successMessage && <p className="success-message">{successMessage}</p>}

      <form onSubmit={handleAddProject} className="project-form">
        <input
          type="text"
          name="id"
          placeholder="ID del proyecto"
          value={newProject.id}
          onChange={handleInputChange}
        />
        <input
          type="text"
          name="client"
          placeholder="Cliente"
          value={newProject.client}
          onChange={handleInputChange}
        />
        <input
          type="text"
          name="address"
          placeholder="Dirección"
          value={newProject.address}
          onChange={handleInputChange}
        />
        <input
          type="text"
          name="nifNie"
          placeholder="NIF/NIE"
          value={newProject.nifNie}
          onChange={handleInputChange}
        />
        <select name="type" value={newProject.type} onChange={handleTypeChange}>
          <option value="hourly">Por horas</option>
          <option value="fixed">Presupuesto cerrado</option>
        </select>
        {newProject.type === "hourly" ? (
          <>
            <input
              type="number"
              name="officialPrice"
              placeholder="Precio oficial (€/h)"
              value={newProject.officialPrice}
              onChange={handleInputChange}
              min="0"
              step="0.01"
            />
            <input
              type="number"
              name="workerPrice"
              placeholder="Precio peón (€/h)"
              value={newProject.workerPrice}
              onChange={handleInputChange}
              min="0"
              step="0.01"
            />
          </>
        ) : (
          <input
            type="number"
              name="budgetAmount"
              placeholder="Importe presupuestado (€)"
              value={newProject.budgetAmount}
              onChange={handleInputChange}
              min="0"
              step="0.01"
          />
        )}
        <button type="submit" disabled={loading}>
          {loading ? "Añadiendo..." : "Añadir proyecto"}
        </button>
      </form>

      <div className="projects-list">
        {projects.map((project) => {
          const costs = calculateProjectCosts(project.id, project.type);
          const invoicedTotal = project.type === "fixed" ? calculateInvoicedTotal(project.id) : 0;
          const isEditing = editingProjectId === project.id;

          return (
            <div key={project.id} className="project-card">
              {isEditing ? (
                <form onSubmit={handleEditSubmit} className="edit-form">
                  <input
                    type="text"
                    name="id"
                    value={editedProject.id}
                    onChange={handleInputChange}
                    disabled
                  />
                  <input
                    type="text"
                    name="client"
                    value={editedProject.client}
                    onChange={handleInputChange}
                  />
                  <input
                    type="text"
                    name="address"
                    value={editedProject.address}
                    onChange={handleInputChange}
                  />
                  <input
                    type="text"
                    name="nifNie"
                    value={editedProject.nifNie}
                    onChange={handleInputChange}
                  />
                  <select name="type" value={editedProject.type} onChange={handleTypeChange}>
                    <option value="hourly">Por horas</option>
                    <option value="fixed">Presupuesto cerrado</option>
                  </select>
                  {editedProject.type === "hourly" ? (
                    <>
                      <input
                        type="number"
                        name="officialPrice"
                        value={editedProject.officialPrice}
                        onChange={handleInputChange}
                        min="0"
                        step="0.01"
                      />
                      <input
                        type="number"
                        name="workerPrice"
                        value={editedProject.workerPrice}
                        onChange={handleInputChange}
                        min="0"
                        step="0.01"
                      />
                    </>
                  ) : (
                    <input
                      type="number"
                      name="budgetAmount"
                      value={editedProject.budgetAmount}
                      onChange={handleInputChange}
                      min="0"
                      step="0.01"
                    />
                  )}
                  <button type="submit">Guardar cambios</button>
                  <button type="button" onClick={() => setEditingProjectId(null)}>
                    Cancelar
                  </button>
                </form>
              ) : (
                <>
                  <p><strong>ID:</strong> {project.id}</p>
                  <p><strong>Cliente:</strong> {project.client}</p>
                  <p><strong>Dirección:</strong> {project.address}</p>
                  <p><strong>NIF/NIE:</strong> {project.nifNie}</p>
                  <p><strong>Tipo:</strong> {project.type === "hourly" ? "Por horas" : "Presupuesto cerrado"}</p>
                  {project.type === "hourly" ? (
                    <>
                      <p><strong>Precio oficial:</strong> {formatCurrency(project.officialPrice)}/h</p>
                      <p><strong>Precio peón:</strong> {formatCurrency(project.workerPrice)}/h</p>
                    </>
                  ) : (
                    <p><strong>Importe presupuestado:</strong> {formatCurrency(project.budgetAmount)}</p>
                  )}
                  <h5>Resumen de costes</h5>
                  {project.type === "hourly" ? (
                    <>
                      <p>Mano de obra: {formatCurrency(costs.laborCost)}</p>
                      <p>Materiales: {formatCurrency(costs.materialsCost)}</p>
                      <p>Total: {formatCurrency(costs.totalCost)}</p>
                    </>
                  ) : (
                    <p><strong>Importe facturado total:</strong> {formatCurrency(invoicedTotal)}</p>
                  )}
                  <button onClick={() => startEditing(project)}>Editar</button>
                  <button
  onClick={() => handleDelete(project.id)}
  style={{ backgroundColor: "#e74c3c", marginLeft: "10px" }}
>
  Eliminar
</button>
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default React.memo(ProjectsViewer);

================
File: src/components/ReportPDFGenerator.js
================
import React from "react";
import { Document, Page, Text, View, StyleSheet, Image, Link, Font } from "@react-pdf/renderer";
import CompressedImage from "./CompressedImage";
import { formatNumber, formatCurrency, formatFullDate } from "../utils/formatters";

// Registrar las fuentes personalizadas
Font.register({
  family: 'AtkinsonHyperlegible',
  fonts: [
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'normal', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'normal', fontStyle: 'italic' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'bold', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'bold', fontStyle: 'italic' }
  ]
});

Font.register({
  family: 'Cormorant',
  fonts: [
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'normal', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'normal', fontStyle: 'italic' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'bold', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'bold', fontStyle: 'italic' }
  ]
});

const styles = StyleSheet.create({
  // Estilo optimizado para la página
  page: { 
    padding: 18, 
    fontSize: 11, 
    fontFamily: "AtkinsonHyperlegible", 
    flexDirection: "column", 
    height: "100%" 
  },
  // Portada con estructura optimizada
  coverPage: {
    padding: 20,
    display: "flex",
    flexDirection: "column",
    height: "100%",
    justifyContent: "space-between",
    fontFamily: "AtkinsonHyperlegible"
  },
  logoSection: {
    flex: 1,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
  },
  logo: { 
    width: 100, 
    height: 36
  },
  contentContainer: {
    marginTop: "auto",
  },
  title: { 
    fontSize: 20, 
    fontWeight: "bold", 
    marginBottom: 25, 
    textAlign: "center", 
    fontFamily: "Cormorant" 
  },
  detailsTable: { display: "table", width: "100%", marginBottom: 18 },
  detailsRow: { flexDirection: "row" },
  detailsColLeft: { width: "50%", padding: 4, fontSize: 11 },
  detailsColRight: { width: "50%", padding: 4, textAlign: "right", fontSize: 11 },
  footer: { fontSize: 11, textAlign: "right", marginTop: 10 },
  
  // Secciones con margen vertical optimizado
  section: { marginBottom: 12 },
  sectionTitle: { 
    fontSize: 16, 
    fontWeight: "bold", 
    marginTop: 16, 
    marginBottom: 8, 
    fontFamily: "Cormorant" 
  },
  text: { fontSize: 11, marginBottom: 4 },
  link: { color: "#007bff", textDecoration: "underline", fontSize: 11 },
  
  // Imágenes que respetan el aspect ratio
  image: { height: 150, objectFit: "contain", margin: 4, border: "1px solid #000" },
  imageRow: { flexDirection: "row", flexWrap: "wrap", justifyContent: "flex-start" },
  
  // Tablas mejor espaciadas
  table: { display: "table", width: "100%", borderStyle: "solid", borderWidth: 1, borderColor: "#000", marginTop: 8, marginBottom: 8 },
  tableRow: { flexDirection: "row", borderBottomWidth: 1, borderBottomColor: "#000" },
  tableHeader: { backgroundColor: "#f0f0f0", fontWeight: "bold", fontSize: 11 },
  tableCol: { width: "25%", borderRightWidth: 1, borderRightColor: "#000", padding: 4, fontSize: 11 },
  tableColWide: { width: "50%", borderRightWidth: 1, borderRightColor: "#000", padding: 4, fontSize: 11 },
  tableColLast: { width: "25%", padding: 4, fontSize: 11 },
  
  // Resumen de costos
  costSummary: { display: "table", width: "100%", borderStyle: "solid", borderWidth: 1, borderColor: "#000", marginTop: 12, marginBottom: 12 },
  costRow: { flexDirection: "row", borderBottomWidth: 1, borderBottomColor: "#000" },
  costColLabel: { width: "70%", padding: 4, fontWeight: "bold", fontSize: 11 },
  costColValue: { width: "30%", padding: 4, textAlign: "right", fontSize: 11 },
  
  // Mensajes de error de imagen
  errorImage: { width: 180, height: 150, backgroundColor: "#f0f0f0", textAlign: "center", padding: 5, fontSize: 10 },
  
  // Tabla de presupuesto
  budgetTable: {
    display: "table",
    width: "100%",
    borderStyle: "solid",
    borderWidth: 1,
    borderColor: "#000",
    marginTop: 8,
    marginBottom: 8
  },
  budgetRow: {
    flexDirection: "row",
    borderBottomWidth: 1,
    borderBottomColor: "#000",
  },
  budgetTableHeader: {
    backgroundColor: "#f0f0f0",
    fontWeight: "bold",
    fontSize: 11,
    padding: 4,
    textAlign: "center",
    width: "50%",
  },
  budgetTableCell: {
    padding: 4,
    fontSize: 11,
    width: "50%",
    textAlign: "left",
  },
  budgetTableCellAmount: {
    padding: 4,
    fontSize: 11,
    width: "50%",
    textAlign: "right",
  },
  
  // Página de resumen
  summaryPage: { 
    padding: 20, 
    fontSize: 11, 
    fontFamily: "AtkinsonHyperlegible", 
    flexDirection: "column" 
  },
  summaryTitle: { 
    fontSize: 20, 
    fontWeight: "bold", 
    marginBottom: 20, 
    textAlign: "center", 
    fontFamily: "Cormorant" 
  },
  summaryTable: { 
    display: "table", 
    width: "100%", 
    borderStyle: "solid", 
    borderWidth: 1, 
    borderColor: "#000", 
    marginBottom: 20 
  },
  summaryRow: { 
    flexDirection: "row", 
    borderBottomWidth: 1, 
    borderBottomColor: "#000" 
  },
  summaryLastRow: { 
    flexDirection: "row" 
  },
  summaryColLabel: { 
    width: "70%", 
    padding: 6, 
    fontSize: 11, 
    borderRightWidth: 1, 
    borderRightColor: "#000", 
    backgroundColor: "#f9f9f9" 
  },
  summaryColValue: { 
    width: "30%", 
    padding: 6, 
    fontSize: 11, 
    textAlign: "right" 
  },
  summaryHeaderRow: { 
    flexDirection: "row", 
    borderBottomWidth: 1, 
    borderBottomColor: "#000", 
    backgroundColor: "#f0f0f0" 
  },
  summaryHeaderCol: { 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    textAlign: "center" 
  },
  summaryTotalRow: { 
    flexDirection: "row", 
    backgroundColor: "#f0f0f0" 
  },
  summaryTotalLabel: { 
    width: "70%", 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    borderRightWidth: 1, 
    borderRightColor: "#000" 
  },
  summaryTotalValue: { 
    width: "30%", 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    textAlign: "right" 
  },
  summaryNote: {
    fontSize: 10,
    fontStyle: "normal",
    marginTop: 15,
    textAlign: "center",
    color: "#666"
  },
  
  // Estilos para el nuevo diseño de 2 columnas
  mainHeader: {
    marginBottom: 10,
  },
  twoColumns: {
    flexDirection: "row",
    marginBottom: 12,
  },
  leftColumn: {
    width: "48%",
    marginRight: "2%",
  },
  rightColumn: {
    width: "48%",
    marginLeft: "2%",
  },
  fullWidth: {
    width: "100%",
    marginBottom: 12,
  },
  subSectionTitle: {
    fontSize: 14,
    fontWeight: "bold",
    marginTop: 6,
    marginBottom: 4,
    fontFamily: "Cormorant"
  },
  materialsList: {
    marginTop: 4,
    marginBottom: 4,
  },
  materialItem: {
    fontSize: 11,
    marginBottom: 2,
  },
  workDescription: {
    marginTop: 4,
    marginBottom: 8,
  },
});

const ReportPDFGenerator = ({ reports, projects }) => {
  const firstReport = reports[0];
  const project = projects.find((p) => p.id === firstReport?.projectId) || {};
  const currentDate = new Date().toLocaleDateString("es-ES", { weekday: "long", day: "numeric", month: "long", year: "numeric" });

  // Función para generar el título con soporte para múltiples semanas
  const renderTitle = () => {
    if (!reports || reports.length === 0) {
      return "Acta de obra";
    }
    
    // Obtener todos los números de semana únicos
    const uniqueWeeks = [...new Set(reports.map(report => report.weekNumber))].sort((a, b) => a - b);
    const year = new Date(firstReport.reportDate).getFullYear();
    
    // Si hay una sola semana
    if (uniqueWeeks.length === 1) {
      return `Acta semanal de obra - Semana ${uniqueWeeks[0]} - Año ${year}`;
    }
    
    // Si son semanas consecutivas
    if (uniqueWeeks.length === uniqueWeeks[uniqueWeeks.length - 1] - uniqueWeeks[0] + 1) {
      return `Acta semanal de obra - Semanas ${uniqueWeeks[0]} a ${uniqueWeeks[uniqueWeeks.length - 1]} - Año ${year}`;
    }
    
    // Si son semanas no consecutivas
    return `Acta semanal de obra - Semanas ${uniqueWeeks.join(', ')} - Año ${year}`;
  };

  const renderImage = (src) => {
    try {
      if (!src || typeof src !== "string" || !src.startsWith("http")) {
        return (
          <View style={styles.errorImage}>
            <Text>Imagen no disponible</Text>
          </View>
        );
      }
      // Usar el componente CompressedImage en lugar de Image directamente
      return <CompressedImage 
              src={src} 
              style={styles.image} 
              maxWidth={600} 
              maxHeight={500} 
              quality={0.5} // Puedes ajustar la calidad aquí (0.1 a 1)
            />;
    } catch (error) {
      console.error("Error al cargar imagen en PDF:", error);
      return (
        <View style={styles.errorImage}>
          <Text>Imagen no disponible</Text>
        </View>
      );
    }
  };

  // Calcular importe facturado total para proyectos "fixed"
  const calculateInvoicedTotal = (projectId) => {
    const projectReports = reports.filter((report) => report.projectId === projectId && report.invoicedAmount);
    return projectReports.reduce((sum, report) => sum + (report.invoicedAmount || 0), 0);
  };

  // Calcular totales para la página de resumen
  const calculateTotals = () => {
    let totalLabor = 0;
    let totalMaterials = 0;
    let totalCost = 0;
    let totalInvoiced = 0;

    reports.forEach(report => {
      // Para proyectos por horas
      if (report.labor) {
        totalLabor += report.labor.totalLaborCost || 0;
      }
      
      totalMaterials += report.totalMaterialsCost || 0;
      
      // El coste total puede venir directamente o calcularse
      if (report.totalCost) {
        totalCost += report.totalCost;
      } else if (report.labor) {
        // Si no existe totalCost pero sí labor, calculamos la suma
        totalCost += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
      }

      // Para proyectos de presupuesto cerrado
      if (report.invoicedAmount) {
        totalInvoiced += report.invoicedAmount;
      }
    });

    return {
      totalLabor,
      totalMaterials,
      totalCost,
      totalInvoiced
    };
  };

  const totals = calculateTotals();
  const isHourlyProject = project.type === "hourly";

  return (
    <Document>
      {/* Portada */}
      <Page size="A4" style={styles.coverPage}>
        <View style={styles.logoSection}>
          <Image src={`${process.env.PUBLIC_URL}/assets/logo.png`} style={styles.logo} />
        </View>
        <View style={styles.contentContainer}>
          <Text style={styles.title}>
            {renderTitle()}
          </Text>
          <View style={styles.detailsTable}>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>Promotor: {project.client || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>Redactado por: Jesús Moral Abásolo</Text>
            </View>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>NIF/NIE: {project.nifNie || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>NIF: 75902042H</Text>
            </View>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>Proyecto: {project.address || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>Arquitecto técnico y artesano</Text>
            </View>
          </View>
          <Text style={styles.footer}>{currentDate}</Text>
        </View>
      </Page>

      {/* Páginas por parte diario - NUEVO LAYOUT */}
      {reports.map((report, index) => {
        const project = projects.find((p) => p.id === report.projectId) || {};
        const isHourly = project.type === "hourly";
        const budgetAmount = project.budgetAmount || 0;
        const invoicedTotal = project.type === "fixed" ? calculateInvoicedTotal(project.id) : 0;
        const remainingToInvoice = budgetAmount - invoicedTotal;

        return (
          <Page key={`report-${index}`} size="A4" style={styles.page}>
            {/* Cabecera del parte */}
            <View style={styles.mainHeader}>
              <Text style={styles.sectionTitle}>Fecha: {formatFullDate(report.reportDate)}</Text>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                <Text style={{ fontSize: 11, marginRight: 20 }}>Semana: {report.weekNumber}</Text>
                <Text style={{ fontSize: 11, marginRight: 20 }}>Proyecto: {report.projectId || "No disponible"}</Text>
                <Text style={{ fontSize: 11 }}>Cliente: {project.client || "No disponible"}</Text>
              </View>
              <Text style={{ fontSize: 11 }}>Dirección: {project.address || "No disponible"}</Text>
            </View>

            {/* Distribución en dos columnas para MO y Materiales */}
            <View style={styles.twoColumns}>
              {/* Columna izquierda - Mano de obra */}
              <View style={styles.leftColumn}>
                {isHourly ? (
                  <>
                    <Text style={styles.subSectionTitle}>Mano de obra</Text>
                    <View style={styles.table}>
                      <View style={[styles.tableRow, styles.tableHeader]}>
                        <Text style={styles.tableColWide}> </Text>
                        <Text style={styles.tableCol}>Oficial</Text>
                        <Text style={styles.tableCol}>Peón</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Hora de entrada</Text>
                        <Text style={styles.tableCol}>{report.labor?.officialEntry || "--:--"}</Text>
                        <Text style={styles.tableCol}>{report.labor?.workerEntry || "--:--"}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Hora de salida</Text>
                        <Text style={styles.tableCol}>{report.labor?.officialExit || "--:--"}</Text>
                        <Text style={styles.tableCol}>{report.labor?.workerExit || "--:--"}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Horas trabajadas</Text>
                        <Text style={styles.tableCol}>{formatNumber(report.labor?.officialHours || 0)}</Text>
                        <Text style={styles.tableCol}>{formatNumber(report.labor?.workerHours || 0)}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Coste</Text>
                        <Text style={styles.tableCol}>{formatCurrency(report.labor?.officialCost || 0)}</Text>
                        <Text style={styles.tableCol}>{formatCurrency(report.labor?.workerCost || 0)}</Text>
                      </View>
                    </View>
                    <Text style={{ fontSize: 11, marginTop: 4 }}>Coste total mano de obra: {formatCurrency(report.labor?.totalLaborCost || 0)}</Text>
                  </>
                ) : (
                  <>
                    <Text style={styles.subSectionTitle}>Presupuesto cerrado</Text>
                    <View style={styles.budgetTable}>
                      <View style={styles.budgetRow}>
                        <Text style={styles.budgetTableHeader}>Concepto</Text>
                        <Text style={styles.budgetTableHeader}>Importe</Text>
                      </View>
                      <View style={styles.budgetRow}>
                        <Text style={styles.budgetTableCell}>Importe presupuestado</Text>
                        <Text style={styles.budgetTableCellAmount}>{formatCurrency(budgetAmount)}</Text>
                      </View>
                      <View style={styles.budgetRow}>
                        <Text style={styles.budgetTableCell}>Importe facturado</Text>
                        <Text style={styles.budgetTableCellAmount}>{formatCurrency(invoicedTotal)}</Text>
                      </View>
                      <View style={styles.budgetRow}>
                        <Text style={styles.budgetTableCell}>Importe restante</Text>
                        <Text style={styles.budgetTableCellAmount}>{formatCurrency(remainingToInvoice)}</Text>
                      </View>
                    </View>
                  </>
                )}
              </View>

              {/* Columna derecha - Materiales */}
              <View style={styles.rightColumn}>
                <Text style={styles.subSectionTitle}>Materiales</Text>
                <View style={styles.materialsList}>
                  {report.materials && report.materials.length > 0 ? (
                    <>
                      <Text style={{ fontSize: 11, marginBottom: 4 }}>Descripción materiales comprados:</Text>
                      {report.materials.map((m, i) => (
                        <Text key={`material-desc-${i}`} style={styles.materialItem}>
                          - {m.description || "Sin descripción"}
                        </Text>
                      ))}
                      <Text style={{ fontSize: 11, marginTop: 6, marginBottom: 2 }}>Albaranes/facturas:</Text>
                      {report.materials.map((m, i) => (
                        <Text key={`material-invoice-${i}`} style={styles.materialItem}>
                          Factura {i + 1} (
                          <Link src={m.invoiceUrl} style={styles.link}>
                            Descargar PDF
                          </Link>
                          )
                        </Text>
                      ))}
                    </>
                  ) : (
                    <Text style={{ fontSize: 11 }}>No hay materiales registrados.</Text>
                  )}
                  <Text style={{ fontSize: 11, marginTop: 6 }}>Coste total de materiales: {formatCurrency(report.totalMaterialsCost || 0)}</Text>
                </View>
              </View>
            </View>

            {/* Resumen de costes (ancho completo) */}
            {isHourly && (
              <View style={styles.fullWidth}>
                <Text style={styles.subSectionTitle}>Coste total MO + materiales</Text>
                <View style={styles.costSummary}>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total mano de obra</Text>
                    <Text style={styles.costColValue}>{formatCurrency(report.labor?.totalLaborCost || 0)}</Text>
                  </View>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total de materiales</Text>
                    <Text style={styles.costColValue}>{formatCurrency(report.totalMaterialsCost || 0)}</Text>
                  </View>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total MO + materiales</Text>
                    <Text style={styles.costColValue}>{formatCurrency(report.totalCost || 0)}</Text>
                  </View>
                </View>
              </View>
            )}

            {/* Trabajos realizados (ancho completo) */}
            <View style={styles.fullWidth}>
              <Text style={styles.subSectionTitle}>Trabajos realizados</Text>
              <View style={styles.workDescription}>
                <Text style={{ fontSize: 11 }}>{report.workPerformed?.description || "Sin descripción"}</Text>
              </View>
            </View>

            {/* Fotografías (ancho completo) */}
            <View style={styles.fullWidth}>
              <Text style={styles.subSectionTitle}>Fotografías</Text>
              <View style={styles.imageRow}>
                {report.workPerformed?.photos?.map((photo, i) => (
                  <View key={`photo-${i}`}>{renderImage(photo.url)}</View>
                ))}
                {(!report.workPerformed?.photos || report.workPerformed.photos.length === 0) && (
                  <Text style={{ fontSize: 11 }}>No hay fotografías disponibles</Text>
                )}
              </View>
            </View>
          </Page>
        );
      })}

      {/* Página de resumen de totales */}
      <Page size="A4" style={styles.summaryPage}>
        <Text style={styles.summaryTitle}>
          Resumen de Totales - Proyecto {project.id}
        </Text>
        
        <View style={styles.detailsTable}>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Promotor: {project.client || "No disponible"}</Text>
            <Text style={styles.detailsColRight}>Fecha: {currentDate}</Text>
          </View>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Proyecto: {project.address || "No disponible"}</Text>
            <Text style={styles.detailsColRight}>Tipo: {isHourlyProject ? "Por horas" : "Presupuesto cerrado"}</Text>
          </View>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Período: {renderTitle().replace('Acta semanal de obra - ', '')}</Text>
            <Text style={styles.detailsColRight}>Total partes: {reports.length}</Text>
          </View>
        </View>

        {isHourlyProject ? (
          <View style={styles.summaryTable}>
            <View style={styles.summaryHeaderRow}>
              <Text style={{...styles.summaryHeaderCol, width: "70%"}}>Concepto</Text>
              <Text style={{...styles.summaryHeaderCol, width: "30%"}}>Importe</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Total mano de obra</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(totals.totalLabor)}</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Total materiales</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(totals.totalMaterials)}</Text>
            </View>
            <View style={styles.summaryTotalRow}>
              <Text style={styles.summaryTotalLabel}>TOTAL GENERAL</Text>
              <Text style={styles.summaryTotalValue}>{formatCurrency(totals.totalCost)}</Text>
            </View>
          </View>
        ) : (
          <View style={styles.summaryTable}>
            <View style={styles.summaryHeaderRow}>
              <Text style={{...styles.summaryHeaderCol, width: "70%"}}>Concepto</Text>
              <Text style={{...styles.summaryHeaderCol, width: "30%"}}>Importe</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Importe presupuestado</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(project.budgetAmount || 0)}</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Total facturado</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(totals.totalInvoiced)}</Text>
            </View>
            <View style={styles.summaryTotalRow}>
              <Text style={styles.summaryTotalLabel}>Importe restante</Text>
              <Text style={styles.summaryTotalValue}>{formatCurrency((project.budgetAmount || 0) - totals.totalInvoiced)}</Text>
            </View>
          </View>
        )}

        <Text style={styles.summaryNote}>
          Este resumen incluye todos los partes diarios seleccionados en el rango de fechas especificado.
        </Text>
      </Page>
    </Document>
  );
};

export default ReportPDFGenerator;

================
File: src/components/ReportsViewer.js
================
import React, { useState, useCallback, useEffect, useMemo } from "react";
import { useDailyReports } from "../hooks/useDailyReports";
import { formatCurrency, formatNumber, getWeekNumber } from "../utils/formatters";
import ReportPDFGenerator from "./ReportPDFGenerator";
import { PDFDownloadLink } from "@react-pdf/renderer";
import { useProjects } from "../hooks/useProjects";
import { updateDoc, doc } from "firebase/firestore";
import { db } from "../firebase";
import { useStorage } from "../hooks/useStorage";

const ReportsViewer = () => {
  const [dateRange, setDateRange] = useState({ startDate: "", endDate: "" });
  const [selectedProjectId, setSelectedProjectId] = useState("");
  const [showPDFLink, setShowPDFLink] = useState(false);
  const [reportToDelete, setReportToDelete] = useState(null);
  const [editingReportId, setEditingReportId] = useState(null);
  const [editedReport, setEditedReport] = useState(null);
  const [pdfDisabledReason, setPdfDisabledReason] = useState("Selecciona un proyecto para generar el PDF.");

  // Obtener datos sin filtros iniciales
  const { reports, loading, error, deleteReport, fetchReports } = useDailyReports();
  const { projects } = useProjects();
  const { uploadFile, uploading: storageUploading, error: storageError } = useStorage();

  // Diagnosticar el contenido de reports
  useEffect(() => {
    console.log("Reports actualizados:", {
      length: reports?.length || 0,
      isArray: Array.isArray(reports),
      reports: reports
    });
  }, [reports]);
  
  // Filtrar reportes basado en criterios locales (en memoria)
  const filteredReports = useMemo(() => {
    console.log("Calculando filteredReports, total reports:", reports?.length || 0);
    
    // Verifica que reports existe y es un array
    if (!Array.isArray(reports)) {
      console.error("reports no es un array:", reports);
      return [];
    }
    
    let result = [...reports]; // Clonar array para evitar mutaciones

    // Filtrar por proyecto si hay seleccionado
    if (selectedProjectId) {
      console.log(`Filtrando por proyecto: ${selectedProjectId}`);
      result = result.filter((report) => report.projectId === selectedProjectId);
      console.log(`Después de filtrar por proyecto: ${result.length} reportes`);
    }

    // Filtrar por fecha si hay rango definido
    if (dateRange.startDate && dateRange.endDate) {
      const start = new Date(dateRange.startDate);
      const end = new Date(dateRange.endDate);
      end.setHours(23, 59, 59, 999); // Incluir todo el día final

      console.log(`Filtrando por fecha: ${start.toISOString()} - ${end.toISOString()}`);
      result = result.filter((report) => {
        if (!report.reportDate) {
          console.warn("Reporte sin fecha:", report);
          return false;
        }
        const reportDate = new Date(report.reportDate);
        return reportDate >= start && reportDate <= end;
      });
      console.log(`Después de filtrar por fecha: ${result.length} reportes`);
    }

    // Ordenar por fecha (más reciente primero)
    result = result.sort((a, b) => {
      if (!a.reportDate) return 1;
      if (!b.reportDate) return -1;
      return new Date(b.reportDate) - new Date(a.reportDate);
    });

    console.log(`Total de reportes filtrados: ${result.length}`);
    return result;
  }, [reports, selectedProjectId, dateRange.startDate, dateRange.endDate]);

  // Efecto para actualizar el estado de showPDFLink cuando cambian los filteredReports
  useEffect(() => {
    console.log("Verificando disponibilidad para PDF:", {
      reportes: filteredReports.length,
      proyecto: selectedProjectId
    });
    
    if (filteredReports.length > 0 && selectedProjectId) {
      setShowPDFLink(true);
      setPdfDisabledReason(null);
    } else {
      setShowPDFLink(false);
      if (!selectedProjectId) {
        setPdfDisabledReason("Selecciona un proyecto para generar el PDF.");
      } else if (filteredReports.length === 0) {
        setPdfDisabledReason("No hay reportes que coincidan con los criterios de búsqueda.");
      }
    }
  }, [filteredReports, selectedProjectId]);

  const calculateTotals = useCallback((reportsArray) => {
    let totalLabor = 0;
    let totalMaterials = 0;
    let totalCost = 0;
    let totalInvoiced = 0;

    reportsArray.forEach((report) => {
      // Para proyectos por horas
      if (report.labor) {
        totalLabor += report.labor.totalLaborCost || 0;
      }
      
      totalMaterials += report.totalMaterialsCost || 0;
      
      // El coste total puede venir directamente o calcularse
      if (report.totalCost) {
        totalCost += report.totalCost;
      } else if (report.labor) {
        // Si no existe totalCost pero sí labor, calculamos la suma
        totalCost += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
      }

      // Para proyectos de presupuesto cerrado
      if (report.invoicedAmount) {
        totalInvoiced += report.invoicedAmount;
      }
    });

    return {
      totalLabor,
      totalMaterials,
      totalCost,
      totalInvoiced
    };
  }, []);

  // Calcular totales (memoizado para evitar recálculos innecesarios)
  const totals = useMemo(() => calculateTotals(filteredReports), [filteredReports, calculateTotals]);
  
  const handleDateRangeChange = useCallback((e) => {
    setDateRange((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  }, []);

  const handleProjectChange = useCallback((e) => {
    setSelectedProjectId(e.target.value);
    if (e.target.value === "") {
      setPdfDisabledReason("Selecciona un proyecto para generar el PDF.");
    } else {
      setPdfDisabledReason(null);
    }
  }, []);

  const handleGeneratePDF = useCallback(() => {
    console.log("Intentando generar PDF con reportes:", filteredReports.length);
    if (filteredReports.length > 0 && selectedProjectId) {
      console.log("Condiciones satisfechas, mostrando link de PDF");
      setShowPDFLink(true);
    } else {
      console.log("No se puede generar PDF:", {
        reportes: filteredReports.length,
        proyecto: selectedProjectId
      });
    }
  }, [filteredReports, selectedProjectId]);

  const confirmDelete = useCallback((reportId) => {
    setReportToDelete(reportId);
  }, []);

  const handleDelete = useCallback(async () => {
    if (reportToDelete) {
      const success = await deleteReport(reportToDelete);
      if (success) {
        setReportToDelete(null);
      }
    }
  }, [reportToDelete, deleteReport]);

  const startEditing = useCallback((report) => {
    setEditingReportId(report.id);
    setEditedReport({ ...report });
  }, []);

  const handleEditChange = useCallback((e) => {
    const { name, value } = e.target;
    setEditedReport((prev) => {
      if (!prev) return prev;
      
      if (name.includes(".")) {
        const [parent, field] = name.split(".");
        if (parent === "labor") {
          return { ...prev, labor: { ...prev.labor, [field]: value } };
        } else if (parent === "workPerformed") {
          const updatedValue = field === 'invoicedAmount' ? parseFloat(value) : value;
          return { ...prev, workPerformed: { ...prev.workPerformed, [field]: updatedValue } };
        }
      }
      return { ...prev, [name]: value };
    });
  }, []);

  const handleAddMaterial = useCallback(async (e) => {
    const file = e.target.files[0];
    if (!file || !editedReport) return;

    const description = prompt("Descripción del material:") || "";
    const costText = prompt("Coste del material (€):") || "0";
    const cost = parseFloat(costText) || 0;

    if (!description || isNaN(cost) || cost < 0) {
      alert("Por favor, completa la descripción y un coste válido (numérico y positivo) antes de subir el archivo.");
      return;
    }

    try {
      const url = await uploadFile(file, "invoices", `${editedReport.projectId}_${editedReport.reportDate}`);
      if (url) {
        const newMaterial = { id: Date.now(), description, cost, invoiceUrl: url };
        setEditedReport((prev) => ({
          ...prev,
          materials: [...(prev.materials || []), newMaterial],
        }));
      }
    } catch (err) {
      console.error("Error al subir material:", err);
    }
  }, [editedReport, uploadFile]);

  const handleRemoveMaterial = useCallback((id) => {
    setEditedReport((prev) => ({
      ...prev,
      materials: prev.materials.filter((m) => m.id !== id),
    }));
  }, []);

  const handleAddPhoto = useCallback(async (e) => {
    const file = e.target.files[0];
    if (!file || !editedReport) return;

    try {
      const url = await uploadFile(file, "photos", `${editedReport.projectId}_${editedReport.reportDate}`);
      if (url) {
        setEditedReport((prev) => ({
          ...prev,
          workPerformed: {
            ...prev.workPerformed,
            photos: [...(prev.workPerformed.photos || []), { id: Date.now(), url }],
          },
        }));
      }
    } catch (err) {
      console.error("Error al subir foto:", err);
    }
  }, [editedReport, uploadFile]);

  const handleRemovePhoto = useCallback((id) => {
    setEditedReport((prev) => ({
      ...prev,
      workPerformed: {
        ...prev.workPerformed,
        photos: prev.workPerformed.photos.filter((p) => p.id !== id),
      },
    }));
  }, []);

  const handleEditSubmit = async (e) => {
    e.preventDefault();
    if (!editedReport) return;
    
    try {
      const reportRef = doc(db, "dailyReports", editingReportId);

      // Preparar los datos a actualizar
      const updatedData = {
        reportDate: editedReport.reportDate,
        weekNumber: getWeekNumber(editedReport.reportDate),
        materials: editedReport.materials || [],
        workPerformed: {
          ...editedReport.workPerformed,
          description: editedReport.workPerformed.description,
          photos: editedReport.workPerformed.photos || [],
        },
      };

      // Si el proyecto es por horas, incluir los datos de labor
      if (editedReport.labor) {
        updatedData.labor = editedReport.labor;
      }

      // Si el proyecto es de presupuesto cerrado, incluir 'invoicedAmount'
      if(editedReport.workPerformed?.invoicedAmount !== undefined) {
        updatedData.invoicedAmount = editedReport.workPerformed.invoicedAmount;
      }

      // Calcular costos (solo si es por horas)
      const project = projects.find((p) => p.id === editedReport.projectId);
      if (project && project.type === "hourly") {
        const totalMaterialsCost = editedReport.materials.reduce((sum, m) => sum + (m.cost || 0), 0);
        updatedData.totalMaterialsCost = totalMaterialsCost;

        if (editedReport.labor && 
            editedReport.labor.officialHours != null && 
            editedReport.labor.workerHours != null) {
          updatedData.totalCost = (editedReport.labor.totalLaborCost || 0) + totalMaterialsCost;
        }
      }

      await updateDoc(reportRef, updatedData);
      setEditingReportId(null);
      setEditedReport(null);
      await fetchReports();
    } catch (err) {
      console.error("Error al guardar cambios:", err);
    }
  };

  // Cargar reportes solo al montar el componente
  useEffect(() => {
    console.log("ReportsViewer montado - cargando reportes");
    fetchReports();
  }, []);

  // Componente de Debug (útil durante el desarrollo, puedes quitarlo en producción)
  const DebugInfo = () => (
    <div style={{ margin: '20px 0', padding: '10px', background: '#f5f5f5', border: '1px solid #ddd', fontSize: '12px' }}>
      <h4>Información de Debug:</h4>
      <pre>
        {JSON.stringify({
          reportsTotales: reports?.length || 0,
          reportesFiltrados: filteredReports?.length || 0,
          proyectoSeleccionado: selectedProjectId,
          mostrarPDF: showPDFLink,
          razonDeshabilitado: pdfDisabledReason,
          cargando: loading,
          error: error || 'ninguno'
        }, null, 2)}
      </pre>
    </div>
  );

  if (loading && reports.length === 0) return <p>Cargando reportes...</p>;
  if (error) return <p className="error-message">Error: {error}</p>;

  return (
    <div className="reports-viewer">
      <h2>Informes</h2>

      {/* Selector de Proyecto */}
      <div className="filter-section">
        <label>Filtrar por Proyecto: </label>
        <select value={selectedProjectId} onChange={handleProjectChange}>
          <option value="">Todos los proyectos</option>
          {projects.map((project) => (
            <option key={project.id} value={project.id}>
              {project.id} - {project.client}
            </option>
          ))}
        </select>

        {/* Selectores de Fecha */}
        <div className="date-range">
          <div className="date-field">
            <label>Fecha de inicio:</label>
            <input type="date" name="startDate" value={dateRange.startDate} onChange={handleDateRangeChange} />
          </div>
          <div className="date-field">
            <label>Fecha de fin:</label>
            <input type="date" name="endDate" value={dateRange.endDate} onChange={handleDateRangeChange} />
          </div>
        </div>
      </div>

      {/* Resumen de totales */}
      {filteredReports.length > 0 && selectedProjectId && (
        <div className="totals-summary" style={{
          backgroundColor: "#f5f7fa",
          padding: "15px",
          borderRadius: "8px",
          marginTop: "20px",
          marginBottom: "20px",
          boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
        }}>
          <h3 style={{ marginTop: "0", marginBottom: "10px" }}>Resumen de totales</h3>
          
          {projects.find(p => p.id === selectedProjectId)?.type === "hourly" ? (
            <>
              <div style={{ display: "flex", justifyContent: "space-between", marginBottom: "10px" }}>
                <strong>Total mano de obra:</strong>
                <span>{formatCurrency(totals.totalLabor)}</span>
              </div>
              <div style={{ display: "flex", justifyContent: "space-between", marginBottom: "10px" }}>
                <strong>Total materiales:</strong>
                <span>{formatCurrency(totals.totalMaterials)}</span>
              </div>
              <div style={{ 
                display: "flex", 
                justifyContent: "space-between",
                borderTop: "1px solid #ddd",
                paddingTop: "10px",
                fontWeight: "bold"
              }}>
                <strong>TOTAL GENERAL:</strong>
                <span>{formatCurrency(totals.totalCost)}</span>
              </div>
            </>
          ) : (
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <strong>Total facturado:</strong>
              <span>{formatCurrency(totals.totalInvoiced)}</span>
            </div>
          )}
        </div>
      )}

      {/* Botón y enlace de descarga */}
      <button 
        onClick={handleGeneratePDF} 
        disabled={!selectedProjectId || filteredReports.length === 0}
      >
        Generar PDF
      </button>
      
      {!showPDFLink && (
        <p style={{ color: "#666", fontStyle: "italic" }}>
          {pdfDisabledReason || "Para generar un PDF, selecciona un proyecto y asegúrate de que haya reportes disponibles."}
        </p>
      )}

      {showPDFLink && filteredReports.length > 0 && (
        <PDFDownloadLink
          document={<ReportPDFGenerator reports={filteredReports} projects={projects} />}
          fileName={`informe_${selectedProjectId || 'todos'}_${dateRange.startDate || 'inicio'}_${dateRange.endDate || 'fin'}.pdf`}
          style={{
            display: "block",
            margin: "10px 0",
            padding: "10px",
            backgroundColor: "#4CAF50",
            color: "white",
            textDecoration: "none",
            textAlign: "center",
            borderRadius: "4px"
          }}
        >
          {({ loading: pdfLoading, error: pdfError }) => {
            console.log("Estado de PDFDownloadLink:", { loading: pdfLoading, error: pdfError });
            if (pdfError) {
              console.error("Error en PDFDownloadLink:", pdfError);
              return "Error al generar PDF";
            }
            return (pdfLoading ? "Generando PDF..." : "Descargar Informe en PDF");
          }}
        </PDFDownloadLink>
      )}

      {/* Añadir componente de Debug durante desarrollo (comentar o eliminar en producción) */}
      {/* <DebugInfo /> */}

      <h3 className="section-title">Partes en el rango seleccionado:</h3>

      {filteredReports.length === 0 ? (
        <p>No hay partes que coincidan con los criterios de búsqueda.</p>
      ) : (
        filteredReports.map((report) => {
          const project = projects.find((p) => p.id === report.projectId) || {};
          const isEditing = editingReportId === report.id;

          return (
            <div key={report.id} className="report-card">
              {isEditing ? (
                <form onSubmit={handleEditSubmit} className="edit-form">
                  <label>Fecha del parte:</label>
                  <input
                    type="date"
                    name="reportDate"
                    value={editedReport.reportDate}
                    onChange={handleEditChange}
                  />

                  {project.type === 'hourly' && <>
                    <h4>Mano de obra</h4>
                    <div className="labor-row">
                      <div className="labor-field">
                        <label>Hora entrada oficial</label>
                        <input
                          type="time"
                          name="labor.officialEntry"
                          value={editedReport.labor?.officialEntry || ""}
                          onChange={handleEditChange}
                          className="time-input"
                        />
                      </div>
                      <div className="labor-field">
                        <label>Hora salida oficial</label>
                        <input
                          type="time"
                          name="labor.officialExit"
                          value={editedReport.labor?.officialExit || ""}
                          onChange={handleEditChange}
                          className="time-input"
                        />
                      </div>
                    </div>

                    <div className="labor-row">
                      <div className="labor-field">
                        <label>Hora entrada peón</label>
                        <input
                          type="time"
                          name="labor.workerEntry"
                          value={editedReport.labor?.workerEntry || ""}
                          onChange={handleEditChange}
                          className="time-input"
                        />
                      </div>
                      <div className="labor-field">
                        <label>Hora salida peón</label>
                        <input
                          type="time"
                          name="labor.workerExit"
                          value={editedReport.labor?.workerExit || ""}
                          onChange={handleEditChange}
                          className="time-input"
                        />
                      </div>
                    </div>
                  </>}
                  <label>Descripción trabajos:</label>
                  <textarea
                    name="workPerformed.description"
                    value={editedReport.workPerformed?.description || ""}
                    onChange={handleEditChange}
                  />
                  {project.type === 'fixed' && (
                    <>
                      <label>Importe Facturado (€)</label>
                      <input
                        type="number"
                        name="workPerformed.invoicedAmount"
                        min="0"
                        step="0.01"
                        value={editedReport.workPerformed?.invoicedAmount || 0}
                        onChange={handleEditChange}
                      />
                    </>
                  )}

                  <h4>Materiales</h4>
                  {editedReport.materials?.map((m) => (
                    <div key={m.id} className="material-item">
                      <input
                        type="text"
                        value={m.description || ""}
                        onChange={(e) =>
                          setEditedReport((prev) => ({
                            ...prev,
                            materials: prev.materials.map((item) =>
                              item.id === m.id ? { ...item, description: e.target.value } : item
                            ),
                          }))
                        }
                      />
                      <input
                        type="number"
                        value={m.cost || 0}
                        onChange={(e) =>
                          setEditedReport((prev) => ({
                            ...prev,
                            materials: prev.materials.map((item) =>
                              item.id === m.id ? { ...item, cost: parseFloat(e.target.value) || 0 } : item
                            ),
                          }))
                        }
                        min="0"
                        step="0.01"
                      />
                      <a href={m.invoiceUrl} target="_blank" rel="noopener noreferrer">
                        Ver factura
                      </a>
                      <button onClick={() => handleRemoveMaterial(m.id)} type="button">Eliminar</button>
                    </div>
                  ))}
                  <input type="file" accept=".pdf" onChange={handleAddMaterial} disabled={storageUploading} />
                  {storageUploading && <p>Subiendo material...</p>}
                  {storageError && <p className="error-message">Error: {storageError}</p>}
                  <h4>Fotografías</h4>
                  <div className="photos-container">
                    {editedReport.workPerformed?.photos?.map((photo) => (
                      <div key={photo.id} className="photo-container">
                        <img src={photo.url} alt="Foto" style={{ width: "100px" }} />
                        <button onClick={() => handleRemovePhoto(photo.id)} type="button">Eliminar</button>
                      </div>
                    ))}
                  </div>
                  <input type="file" accept="image/*" onChange={handleAddPhoto} disabled={storageUploading} />
                  {storageUploading && <p>Subiendo foto...</p>}
                  {storageError && <p className="error-message">Error: {storageError}</p>}
                  <button type="submit">Guardar cambios</button>
                  <button type="button" onClick={() => setEditingReportId(null)}>
                    Cancelar
                  </button>
                </form>
              ) : (
                <>
                  <h4>Parte del {new Date(report.reportDate).toLocaleDateString()}</h4>
                  <p>
                    <strong>Semana:</strong> {report.weekNumber}
                  </p>
                  <p>
                    <strong>Proyecto:</strong> {report.projectId}
                  </p>
                  <p>
                    <strong>Cliente:</strong> {project.client || "No disponible"}
                  </p>
                  <p>
                    <strong>Dirección:</strong> {project.address || "No disponible"}
                  </p>

                  {project.type === "hourly" ? (
                    <>
                      <h5>Mano de obra</h5>
                      <p>Oficial: {formatNumber(report.labor?.officialHours || 0)} h - {formatCurrency(report.labor?.officialCost || 0)}</p>
                      <p>Peón: {formatNumber(report.labor?.workerHours || 0)} h - {formatCurrency(report.labor?.workerCost || 0)}</p>
                      <p>Total mano de obra: {formatCurrency(report.labor?.totalLaborCost || 0)}</p>
                      <h5>Materiales</h5>
                      {report.materials && report.materials.length > 0 ? (
                        report.materials.map((m, i) => (
                          <p key={i}>
                            {m.description} - {formatCurrency(m.cost)} (
                            <a href={m.invoiceUrl} target="_blank" rel="noopener noreferrer">
                              Ver factura
                            </a>
                            )
                          </p>
                        ))
                      ) : (
                        <p>No hay materiales registrados.</p>
                      )}
                      <p>Total materiales: {formatCurrency(report.totalMaterialsCost || 0)}</p>
                    </>
                  ) : (
                    <>
                      <p>
                        <strong>Importe facturado:</strong>{" "}
                        {formatCurrency(report.invoicedAmount || 0)}
                      </p>
                    </>
                  )}

                  <h5>Trabajos realizados</h5>
                  <p>{report.workPerformed?.description || "Sin descripción"}</p>
                  <div className="photos-container">
                    {report.workPerformed?.photos?.map((photo, i) => (
                      <img
                        key={i}
                        src={photo.url}
                        alt={`Foto ${i + 1}`}
                        style={{ width: "100px", marginRight: "10px" }}
                      />
                    ))}
                  </div>

                  {project.type === "hourly" && (
                    <p>
                      <strong>Total:</strong> {formatCurrency(report.totalCost || 0)}
                    </p>
                  )}

                  <button onClick={() => startEditing(report)}>Editar</button>
                  <button
                    onClick={() => confirmDelete(report.id)}
                    style={{ backgroundColor: "#e74c3c", marginLeft: "10px" }}
                  >
                    Eliminar
                  </button>
                </>
              )}
            </div>
          );
        })
      )}
      
      {reportToDelete && (
        <div className="modal">
          <p>¿Seguro que quieres eliminar este parte?</p>
          <button onClick={handleDelete} style={{ marginRight: "10px" }}>
            Sí
          </button>
          <button onClick={() => setReportToDelete(null)}>No</button>
        </div>
      )}
    </div>
  );
};

export default React.memo(ReportsViewer);

================
File: src/components/WorkPerformedForm.js
================
import React, { useCallback } from "react";
import ImageUploader from "./ImageUploader"; // Importamos nuestro nuevo componente

const WorkPerformedForm = ({ workPerformed, onWorkPerformedChange, projectId, reportDate }) => {
  const handleDescriptionChange = useCallback(
    (e) => {
      onWorkPerformedChange({ ...workPerformed, description: e.target.value });
    },
    [workPerformed, onWorkPerformedChange]
  );

  // Manejador para las imágenes subidas o eliminadas
  const handleImagesChange = useCallback(
    ({ type, images, id }) => {
      if (type === 'add' && images && images.length > 0) {
        // Añadir nuevas imágenes
        onWorkPerformedChange({
          ...workPerformed,
          photos: [...(workPerformed.photos || []), ...images],
        });
      } else if (type === 'remove' && id) {
        // Eliminar una imagen existente
        onWorkPerformedChange({
          ...workPerformed,
          photos: (workPerformed.photos || []).filter((p) => p.id !== id),
        });
      }
    },
    [workPerformed, onWorkPerformedChange]
  );

  return (
    <div>
      <h3>Trabajos realizados</h3>
      <textarea
        value={workPerformed.description || ""}
        onChange={handleDescriptionChange}
        placeholder="Descripción de los trabajos realizados"
      />
      
      {/* Reemplazamos el input file por nuestro ImageUploader */}
      <ImageUploader
        onImagesUploaded={handleImagesChange}
        folder="photos"
        prefix={`${projectId}_${reportDate}`}
        maxFiles={10}
        acceptedTypes="image/*"
        existingImages={workPerformed.photos || []}
      />
    </div>
  );
};

export default React.memo(WorkPerformedForm);

================
File: src/firebase.js
================
// firebase.js
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
};

const app = initializeApp(firebaseConfig);

export const db = getFirestore(app);
export const storage = getStorage(app);
export { app }; // Exporta la instancia de la app

================
File: src/hooks/useDailyReports.js
================
// src/hooks/useDailyReports.js - Versión corregida

import { useState, useEffect, useCallback, useRef } from "react";
import { 
  collection, 
  query, 
  orderBy, 
  where, 
  limit, 
  startAfter, 
  getDocs, 
  deleteDoc, 
  doc, 
  getDoc 
} from "firebase/firestore";
import { ref, deleteObject } from "firebase/storage";
import { db, storage } from "../firebase";

export const useDailyReports = (initialFilters = {}) => {
  const [reports, setReports] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState(initialFilters);
  
  // Estado para paginación
  const [lastVisible, setLastVisible] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [pageSize, setPageSize] = useState(50); // Aumentado para cargar más reportes de una vez
  
  // Referencia para cache de reportes por ID
  const reportsCache = useRef(new Map());

  // Función para construir la consulta con filtros
  const buildQuery = useCallback((lastDoc = null) => {
    console.log("Construyendo query con filtros:", filters);
    let q = collection(db, "dailyReports");
    const conditions = [];
    
    // Filtro por fecha de inicio
    if (filters.startDate) {
      conditions.push(where("reportDate", ">=", filters.startDate));
    }
    
    // Filtro por fecha final
    if (filters.endDate) {
      conditions.push(where("reportDate", "<=", filters.endDate));
    }
    
    // Filtro por proyecto
    if (filters.projectId) {
      conditions.push(where("projectId", "==", filters.projectId));
    }
    
    // Filtro por usuario
    if (filters.userId) {
      conditions.push(where("userId", "==", filters.userId));
    }
    
    // Filtro por semana
    if (filters.weekNumber) {
      conditions.push(where("weekNumber", "==", filters.weekNumber));
    }
    
    // Aplicar ordenamiento
    const orderByField = filters.orderBy || "reportDate";
    const orderDirection = filters.orderDirection || "desc";
    
    // Construir la consulta con condiciones
    if (conditions.length > 0) {
      q = query(q, ...conditions, orderBy(orderByField, orderDirection));
    } else {
      q = query(q, orderBy(orderByField, orderDirection));
    }
    
    // Aplicar paginación
    if (pageSize > 0) {
      q = query(q, limit(pageSize));
    }
    
    // Si hay un documento de inicio para paginación
    if (lastDoc) {
      q = query(q, startAfter(lastDoc));
    }
    
    return q;
  }, [filters, pageSize]);

  // Función para cargar reportes
  const fetchReports = useCallback(async (resetPagination = true) => {
    console.log("Iniciando fetchReports, resetPagination:", resetPagination);
    setLoading(true);
    setError(null);
    
    try {
      if (resetPagination) {
        setReports([]);
        setLastVisible(null);
      }
      
      const q = buildQuery(resetPagination ? null : lastVisible);
      console.log("Ejecutando consulta a Firestore");
      const querySnapshot = await getDocs(q);
      console.log(`Obtenidos ${querySnapshot.docs.length} documentos de Firestore`);
      
      // Actualizar estado de paginación
      const lastDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
      setLastVisible(lastDoc || null);
      setHasMore(querySnapshot.docs.length === pageSize);
      
      // Procesar resultados
      const reportsData = querySnapshot.docs.map((doc) => {
        const data = { id: doc.id, ...doc.data() };
        
        // Actualizar caché
        reportsCache.current.set(doc.id, data);
        
        return data;
      });
      
      // Actualizar lista de reportes (paginación)
      setReports((prev) => {
        const newReports = resetPagination ? reportsData : [...prev, ...reportsData];
        console.log(`Total de reportes cargados: ${newReports.length}`);
        return newReports;
      });
    } catch (err) {
      console.error("Error al cargar reportes:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [buildQuery, lastVisible, pageSize]);

  // Cargar más reportes (paginación)
  const loadMore = useCallback(() => {
    if (hasMore && !loading) {
      return fetchReports(false);
    }
  }, [fetchReports, hasMore, loading]);

  // Actualizar filtros
  const updateFilters = useCallback((newFilters) => {
    console.log("Actualizando filtros:", newFilters);
    setFilters((prev) => ({ ...prev, ...newFilters }));
  }, []);

  // Obtener un reporte por ID (usando caché)
  const getReportById = useCallback(async (reportId) => {
    // Verificar caché primero
    if (reportsCache.current.has(reportId)) {
      return reportsCache.current.get(reportId);
    }
    
    try {
      setLoading(true);
      const reportDoc = await getDoc(doc(db, "dailyReports", reportId));
      
      if (reportDoc.exists()) {
        const reportData = { id: reportDoc.id, ...reportDoc.data() };
        // Actualizar caché
        reportsCache.current.set(reportId, reportData);
        return reportData;
      }
      
      return null;
    } catch (err) {
      console.error(`Error al obtener reporte ${reportId}:`, err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Eliminar un reporte y sus archivos asociados
  const deleteReport = useCallback(async (reportId) => {
    try {
      console.log("Iniciando eliminación de reporte:", reportId);
      setLoading(true);
      const reportRef = doc(db, "dailyReports", reportId);
      const reportSnap = await getDoc(reportRef);
      
      if (!reportSnap.exists()) {
        throw new Error("Reporte no encontrado");
      }
      
      const report = reportSnap.data();
      console.log("Datos del reporte a eliminar:", report);

      // Función auxiliar para eliminar archivos de Storage
      const deleteFileFromStorage = async (url) => {
        if (!url) return;
        try {
          // Extraer la ruta de la URL
          const path = decodeURIComponent(url.split('/').slice(3).join('/').split('?')[0]);
          console.log("Intentando eliminar archivo:", path);
          const fileRef = ref(storage, path);
          await deleteObject(fileRef);
          console.log("Archivo eliminado con éxito:", path);
        } catch (err) {
          console.error(`Error eliminando archivo ${url}:`, err);
        }
      };

      // Eliminar facturas de materiales
      if (report.materials?.length > 0) {
        console.log("Eliminando facturas de materiales:", report.materials.length);
        for (const material of report.materials) {
          if (material.invoiceUrl) {
            await deleteFileFromStorage(material.invoiceUrl);
          }
        }
      }
      
      // Eliminar fotos
      if (report.workPerformed?.photos?.length > 0) {
        console.log("Eliminando fotos:", report.workPerformed.photos.length);
        for (const photo of report.workPerformed.photos) {
          if (photo.url) {
            await deleteFileFromStorage(photo.url);
          }
        }
      }

      // Eliminar el documento de Firestore
      console.log("Eliminando documento de Firestore:", reportId);
      await deleteDoc(reportRef);
      
      // Actualizar estado local y caché
      setReports((prev) => prev.filter((r) => r.id !== reportId));
      reportsCache.current.delete(reportId);
      
      console.log("Reporte eliminado con éxito:", reportId);
      return true;
    } catch (err) {
      console.error("Error al eliminar reporte:", err);
      setError(err.message);
      return false;
    } finally {
      setLoading(false);
    }
  }, []);

  // Cargar reportes al cambiar los filtros
  useEffect(() => {
    console.log("useEffect en useDailyReports - cargando reportes por cambio de filtros");
    fetchReports();
  }, [filters]);

  // Crear objeto para retornar
  const returnObj = {
    reports,
    allReports: reports, // Para compatibilidad con código antiguo
    loading,
    error,
    fetchReports,
    deleteReport,
    getReportById,
    updateFilters,
    filters,
    loadMore,
    hasMore,
    setPageSize
  };

  // Log de depuración
  console.log("useDailyReports retornando:", {
    reportsLength: reports.length,
    loading,
    error
  });

  return returnObj;
};

export default useDailyReports;

================
File: src/hooks/useFormValidation.js
================
// src/hooks/useFormValidation.js

import { useState, useCallback, useEffect } from 'react';
import { validateForm } from '../utils/validationSchemas';

const useFormValidation = (initialValues, validationSchema, contextData = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touchedFields, setTouchedFields] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isValid, setIsValid] = useState(false);

  // Validar el formulario completo
  const validateFormData = useCallback(() => {
    const result = validateForm(values, validationSchema, contextData);
    setErrors(result.errors);
    setIsValid(result.isValid);
    return result;
  }, [values, validationSchema, contextData]);

  // Efecto para validar cuando cambian los valores
  useEffect(() => {
    validateFormData();
  }, [validateFormData]);

  // Manejar cambios en campos
  const handleChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;
    
    // Manejar diferentes tipos de input
    const inputValue = type === 'checkbox' ? checked : value;
    
    setValues(prevValues => {
      // Manejar campos anidados (e.g., 'labor.officialEntry')
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        
        // Navegar hasta el penúltimo nivel
        for (let i = 0; i < parts.length - 1; i++) {
          // Crear objeto si no existe
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        
        // Asignar valor al último nivel
        current[parts[parts.length - 1]] = inputValue;
        return newValues;
      }
      
      // Caso simple: campo no anidado
      return { ...prevValues, [name]: inputValue };
    });
    
    // Marcar el campo como tocado
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  // Manejar eventos blur para validación
  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  // Verificar si un campo tiene error y ha sido tocado
  const hasError = useCallback((fieldName) => {
    return touchedFields[fieldName] && errors[fieldName];
  }, [touchedFields, errors]);

  // Obtener el mensaje de error para un campo
  const getError = useCallback((fieldName) => {
    return hasError(fieldName) ? errors[fieldName] : null;
  }, [hasError, errors]);

  // Manejar envío del formulario
  const handleSubmit = useCallback((onSubmit) => async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    // Marcar todos los campos como tocados para mostrar todos los errores
    const allFields = Object.keys(validationSchema).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouchedFields(allFields);
    
    // Validar antes de enviar
    const validationResult = validateFormData();
    
    if (validationResult.isValid) {
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Error en envío del formulario:', error);
      }
    }
    
    setIsSubmitting(false);
  }, [values, validateFormData, validationSchema]);

  // Resetear el formulario
  const resetForm = useCallback((newValues = initialValues) => {
    setValues(newValues);
    setErrors({});
    setTouchedFields({});
    setIsSubmitting(false);
  }, [initialValues]);

  // Actualizar un valor específico programáticamente
  const setValue = useCallback((name, value) => {
    setValues(prevValues => {
      // Manejar campos anidados
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        
        current[parts[parts.length - 1]] = value;
        return newValues;
      }
      
      return { ...prevValues, [name]: value };
    });
  }, []);

  return {
    values,
    errors,
    touchedFields,
    isSubmitting,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setValue,
    hasError,
    getError,
  };
};

export default useFormValidation;

================
File: src/hooks/useLabor.js
================
import { useMemo } from "react";

export const useLabor = (labor, project) => {
  return useMemo(() => {
    const { officialEntry, officialExit, workerEntry, workerExit } = labor;
    const officialStart = officialEntry ? new Date(`2025-01-01T${officialEntry}`) : null;
    const officialEnd = officialExit ? new Date(`2025-01-01T${officialExit}`) : null;
    const workerStart = workerEntry ? new Date(`2025-01-01T${workerEntry}`) : null;
    const workerEnd = workerExit ? new Date(`2025-01-01T${workerExit}`) : null;

    if (officialStart && officialEnd && officialEnd < officialStart) {
      officialEnd.setDate(officialEnd.getDate() + 1);
    }
    if (workerStart && workerEnd && workerEnd < workerStart) {
      workerEnd.setDate(workerEnd.getDate() + 1);
    }

    const officialHours = officialStart && officialEnd ? (officialEnd - officialStart) / 3600000 : 0;
    const workerHours = workerStart && workerEnd ? (workerEnd - workerStart) / 3600000 : 0;
    const officialCost = officialHours * (project?.officialPrice || 0);
    const workerCost = workerHours * (project?.workerPrice || 0);

    return {
      officialHours,
      workerHours,
      officialCost,
      workerCost,
      totalLaborCost: officialCost + workerCost,
    };
  }, [labor, project]);
};

================
File: src/hooks/useProjects.js
================
import { useState, useEffect, useCallback } from "react";
import { collection, getDocs, addDoc, updateDoc, doc, deleteDoc } from "firebase/firestore";
import { db } from "../firebase";

export const useProjects = () => {
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchProjects = useCallback(async () => {
    setLoading(true);
    setError(null); // Limpiar errores anteriores
    try {
      const querySnapshot = await getDocs(collection(db, "projects"));
      const projectsData = querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
      setProjects(projectsData);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  const addProject = useCallback(async (project) => {
    setLoading(true);
    setError(null);
    try {
      // Asegurarse de que el ID no tenga espacios al principio ni al final
      const cleanedProject = {
        ...project,
        id: project.id.trim()
      };
      
      // Verificar si ya existe un proyecto con este ID
      const existingProjects = await getDocs(collection(db, "projects"));
      const exists = existingProjects.docs.some(doc => doc.id === cleanedProject.id);
      
      if (exists) {
        throw new Error(`Ya existe un proyecto con el ID ${cleanedProject.id}`);
      }
      
      // Usar el ID del proyecto como el ID del documento en Firestore
      await addDoc(collection(db, "projects"), cleanedProject);
      await fetchProjects(); // Refrescar la lista
    } catch (err) {
      setError(err.message);
      throw err; // Re-lanzar el error para que se maneje en el componente
    } finally {
      setLoading(false);
    }
  }, [fetchProjects]);

  const updateProject = useCallback(async (projectId, updatedProject) => {
    setLoading(true);
    setError(null);
    try {
      const projectRef = doc(db, "projects", projectId);
      await updateDoc(projectRef, updatedProject);
      await fetchProjects(); // Refrescar la lista
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [fetchProjects]);

  const deleteProject = useCallback(async (projectId) => {
    setLoading(true);
    setError(null); // Limpiar errores
    try {
      console.log("deleteProject llamado con projectId:", projectId);
      
      // Verificar todos los proyectos en la base de datos
      const querySnapshot = await getDocs(collection(db, "projects"));
      console.log("Proyectos en la base de datos:");
      querySnapshot.docs.forEach(doc => {
        console.log(`ID del documento: "${doc.id}" - Datos:`, doc.data());
      });
      
      // Buscar el proyecto por su propiedad id dentro de los datos, no por el ID del documento
      const projectDoc = querySnapshot.docs.find(doc => {
        const data = doc.data();
        return data.id === projectId;
      });
      
      if (!projectDoc) {
        throw new Error(`El proyecto con ID ${projectId} no existe.`);
      }
      
      // Usar el ID del documento de Firestore para eliminarlo
      const projectRef = doc(db, "projects", projectDoc.id);
      await deleteDoc(projectRef);
      console.log("deleteDoc completado, llamando a fetchProjects");
      await fetchProjects(); // Refrescar después de eliminar
    } catch (err) {
      console.error("Error en deleteProject:", err);
      setError(err.message);
      throw err; // Re-lanzar para que el componente pueda manejarlo
    } finally {
      setLoading(false);
    }
  }, [fetchProjects]);

  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);

  return { projects, loading, error, addProject, updateProject, deleteProject };
};

================
File: src/hooks/useQueryProjects.js
================
// src/hooks/useQueryProjects.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { 
  collection, 
  getDocs, 
  doc, 
  getDoc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where 
} from 'firebase/firestore';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { db } from '../firebase';

// Clave de caché para proyectos
const PROJECTS_CACHE_KEY = 'projects';

// Obtener todos los proyectos
const fetchProjects = async (userId = null) => {
  let q = collection(db, 'projects');
  
  if (userId) {
    q = query(q, where('userId', '==', userId));
  }
  
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// Obtener un proyecto por ID
const fetchProjectById = async (projectId) => {
  if (!projectId) return null;
  
  const docRef = doc(db, 'projects', projectId);
  const docSnap = await getDoc(docRef);
  
  if (docSnap.exists()) {
    return { id: docSnap.id, ...docSnap.data() };
  }
  
  return null;
};

// Hook para obtener proyectos
export const useQueryProjects = (userId = null) => {
  return useQuery({
    queryKey: [PROJECTS_CACHE_KEY, { userId }],
    queryFn: () => fetchProjects(userId),
  });
};

// Hook para obtener un proyecto específico
export const useQueryProject = (projectId) => {
  return useQuery({
    queryKey: [PROJECTS_CACHE_KEY, projectId],
    queryFn: () => fetchProjectById(projectId),
    enabled: !!projectId, // Solo ejecutar si hay un projectId
  });
};

// Hook para agregar un proyecto
export const useAddProject = () => {
  const queryClient = useQueryClient();
  const functions = getFunctions();
  const createProjectFunction = httpsCallable(functions, 'createProject');
  
  return useMutation({
    mutationFn: async (projectData) => {
      // Usar Cloud Function para validación y creación
      const result = await createProjectFunction(projectData);
      return result.data;
    },
    // Invalidar cache al finalizar
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] });
    },
  });
};

// Hook para actualizar un proyecto
export const useUpdateProject = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ projectId, data }) => {
      const projectRef = doc(db, 'projects', projectId);
      await updateDoc(projectRef, data);
      return { id: projectId, ...data };
    },
    // Actualizar la caché optimistamente
    onMutate: async ({ projectId, data }) => {
      // Cancelar consultas pendientes
      await queryClient.cancelQueries({ queryKey: [PROJECTS_CACHE_KEY, projectId] });
      
      // Guardar el estado previo
      const previousProject = queryClient.getQueryData([PROJECTS_CACHE_KEY, projectId]);
      
      // Actualizar la caché optimistamente
      queryClient.setQueryData([PROJECTS_CACHE_KEY, projectId], old => ({
        ...old,
        ...data,
      }));
      
      // También actualizar la lista de proyectos
      queryClient.setQueryData([PROJECTS_CACHE_KEY], old => {
        if (!old) return old;
        return old.map(project => 
          project.id === projectId ? { ...project, ...data } : project
        );
      });
      
      return { previousProject };
    },
    // En caso de error, restaurar el estado previo
    onError: (err, { projectId }, context) => {
      if (context?.previousProject) {
        queryClient.setQueryData([PROJECTS_CACHE_KEY, projectId], context.previousProject);
      }
    },
    // Invalidar cache al finalizar
    onSettled: (data, error, { projectId }) => {
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY, projectId] });
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] });
    },
  });
};

// Hook para eliminar un proyecto
export const useDeleteProject = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (projectId) => {
      // Buscar el proyecto por ID dentro de los datos
      const projects = await fetchProjects();
      const project = projects.find(p => p.id === projectId);
      
      if (!project) {
        throw new Error(`Proyecto con ID ${projectId} no encontrado`);
      }
      
      // Eliminar el documento de Firestore
      const projectDoc = projects.find(p => p.id === projectId);
      await deleteDoc(doc(db, 'projects', projectDoc.id));
      
      return projectId;
    },
    // Actualizar la caché optimistamente
    onMutate: async (projectId) => {
      // Cancelar consultas pendientes
      await queryClient.cancelQueries({ queryKey: [PROJECTS_CACHE_KEY] });
      
      // Guardar el estado previo
      const previousProjects = queryClient.getQueryData([PROJECTS_CACHE_KEY]);
      
      // Actualizar la caché optimistamente
      queryClient.setQueryData([PROJECTS_CACHE_KEY], old => {
        if (!old) return [];
        return old.filter(project => project.id !== projectId);
      });
      
      return { previousProjects };
    },
    // En caso de error, restaurar el estado previo
    onError: (err, projectId, context) => {
      if (context?.previousProjects) {
        queryClient.setQueryData([PROJECTS_CACHE_KEY], context.previousProjects);
      }
    },
    // Invalidar cache al finalizar
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] });
    },
  });
};

================
File: src/hooks/useQueryReports.js
================
// src/hooks/useQueryReports.js
import { useInfiniteQuery, useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  startAfter, 
  getDocs, 
  getDoc, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc,
  serverTimestamp 
} from 'firebase/firestore';
import { ref, deleteObject } from 'firebase/storage';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { db, storage } from '../firebase';

// Clave de caché para reportes
const REPORTS_CACHE_KEY = 'reports';

// Obtener reportes con filtros y paginación
const fetchReports = async ({ pageParam = null, ...filters }) => {
  const pageSize = filters.pageSize || 10;
  
  let q = collection(db, 'dailyReports');
  const conditions = [];
  
  // Aplicar filtros
  if (filters.projectId) {
    conditions.push(where('projectId', '==', filters.projectId));
  }
  
  if (filters.userId) {
    conditions.push(where('userId', '==', filters.userId));
  }
  
  if (filters.weekNumber) {
    conditions.push(where('weekNumber', '==', filters.weekNumber));
  }
  
  if (filters.startDate) {
    conditions.push(where('reportDate', '>=', filters.startDate));
  }
  
  if (filters.endDate) {
    conditions.push(where('reportDate', '<=', filters.endDate));
  }
  
  // Ordenamiento
  const orderByField = filters.orderBy || 'reportDate';
  const orderDirection = filters.orderDirection || 'desc';
  
  q = query(q, ...conditions, orderBy(orderByField, orderDirection));
  
  // Aplicar paginación
  q = query(q, limit(pageSize));
  
  if (pageParam) {
    q = query(q, startAfter(pageParam));
  }
  
  const querySnapshot = await getDocs(q);
  const lastDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
  const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  
  return {
    items,
    lastDoc,
    hasMore: items.length === pageSize,
  };
};

// Obtener un reporte por ID
const fetchReportById = async (reportId) => {
  if (!reportId) return null;
  
  const docRef = doc(db, 'dailyReports', reportId);
  const docSnap = await getDoc(docRef);
  
  if (docSnap.exists()) {
    return { id: docSnap.id, ...docSnap.data() };
  }
  
  return null;
};

// Hook para obtener reportes con paginación infinita
export const useQueryReportsInfinite = (filters = {}) => {
  return useInfiniteQuery({
    queryKey: [REPORTS_CACHE_KEY, filters],
    queryFn: ({ pageParam }) => fetchReports({ pageParam, ...filters }),
    getNextPageParam: (lastPage) => lastPage.hasMore ? lastPage.lastDoc : undefined,
  });
};

// Hook para obtener un reporte específico
export const useQueryReport = (reportId) => {
  return useQuery({
    queryKey: [REPORTS_CACHE_KEY, reportId],
    queryFn: () => fetchReportById(reportId),
    enabled: !!reportId, // Solo ejecutar si hay un reportId
  });
};

// Hook para agregar un reporte
export const useAddReport = () => {
  const queryClient = useQueryClient();
  const functions = getFunctions();
  const createReportFunction = httpsCallable(functions, 'createDailyReport');
  
  return useMutation({
    mutationFn: async (reportData) => {
      // Usar Cloud Function para validación y creación
      const result = await createReportFunction(reportData);
      return result.data;
    },
    // Invalidar cache al finalizar
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
    },
  });
};

// Hook para actualizar un reporte
export const useUpdateReport = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ reportId, data }) => {
      const reportRef = doc(db, 'dailyReports', reportId);
      
      // Agregar timestamp de actualización
      const updateData = {
        ...data,
        updatedAt: serverTimestamp(),
      };
      
      await updateDoc(reportRef, updateData);
      return { id: reportId, ...data };
    },
    // Actualizar la caché optimistamente
    onMutate: async ({ reportId, data }) => {
      // Cancelar consultas pendientes
      await queryClient.cancelQueries({ queryKey: [REPORTS_CACHE_KEY, reportId] });
      
      // Guardar el estado previo
      const previousReport = queryClient.getQueryData([REPORTS_CACHE_KEY, reportId]);
      
      // Actualizar la caché optimistamente
      queryClient.setQueryData([REPORTS_CACHE_KEY, reportId], old => ({
        ...old,
        ...data,
      }));
      
      return { previousReport };
    },
    // En caso de error, restaurar el estado previo
    onError: (err, { reportId }, context) => {
      if (context?.previousReport) {
        queryClient.setQueryData([REPORTS_CACHE_KEY, reportId], context.previousReport);
      }
    },
    // Invalidar cache al finalizar
    onSettled: (data, error, { reportId }) => {
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY, reportId] });
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
    },
  });
};

// Hook para eliminar un reporte
export const useDeleteReport = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (reportId) => {
      // Primero obtener el reporte para saber qué archivos eliminar
      const reportRef = doc(db, 'dailyReports', reportId);
      const reportSnap = await getDoc(reportRef);
      
      if (!reportSnap.exists()) {
        throw new Error('Reporte no encontrado');
      }
      
      const report = reportSnap.data();
      
      // Función auxiliar para eliminar archivos
      const deleteFileFromStorage = async (url) => {
        if (!url) return;
        try {
          const fileRef = ref(storage, url);
          await deleteObject(fileRef);
        } catch (err) {
          console.error(`Error eliminando archivo ${url}:`, err);
        }
      };
      
      // Eliminar facturas de materiales
      if (report.materials?.length > 0) {
        await Promise.all(report.materials.map(m => deleteFileFromStorage(m.invoiceUrl)));
      }
      
      // Eliminar fotos
      if (report.workPerformed?.photos?.length > 0) {
        await Promise.all(report.workPerformed.photos.map(p => deleteFileFromStorage(p.url)));
      }
      
      // Eliminar el documento
      await deleteDoc(reportRef);
      
      return reportId;
    },
    // Actualizar la caché optimistamente
    onMutate: async (reportId) => {
      // Cancelar consultas pendientes
      await queryClient.cancelQueries({ queryKey: [REPORTS_CACHE_KEY] });
      
      // Guardar el estado previo
      const previousCacheData = queryClient.getQueryState([REPORTS_CACHE_KEY]);
      
      // Actualizar todas las páginas de la consulta infinita
      queryClient.setQueriesData(
        { queryKey: [REPORTS_CACHE_KEY] },
        (oldData) => {
          // Solo procesar datos de consultas infinitas
          if (!oldData || !oldData.pages) return oldData;
          
          // Filtrar el reporte eliminado de cada página
          return {
            ...oldData,
            pages: oldData.pages.map(page => ({
              ...page,
              items: page.items.filter(item => item.id !== reportId),
            })),
          };
        }
      );
      
      return { previousCacheData };
    },
    // Invalidar cache al finalizar
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
    },
  });
};

================
File: src/hooks/useStorage.js
================
// src/hooks/useStorage.js - Versión mejorada
import { useState, useCallback } from "react";
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { storage } from "../firebase";
import { v4 as uuidv4 } from "uuid";

export const useStorage = () => {
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState(null);
  const [progress, setProgress] = useState(0);

  // Función para comprimir imagen antes de subir
  const compressImage = async (file, maxWidth = 1200, maxHeight = 1000, quality = 0.7) => {
    return new Promise((resolve, reject) => {
      // Verificar si el archivo es una imagen
      if (!file.type.match(/image.*/)) {
        return resolve(file); // Si no es imagen, devolver el archivo original
      }

      // Crear un elemento de imagen para cargar el archivo
      const img = new Image();
      img.src = URL.createObjectURL(file);
      
      img.onload = () => {
        // Crear un canvas para redimensionar la imagen
        const canvas = document.createElement('canvas');
        
        // Calcular dimensiones manteniendo la proporción
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        if (height > maxHeight) {
          width = (width * maxHeight) / height;
          height = maxHeight;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        // Dibujar la imagen redimensionada
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Convertir a blob con la calidad especificada
        canvas.toBlob((blob) => {
          if (blob) {
            // Crear un nuevo archivo con el blob comprimido
            const compressedFile = new File([blob], file.name, {
              type: 'image/jpeg',
              lastModified: Date.now()
            });
            
            resolve(compressedFile);
          } else {
            reject(new Error('Error al comprimir la imagen'));
          }
        }, 'image/jpeg', quality);
      };
      
      img.onerror = () => {
        reject(new Error('Error al cargar la imagen para compresión'));
      };
    });
  };

  const uploadFile = useCallback(async (file, folder, fileNamePrefix) => {
    if (!file) return null;
    setUploading(true);
    setError(null);
    setProgress(0);
    
    try {
      // Comprimir la imagen si es necesario
      let fileToUpload = file;
      
      // Solo comprimir si es una imagen
      if (file.type.match(/image.*/)) {
        fileToUpload = await compressImage(file);
        console.log(`Imagen comprimida: ${file.size} -> ${fileToUpload.size} bytes`);
      }
      
      // Generar nombre de archivo único
      const fileName = `${fileNamePrefix}_${uuidv4()}_${file.name.replace(/[^a-zA-Z0-9.]/g, "_")}`;
      const storageRef = ref(storage, `${folder}/${fileName}`);
      
      // Subir archivo
      await uploadBytes(storageRef, fileToUpload);
      setProgress(100);
      
      // Obtener URL de descarga
      const url = await getDownloadURL(storageRef);
      return url;
    } catch (err) {
      setError(err.message);
      return null;
    } finally {
      setUploading(false);
    }
  }, []);

  return { uploadFile, uploading, progress, error };
};

================
File: src/index.css
================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: src/index.js
================
// Primero, agregar React Query a las dependencias en package.json:
// "dependencies": {
//   ...
//   "@tanstack/react-query": "^5.0.0",
//   ...
// }

// src/index.js - Configuración de React Query
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './App';
import './index.css';
import reportWebVitals from './reportWebVitals';

// Crear cliente de React Query con configuración óptima
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutos
      cacheTime: 10 * 60 * 1000, // 10 minutos
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);

reportWebVitals();

================
File: src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: src/ReportPDF.js
================
import React from "react";
import { Document, Page, Text, View, StyleSheet, Image, Link } from "@react-pdf/renderer";

const styles = StyleSheet.create({
  page: { padding: 20, fontSize: 12 },
  title: { fontSize: 14, fontWeight: "bold", marginBottom: 10 },
  text: { marginBottom: 5 },
  table: { display: "table", width: "100%", borderStyle: "solid", borderWidth: 1 },
  tableRow: { flexDirection: "row", borderBottomWidth: 1 },
  tableCol: { width: "25%", borderRightWidth: 1, padding: 5 },
  tableColLast: { width: "25%", padding: 5 },
  image: { width: 200, height: 150, marginVertical: 10 }
});

const ReportPDF = ({ reports }) => (
  <Document>
    {reports.map((report, index) => (
      <Page key={index} size="A4" style={styles.page}>
        <Text style={styles.title}>Parte del {new Date(report.reportDate).toLocaleDateString()}</Text>
        <Text>Proyecto: {report.projectId}</Text>
        <Text>Cliente: {report.client || "No disponible"}</Text>

        <Text style={styles.title}>Mano de obra</Text>
        <View style={styles.table}>
          <View style={styles.tableRow}>
            <Text style={styles.tableCol}>Horas trabajadas</Text>
            <Text style={styles.tableColLast}>{report.labor.officialHours} (Oficial) / {report.labor.workerHours} (Peón)</Text>
          </View>
          <View style={styles.tableRow}>
            <Text style={styles.tableCol}>Coste total</Text>
            <Text style={styles.tableColLast}>{report.totalCost}€</Text>
          </View>
        </View>

        <Text style={styles.title}>Trabajos realizados</Text>
        <Text>{report.workPerformed.description}</Text>
        {report.workPerformed.photos.map((photo, i) => (
          <Image key={i} src={photo} style={styles.image} />
        ))}
      </Page>
    ))}
  </Document>
);

export default ReportPDF;

================
File: src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: src/setupTests.js
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

================
File: src/storageService.js
================
import { storage } from "./firebaseConfig";
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";

export const subirArchivo = async (file, folder, projectId, reportDate) => {
  const fileName = `${projectId}_${reportDate}_${Date.now()}_${file.name.replace(/[^a-zA-Z0-9.]/g, "_")}`;
  const storageRef = ref(storage, `${folder}/${fileName}`);

  await uploadBytes(storageRef, file);
  return getDownloadURL(storageRef);
};

================
File: src/utils/formatters.js
================
export const formatNumber = (num) => parseFloat(num).toFixed(2);
export const formatCurrency = (num) => `€${formatNumber(num)}`;
export const formatFullDate = (date) =>
  new Date(date).toLocaleDateString("es-ES", { weekday: "long", day: "numeric", month: "long", year: "numeric" });
export const getWeekNumber = (date) => {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
};

================
File: src/utils/PdfDownload.js
================
// src/utils/PdfDownload.js - Versión simplificada
import React from 'react';
import { pdf } from '@react-pdf/renderer';
import { saveAs } from 'file-saver';

const PDFDownloadButton = ({ 
  Document, 
  documentProps = {}, 
  fileName = 'document.pdf',
  buttonProps = {},
  children
}) => {
  const generatePdf = async () => {
    try {
      // Crear el PDF sin complicaciones adicionales
      const blob = await pdf(<Document {...documentProps} />).toBlob();
      saveAs(blob, fileName);
    } catch (err) {
      console.error('Error al generar PDF:', err);
      alert('Error al generar el PDF. Por favor, inténtalo de nuevo.');
    }
  };

  return (
    <div className="pdf-download-container">
      <button
        onClick={generatePdf}
        {...buttonProps}
      >
        {children || 'Descargar PDF'}
      </button>
    </div>
  );
};

export const generateAndDownloadPDF = async (Document, documentProps = {}, fileName = 'document.pdf') => {
  try {
    const blob = await pdf(<Document {...documentProps} />).toBlob();
    saveAs(blob, fileName);
    return { success: true };
  } catch (err) {
    console.error('Error al generar PDF:', err);
    return { success: false, error: err.message };
  }
};

export default PDFDownloadButton;

================
File: src/utils/validationSchemas.js
================
// src/utils/validationSchemas.js

// Funciones de validación básicas
const isRequired = (value) => !!value || value === 0;
const isNumber = (value) => !isNaN(parseFloat(value)) && isFinite(value);
const isPositiveNumber = (value) => isNumber(value) && parseFloat(value) >= 0;
const isValidTime = (value) => /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value);
const isValidDate = (value) => !isNaN(Date.parse(value));
const isValidEmail = (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

// Esquema para proyectos
export const projectSchema = {
  id: {
    validator: (value) => isRequired(value) && /^[a-zA-Z0-9-_]+$/.test(value),
    message: "El ID es obligatorio y solo puede contener letras, números, guiones y guiones bajos.",
  },
  client: {
    validator: isRequired,
    message: "El cliente es obligatorio.",
  },
  address: {
    validator: isRequired,
    message: "La dirección es obligatoria.",
  },
  nifNie: {
    validator: (value) => isRequired(value) && /^[0-9XYZ][0-9]{7}[A-Z]$/.test(value),
    message: "El NIF/NIE debe tener un formato válido.",
  },
  type: {
    validator: (value) => ["hourly", "fixed"].includes(value),
    message: "El tipo debe ser 'hourly' o 'fixed'.",
  },
  officialPrice: {
    validator: (value, formData) => 
      formData.type !== "hourly" || isPositiveNumber(value),
    message: "El precio por hora del oficial debe ser un número positivo.",
  },
  workerPrice: {
    validator: (value, formData) => 
      formData.type !== "hourly" || isPositiveNumber(value),
    message: "El precio por hora del peón debe ser un número positivo.",
  },
  budgetAmount: {
    validator: (value, formData) => 
      formData.type !== "fixed" || isPositiveNumber(value),
    message: "El importe del presupuesto debe ser un número positivo.",
  },
};

// Esquema para partes diarios
export const dailyReportSchema = {
  reportDate: {
    validator: isValidDate,
    message: "La fecha debe ser válida.",
  },
  // Para proyectos por horas
  "labor.officialEntry": {
    validator: (value, formData) => 
      formData.projectType !== "hourly" || !value || isValidTime(value),
    message: "La hora de entrada del oficial debe tener un formato válido (HH:MM).",
  },
  "labor.officialExit": {
    validator: (value, formData) => 
      formData.projectType !== "hourly" || !value || isValidTime(value),
    message: "La hora de salida del oficial debe tener un formato válido (HH:MM).",
  },
  "labor.workerEntry": {
    validator: (value, formData) => 
      formData.projectType !== "hourly" || !value || isValidTime(value),
    message: "La hora de entrada del peón debe tener un formato válido (HH:MM).",
  },
  "labor.workerExit": {
    validator: (value, formData) => 
      formData.projectType !== "hourly" || !value || isValidTime(value),
    message: "La hora de salida del peón debe tener un formato válido (HH:MM).",
  },
  // Para todos los tipos
  "workPerformed.description": {
    validator: isRequired,
    message: "La descripción de los trabajos realizados es obligatoria.",
  },
  // Para proyectos de presupuesto cerrado
  "workPerformed.invoicedAmount": {
    validator: (value, formData) => 
      formData.projectType !== "fixed" || isPositiveNumber(value),
    message: "El importe facturado debe ser un número positivo.",
  },
};

// Esquema para materiales
export const materialSchema = {
  description: {
    validator: isRequired,
    message: "La descripción del material es obligatoria.",
  },
  cost: {
    validator: isPositiveNumber,
    message: "El coste debe ser un número positivo.",
  },
};

// Utilidad para validar formularios
export const validateForm = (data, schema, context = {}) => {
  const errors = {};
  
  Object.entries(schema).forEach(([field, { validator, message }]) => {
    // Manejar campos anidados (e.g., 'labor.officialEntry')
    const fieldParts = field.split('.');
    let value = data;
    
    for (const part of fieldParts) {
      value = value && typeof value === 'object' ? value[part] : undefined;
    }
    
    // Validar el campo
    if (!validator(value, { ...data, ...context })) {
      errors[field] = message;
    }
  });
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

================
File: storage.rules
================
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Regla por defecto: denegar todo
    match /{allPaths=**} {
      allow read, write: if false;
    }
    
    // Reglas para facturas (invoices)
    match /invoices/{fileName} {
      // Lectura: Cualquier usuario autenticado puede leer facturas
      allow read: if request.auth != null;
      
      // Escritura: Validar formato de archivo, tamaño y prefijo de nombre
      allow write: if request.auth != null && 
                     // Validar que el nombre tiene un formato válido (prefijo_fecha_uuid)
                     fileName.matches('^[^_]+_[0-9]{4}-[0-9]{2}-[0-9]{2}.*$') &&
                     // Validar tipo de archivo (PDF)
                     request.resource.contentType.matches('application/pdf') &&
                     // Limitar tamaño a 10MB
                     request.resource.size < 10 * 1024 * 1024;
      
      // Permitir eliminación si el usuario está autenticado
      // En un escenario ideal, verificaríamos si es el propietario, pero 
      // no podemos consultar Firestore directamente desde las reglas de Storage
      allow delete: if request.auth != null;
    }
    
    // Reglas para fotos
    match /photos/{fileName} {
      // Lectura: Cualquier usuario autenticado puede ver fotos
      allow read: if request.auth != null;
      
      // Escritura: Validar formato, tamaño y prefijo de nombre
      allow write: if request.auth != null && 
                     // Validar que el nombre tiene un formato válido (prefijo_fecha_uuid)
                     fileName.matches('^[^_]+_[0-9]{4}-[0-9]{2}-[0-9]{2}.*$') &&
                     // Validar tipo de archivo (imágenes)
                     request.resource.contentType.matches('image/.*') &&
                     // Limitar tamaño a 5MB
                     request.resource.size < 5 * 1024 * 1024;
      
      // Permitir eliminación si el usuario está autenticado
      allow delete: if request.auth != null;
    }
  }
}



================================================================
End of Codebase
================================================================
