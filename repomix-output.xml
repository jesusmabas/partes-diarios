This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebaserc
.gitignore
.repomixignore
cors.json
firebase.json
firestore.indexes.json
firestore.rules
functions/index.js
functions/package.json
jest.config.js
package.json
public/index.html
public/manifest.json
public/robots.txt
README.md
repomix.config.json
src/__mocks__/fileMock.js
src/__mocks__/styleMock.js
src/App.css
src/App.js
src/components/common/ConfirmModal.js
src/components/common/EmptyState.js
src/components/common/ErrorDisplay.js
src/components/common/PDFButton.js
src/components/CompressedImage.js
src/components/DailyReportForm.js
src/components/Dashboard.css
src/components/Dashboard.js
src/components/dashboard/DashboardCharts.js
src/components/dashboard/DashboardFilters.js
src/components/dashboard/DashboardSkeleton.js
src/components/dashboard/DashboardSummary.js
src/components/dashboard/KPICards.js
src/components/dashboard/ProjectCostChart.js
src/components/dashboard/TimelineChart.js
src/components/ExtraWork.css
src/components/ExtraWorkForm.js
src/components/FixedReportForm.js
src/components/ImageUploader.css
src/components/ImageUploader.js
src/components/LaborForm.js
src/components/LoginForm.js
src/components/MaterialsForm.js
src/components/ProjectForm.css
src/components/ProjectForm.js
src/components/ProjectSelector.js
src/components/ProjectsViewer.js
src/components/ReportPDFGenerator.js
src/components/reports/details/ReportFixedAmountDetails.js
src/components/reports/details/ReportLaborDetails.js
src/components/reports/details/ReportMaterialsDetails.js
src/components/reports/MaterialsEditor.js
src/components/reports/PhotosEditor.js
src/components/reports/ReportDeleteModal.js
src/components/reports/ReportEditForm.js
src/components/reports/ReportFilters.js
src/components/reports/ReportItem.js
src/components/reports/Reports.css
src/components/reports/ReportsList.js
src/components/reports/ReportSummary.js
src/components/reports/ReportsViewer.js
src/components/WorkPerformedForm.js
src/firebase.js
src/hooks/__tests__/useCalculationsService.test.js
src/hooks/__tests__/useFormValidation.test.js
src/hooks/reports/_useReportSummary.js
src/hooks/reports/useReportActions.js
src/hooks/reports/useReportFilters.js
src/hooks/reports/useReportSummary.js
src/hooks/useCalculationsService.js
src/hooks/useFormValidation.js
src/hooks/useLabor.js
src/hooks/useLocalStorage.js
src/hooks/useQueryProjects.js
src/hooks/useQueryReports.js
src/hooks/useQueryUser.js
src/hooks/useStorage.js
src/index.css
src/index.js
src/reportWebVitals.js
src/setupTests.js
src/tests/examples/asyncTestExample.test.js
src/tests/integration/calculationsIntegration.test.js
src/utils/__tests__/calculationUtils.test.js
src/utils/calculations/__tests__/budgetUtils.test.js
src/utils/calculations/__tests__/extraWorkUtils.test.js
src/utils/calculations/__tests__/laborUtils.test.js
src/utils/calculations/__tests__/materialsUtils.test.js
src/utils/calculations/__tests__/reportSummaryUtils.test.js
src/utils/calculations/budgetUtils.js
src/utils/calculations/extraWorkUtils.js
src/utils/calculations/laborUtils.js
src/utils/calculations/materialsUtils.js
src/utils/calculations/reportSummaryUtils.js
src/utils/calculationUtils.js
src/utils/formatters.js
src/utils/PdfDownload.js
src/utils/validationSchemas.js
storage.rules
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
*.log
tmp/
</file>

<file path="jest.config.js">
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapper: {
    // Manejar importaciones de archivos est√°ticos
    '\\.(css|less|scss|sass)
: '<rootDir>/__mocks__/styleMock.js',
    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)
: '<rootDir>/__mocks__/fileMock.js',
  },
  transform: {
    '^.+\\.(js|jsx)
: 'babel-jest',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',  
    '!src/reportWebVitals.js',
    '!src/firebase.js', // Excluir configuraciones
    '!src/App.js',      // Generalmente se testea con tests de integraci√≥n
    // Enfocarse especialmente en los archivos de utilidades y hooks
    'src/utils/calculations/**/*.js',
    'src/utils/calculationUtils.js',
    'src/utils/formatters.js',
    'src/hooks/useCalculationsService.js',
    'src/hooks/useFormValidation.js',
  ],
  coverageThreshold: {
    global: {
      statements: 80,
      branches: 80,
      functions: 80,
      lines: 80,
    },
  },
};
</file>

<file path="public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src/__mocks__/fileMock.js">
module.exports = 'test-file-stub';
</file>

<file path="src/__mocks__/styleMock.js">
module.exports = {};
</file>

<file path="src/components/common/ConfirmModal.js">
import React from "react";
import PropTypes from "prop-types";

/**
 * Componente modal gen√©rico para confirmaciones
 * @param {Object} props - Propiedades del componente
 * @param {string} props.title - T√≠tulo del modal
 * @param {string} props.message - Mensaje de confirmaci√≥n
 * @param {string} props.confirmText - Texto del bot√≥n de confirmaci√≥n
 * @param {string} props.cancelText - Texto del bot√≥n de cancelaci√≥n
 * @param {Function} props.onConfirm - Funci√≥n a ejecutar al confirmar
 * @param {Function} props.onCancel - Funci√≥n a ejecutar al cancelar
 * @param {string} props.confirmButtonClass - Clase CSS para el bot√≥n de confirmaci√≥n
 * @param {boolean} props.isDangerous - Si es una acci√≥n peligrosa (cambia el estilo)
 */
const ConfirmModal = ({ 
  title = "Confirmar acci√≥n",
  message = "¬øEst√°s seguro de que quieres realizar esta acci√≥n?", 
  confirmText = "Confirmar", 
  cancelText = "Cancelar",
  onConfirm,
  onCancel,
  confirmButtonClass = "",
  isDangerous = false
}) => {
  const handleConfirm = () => {
    if (typeof onConfirm === 'function') {
      onConfirm();
    }
  };

  const handleCancel = () => {
    if (typeof onCancel === 'function') {
      onCancel();
    }
  };

  // Prevenir que clics en el modal se propaguen al overlay
  const handleModalClick = (e) => {
    e.stopPropagation();
  };

  return (
    <div className="modal-overlay" onClick={handleCancel}>
      <div className="modal" onClick={handleModalClick}>
        <h3>{title}</h3>
        <p>{message}</p>
        
        {isDangerous && (
          <p className="warning">Esta acci√≥n no se puede deshacer.</p>
        )}
        
        <div className="modal-actions">
          <button 
            onClick={handleConfirm} 
            className={`confirm-button ${isDangerous ? 'dangerous' : ''} ${confirmButtonClass}`}
          >
            {confirmText}
          </button>
          <button 
            onClick={handleCancel} 
            className="cancel-button"
          >
            {cancelText}
          </button>
        </div>
      </div>
    </div>
  );
};

ConfirmModal.propTypes = {
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
  onConfirm: PropTypes.func.isRequired,
  onCancel: PropTypes.func.isRequired,
  confirmButtonClass: PropTypes.string,
  isDangerous: PropTypes.bool
};

export default React.memo(ConfirmModal);
</file>

<file path="src/components/common/EmptyState.js">
// src/components/common/EmptyState.js
import React from "react";

/**
 * Componente que muestra un estado vac√≠o con un mensaje y un icono
 * @param {Object} props - Propiedades del componente
 * @param {string} props.title - T√≠tulo opcional para el estado vac√≠o
 * @param {string} props.message - Mensaje que describe el estado vac√≠o
 * @param {string} props.icon - Emoji o icono para mostrar
 * @param {Function} props.action - Funci√≥n opcional para realizar una acci√≥n
 * @param {string} props.actionLabel - Etiqueta para el bot√≥n de acci√≥n
 */
const EmptyState = ({ 
  title = "No hay datos disponibles", 
  message, 
  icon = "üìä", 
  action, 
  actionLabel = "Actualizar"
}) => {
  return (
    <div className="empty-state" role="status" aria-live="polite">
      <div className="empty-state-icon">{icon}</div>
      <h3 className="empty-state-title">{title}</h3>
      <p className="empty-state-message">{message}</p>
      
      {action && (
        <button 
          onClick={action} 
          className="empty-state-action"
          type="button"
        >
          {actionLabel}
        </button>
      )}
    </div>
  );
};

export default EmptyState;
</file>

<file path="src/components/common/ErrorDisplay.js">
// src/components/common/ErrorDisplay.js
import React from "react";

/**
 * Componente para mostrar errores con opci√≥n de reintentar
 * @param {Object} props - Propiedades del componente
 * @param {string|Object} props.error - Error capturado
 * @param {string} props.message - Mensaje descriptivo del error
 * @param {Function} props.onRetry - Funci√≥n a ejecutar al reintentar
 */
const ErrorDisplay = ({ error, message, onRetry }) => {
  // Extraer mensaje de error de diferentes tipos de errores
  const errorMessage = typeof error === 'string' 
    ? error 
    : error?.message || 'Se ha producido un error desconocido';
  
  return (
    <div className="error-display" role="alert" aria-live="assertive">
      <div className="error-icon">‚ùå</div>
      <h3 className="error-title">{message}</h3>
      <p className="error-details">{errorMessage}</p>
      
      {onRetry && (
        <button 
          onClick={onRetry} 
          className="error-retry-button"
          type="button"
        >
          Reintentar
        </button>
      )}
      
      <p className="error-help">
        Si el problema persiste, contacta con soporte t√©cnico.
      </p>
    </div>
  );
};

export default ErrorDisplay;
</file>

<file path="src/components/common/PDFButton.js">
// src/components/common/PDFButton.js
import React from "react";
import { PDFDownloadLink } from "@react-pdf/renderer";
import ReportPDFGenerator from "../ReportPDFGenerator";

const PDFButton = ({ 
  reports, 
  projects, 
  selectedProjectId, 
  dateRange,
  disabled 
}) => {
  if (disabled) {
    return (
      <p className="pdf-disabled-message">
        Para generar un PDF, selecciona un proyecto y aseg√∫rate de que haya reportes disponibles.
      </p>
    );
  }

  return (
    <div className="pdf-button-container">
      <PDFDownloadLink
        document={
          <ReportPDFGenerator 
            reports={reports.map(r => ({...r}))} 
            projects={projects.map(p => ({...p}))} 
          />
        }
        fileName={`informe_${selectedProjectId || 'todos'}_${dateRange.startDate || 'inicio'}_${dateRange.endDate || 'fin'}.pdf`}
      >
        {({ blob, url, loading, error }) => {
          if (error) {
            console.error("Error en PDFDownloadLink:", error);
            return (
              <button className="pdf-button error-button">
                Error al generar PDF
              </button>
            );
          }
          return (
            <button className="pdf-button">
              {loading ? "Preparando PDF..." : "Descargar Informe en PDF"}
            </button>
          );
        }}
      </PDFDownloadLink>
    </div>
  );
};

export default React.memo(PDFButton);
</file>

<file path="src/components/CompressedImage.js">
import React, { useState, useEffect } from "react";
import { Image as PDFImage, View, Text } from "@react-pdf/renderer";

// Componente para comprimir im√°genes antes de mostrarlas en el PDF
const CompressedImage = ({ src, style, maxWidth = 600, maxHeight = 500, quality = 0.6 }) => {
  const [compressedSrc, setCompressedSrc] = useState(null);
  const [error, setError] = useState(false);

  useEffect(() => {
    const compressImage = async () => {
      if (!src || typeof src !== "string" || !src.startsWith("http")) {
        setError(true);
        return;
      }

      try {
        // Crear un elemento de imagen para cargar la imagen original
        const img = new Image();
        img.crossOrigin = "Anonymous"; // Necesario para im√°genes de otros dominios

        img.onload = () => {
          // Crear un canvas para redimensionar y comprimir la imagen
          const canvas = document.createElement("canvas");
          
          // Calcular las nuevas dimensiones manteniendo la proporci√≥n
          let width = img.width;
          let height = img.height;
          
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }
          
          if (height > maxHeight) {
            width = (width * maxHeight) / height;
            height = maxHeight;
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // Dibujar la imagen redimensionada en el canvas
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, width, height);
          
          // Convertir el canvas a una URL de datos con la calidad especificada
          const compressedDataUrl = canvas.toDataURL("image/jpeg", quality);
          setCompressedSrc(compressedDataUrl);
        };

        img.onerror = () => {
          setError(true);
        };

        // Iniciar la carga de la imagen
        img.src = src;
      } catch (error) {
        console.error("Error al comprimir imagen:", error);
        setError(true);
      }
    };

    compressImage();
  }, [src, maxWidth, maxHeight, quality]);

  if (error) {
    return (
      <View style={{ ...style, backgroundColor: "#f0f0f0", padding: 5 }}>
        <Text style={{ fontSize: 10, textAlign: "center" }}>Imagen no disponible</Text>
      </View>
    );
  }

  return compressedSrc ? <PDFImage src={compressedSrc} style={style} /> : null;
};

export default CompressedImage;
</file>

<file path="src/components/dashboard/DashboardSkeleton.js">
// src/components/dashboard/DashboardSkeleton.js
import React from "react";

/**
 * Componente esqueleto para el Dashboard durante la carga
 * Muestra un esqueleto animado mientras los datos se cargan
 */
const DashboardSkeleton = () => {
  return (
    <div className="dashboard skeleton-container" aria-busy="true" aria-label="Cargando dashboard">
      <h2 className="section-title">Dashboard</h2>
      
      {/* Esqueleto para KPIs */}
      <div className="metrics-container">
        {[...Array(5)].map((_, i) => (
          <div key={i} className="metric-card skeleton-card">
            <div className="skeleton-circle"></div>
            <div className="skeleton-line" style={{ width: '60%', height: '24px' }}></div>
            <div className="skeleton-line" style={{ width: '80%', height: '16px' }}></div>
          </div>
        ))}
      </div>
      
      {/* Esqueleto para filtros */}
      <div className="dashboard-filter skeleton-filter">
        <h3>Filtros</h3>
        <div className="skeleton-line" style={{ width: '100%', height: '40px', marginBottom: '20px' }}></div>
        <div className="skeleton-line" style={{ width: '100%', height: '40px' }}></div>
      </div>
      
      {/* Esqueleto para gr√°ficos */}
      <div className="chart-container">
        <div className="skeleton-tabs">
          <div className="skeleton-tab"></div>
          <div className="skeleton-tab"></div>
        </div>
        <div className="skeleton-chart"></div>
      </div>
      
      {/* Esqueleto para tabla */}
      <div className="dashboard-section">
        <h3>Resumen de Datos</h3>
        <div className="skeleton-table">
          <div className="skeleton-row header"></div>
          {[...Array(4)].map((_, i) => (
            <div key={i} className="skeleton-row"></div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default DashboardSkeleton;
</file>

<file path="src/components/ExtraWork.css">
/* src/components/ExtraWork.css - Estilos para trabajos extra */

/* Estilos generales para el formulario de trabajos extra */
.extra-work-form {
  background-color: #fffaed;
  border-left: 4px solid #E67E22;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 0 5px 5px 0;
}

.extra-work-form h3 {
  color: #d35400;
  margin-top: 0;
  padding-bottom: 10px;
  border-bottom: 1px solid #f0e0c0;
}

/* Estilos para grupo de opciones de radio */
.radio-group {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 15px;
}

.radio-option {
  display: flex;
  align-items: center;
  gap: 5px;
}

.radio-option input[type="radio"] {
  margin: 0;
  width: auto;
}

.radio-option label {
  margin: 0;
  font-weight: normal;
}

/* Estilos para el grupo de checkbox */
.checkbox-group {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
  background-color: #f8f9fa;
  padding: 12px;
  border-radius: 5px;
  border-left: 3px solid #8D432D;
}

.checkbox-input {
  width: auto !important;
  margin: 0 !important;
}

.checkbox-label {
  margin: 0 !important;
  font-weight: normal;
}

/* Dise√±o mejorado para los campos de entrada num√©rica en el formulario extra */
.extra-work-form input[type="number"] {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  width: 100%;
  max-width: 300px;
}

/* Texto de ayuda e informaci√≥n */
.form-hint {
  font-size: 0.9rem;
  color: #666;
  margin-top: 5px;
  font-style: italic;
}

/* Mensaje de informaci√≥n sobre trabajos extra */
.extra-work-info {
  background-color: #e8f4f8;
  padding: 12px;
  border-radius: 5px;
  border-left: 4px solid #3498db;
  margin-bottom: 15px;
  font-size: 0.95rem;
  color: #2c3e50;
}

/* Estilos para la tabla de resumen que incluye trabajos extra */
.summary-table .extra-section-header {
  background-color: #fff8e1;
  font-weight: bold;
  color: #e67e22;
}

.summary-table .extra-section-header td {
  padding-top: 12px;
  padding-bottom: 12px;
  border-bottom: 2px solid #f0ad4e;
}

/* Indicador visual para trabajos extra en reportes */
.report-card.extra-work {
  border-left: 4px solid #E67E22;
  background-color: #fffaf3;
}

.extra-work-badge {
  background-color: #E67E22;
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  display: inline-block;
  margin-bottom: 8px;
}

/* Estilos responsivos para m√≥viles */
@media (max-width: 768px) {
  .radio-group {
    flex-direction: column;
    gap: 10px;
  }
  
  .extra-work-form {
    padding: 15px;
  }
}
</file>

<file path="src/components/ExtraWorkForm.js">
// src/components/ExtraWorkForm.js - Refactorizado para usar useCalculationsService

import React, { useState, useCallback } from "react";
import { formatCurrency } from "../utils/calculationUtils";
import { useCalculationsService } from "../hooks/useCalculationsService";
import LaborForm from "./LaborForm";
import MaterialsForm from "./MaterialsForm";
import WorkPerformedForm from "./WorkPerformedForm";
import "./ExtraWork.css"; // Importar el archivo CSS


/**
 * Componente para gestionar trabajos extra en proyectos de presupuesto cerrado
 * 
 * @param {Object} props 
 * @param {Object} props.extraWorkData - Datos del trabajo extra
 * @param {Function} props.onExtraWorkChange - Funci√≥n que se ejecuta al cambiar los datos
 * @param {Object} props.project - Proyecto al que pertenece el trabajo extra
 * @param {string} props.reportDate - Fecha del parte diario
 */
const ExtraWorkForm = ({ 
  extraWorkData, 
  onExtraWorkChange, 
  project, 
  reportDate 
}) => {
  // Estado local para el tipo de trabajo extra
  const [extraWorkType, setExtraWorkType] = useState(extraWorkData.extraWorkType || "additional_budget");
  
  // Usamos el servicio centralizado de c√°lculos
  const { calculateLabor, calculateMaterials } = useCalculationsService();
  
  // Calculamos datos de labor y materiales
  const laborCalcs = calculateLabor(extraWorkData.labor, project);
  const materialsCalcs = calculateMaterials(extraWorkData.materials);
  
  // Total para trabajos extra por hora
  const extraWorkTotal = extraWorkType === "hourly" 
    ? laborCalcs.totalLaborCost + materialsCalcs.totalMaterialsCost
    : extraWorkData.extraBudgetAmount || 0;
  
  // Handler para cambio de tipo de trabajo extra
  const handleExtraWorkTypeChange = useCallback((e) => {
    const newType = e.target.value;
    setExtraWorkType(newType);
    
    // Actualizar datos seg√∫n el nuevo tipo
    onExtraWorkChange({
      ...extraWorkData,
      extraWorkType: newType,
    });
  }, [extraWorkData, onExtraWorkChange]);

  // Handler para cambio de importe adicional
  const handleExtraBudgetChange = useCallback((e) => {
    const value = parseFloat(e.target.value) || 0;
    onExtraWorkChange({
      ...extraWorkData,
      extraBudgetAmount: value
    });
  }, [extraWorkData, onExtraWorkChange]);

  // Handler para cambios en la mano de obra
  const handleLaborChange = useCallback((labor) => {
    onExtraWorkChange({
      ...extraWorkData,
      labor
    });
  }, [extraWorkData, onExtraWorkChange]);

  // Handler para cambios en materiales
  const handleMaterialsChange = useCallback((materials) => {
    onExtraWorkChange({
      ...extraWorkData,
      materials
    });
  }, [extraWorkData, onExtraWorkChange]);

  // Handler para cambios en el trabajo realizado
  const handleWorkPerformedChange = useCallback((workPerformed) => {
    onExtraWorkChange({
      ...extraWorkData,
      workPerformed: {
        ...extraWorkData.workPerformed,
        ...workPerformed
      }
    });
  }, [extraWorkData, onExtraWorkChange]);

  return (
    <div className="extra-work-form">
      <h3>Trabajos Extra (Fuera de Presupuesto)</h3>
      
      <div className="form-group">
        <label>Tipo de facturaci√≥n para trabajo extra:</label>
        <div className="radio-group">
          <div className="radio-option">
            <input 
              type="radio"
              id="extra-type-budget"
              name="extraWorkType"
              value="additional_budget"
              checked={extraWorkType === "additional_budget"}
              onChange={handleExtraWorkTypeChange}
            />
            <label htmlFor="extra-type-budget">Presupuesto adicional</label>
          </div>
          
          <div className="radio-option">
            <input 
              type="radio"
              id="extra-type-hourly"
              name="extraWorkType"
              value="hourly"
              checked={extraWorkType === "hourly"}
              onChange={handleExtraWorkTypeChange}
            />
            <label htmlFor="extra-type-hourly">Por horas</label>
          </div>
        </div>
      </div>
      
      {extraWorkType === "additional_budget" ? (
        <div className="form-group">
          <label htmlFor="extra-budget-amount">Importe adicional presupuestado (‚Ç¨)</label>
          <input
            id="extra-budget-amount"
            type="number"
            value={extraWorkData.extraBudgetAmount || 0}
            onChange={handleExtraBudgetChange}
            min="0"
            step="0.01"
          />
          {extraWorkData.extraBudgetAmount > 0 && (
            <p className="form-hint">Importe adicional: {formatCurrency(extraWorkData.extraBudgetAmount)}</p>
          )}
        </div>
      ) : (
        // Mostrar formularios para trabajo por horas
        <>
          <LaborForm 
            labor={extraWorkData.labor || { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" }} 
            onLaborChange={handleLaborChange} 
            project={project} 
          />
          
          <MaterialsForm
            materials={extraWorkData.materials || []}
            onMaterialsChange={handleMaterialsChange}
            projectId={project.id}
            reportDate={reportDate}
          />
          
          {/* Mostrar el total calculado para trabajo por horas */}
          {extraWorkType === "hourly" && (
            <div className="extra-work-total">
              <p className="total-summary">
                <strong>Total trabajo extra por horas:</strong> {formatCurrency(extraWorkTotal)}
              </p>
            </div>
          )}
        </>
      )}
      
      {/* Trabajo realizado (siempre visible) */}
      <WorkPerformedForm
        workPerformed={extraWorkData.workPerformed || { description: "", photos: [] }}
        onWorkPerformedChange={handleWorkPerformedChange}
        projectId={project.id}
        reportDate={reportDate}
      />
    </div>
  );
};

export default React.memo(ExtraWorkForm);
</file>

<file path="src/components/ImageUploader.css">
.image-uploader {
  margin: 20px 0;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

.drop-area {
  border: 2px dashed #ccc;
  border-radius: 5px;
  padding: 30px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  background-color: #f9f9f9;
}

.drop-area.dragging {
  background-color: #e6f7ff;
  border-color: #8D432D;
}

.drop-area:hover {
  background-color: #f0f0f0;
  border-color: #999;
}

.drop-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.upload-icon {
  font-size: 2rem;
  color: #8D432D;
}

.file-info {
  font-size: 0.85rem;
  color: #666;
  margin-top: 5px;
}

.preview-container {
  margin-top: 20px;
}

.previews {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-top: 10px;
  margin-bottom: 15px;
}

.preview-item {
  position: relative;
  width: 150px;
  border-radius: 5px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  background-color: white;
}

.preview-item img {
  width: 100%;
  height: 120px;
  object-fit: cover;
  display: block;
}

.preview-info {
  padding: 8px;
  font-size: 0.8rem;
}

.file-name {
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}

.file-size {
  color: #666;
  font-size: 0.75rem;
}

.remove-button {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
}

.remove-button:hover {
  background-color: rgba(255, 0, 0, 0.7);
}

.upload-button {
  padding: 10px 15px;
  background-color: #8D432D;
  color: white;
  border: none;
  border-radius: 0;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s ease;
  display: block;
  margin-top: 10px;
}

.upload-button:hover:not(:disabled) {
  background-color: #7A3624;
}

.upload-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.upload-errors {
  margin-top: 15px;
  padding: 10px;
  background-color: #fff0f0;
  border-left: 4px solid #e74c3c;
  border-radius: 3px;
}

.error-message {
  color: #e74c3c;
  margin: 5px 0;
  font-size: 0.9rem;
}

.upload-progress {
  font-size: 0.75rem;
  color: #4caf50;
}

.upload-progress.error {
  color: #e74c3c;
}

.existing-images {
  margin-top: 20px;
}

/* Estilos responsivos */
@media (max-width: 768px) {
  .previews {
    justify-content: center;
  }
  
  .preview-item {
    width: 130px;
  }
  
  .preview-item img {
    height: 100px;
  }
}
</file>

<file path="src/components/ProjectForm.css">
/* ProjectForm.css - Estilos espec√≠ficos para el formulario de proyectos */

/* Contenedor del formulario */
.project-form {
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 30px;
}

/* Grupo de campos del formulario */
.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: #333;
}

.form-group input,
.form-group select {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  transition: border-color 0.3s;
}

.form-group input:focus,
.form-group select:focus {
  border-color: #8D432D;
  outline: none;
}

/* Estilo para campo con error */
.input-error {
  border-color: #e74c3c !important;
  background-color: #fff8f8;
}

/* Grupo de checkbox */
.checkbox-group {
  display: flex;
  align-items: center;
  background-color: #f8f9fa;
  padding: 12px 15px;
  border-radius: 5px;
  border-left: 3px solid #8D432D;
}

.checkbox-input {
  width: auto !important;
  margin-right: 10px !important;
}

.checkbox-label {
  margin: 0;
  font-weight: normal;
}

/* Secci√≥n de trabajos extra */
.extra-work-section {
  background-color: #fffaed;
  border-left: 4px solid #E67E22;
  padding: 15px;
  margin-top: 15px;
  margin-bottom: 20px;
  border-radius: 0 5px 5px 0;
}

.extra-work-section h4 {
  color: #d35400;
  margin-top: 0;
  padding-bottom: 8px;
  border-bottom: 1px solid #f0e0c0;
}

.hint-text {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 15px;
  font-style: italic;
}

/* Botones */
.project-form button {
  padding: 12px 20px;
  background-color: #8D432D;
  color: white;
  border: none;
  border-radius: 0;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s;
  margin-right: 10px;
}

.project-form button:hover:not(:disabled) {
  background-color: #7A3624;
}

.project-form button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.button-secondary {
  background-color: #6c757d !important;
}

.button-secondary:hover:not(:disabled) {
  background-color: #5a6268 !important;
}

.button-disabled {
  opacity: 0.65;
}

/* Mensajes de feedback */
.error-message {
  background-color: #fff0f0;
  border-left: 4px solid #e74c3c;
  padding: 10px 15px;
  margin: 10px 0;
  border-radius: 0 4px 4px 0;
  color: #c0392b;
}

.success-message {
  background-color: #e8f7eb;
  border-left: 4px solid #27ae60;
  padding: 10px 15px;
  margin: 10px 0;
  border-radius: 0 4px 4px 0;
  color: #27ae60;
}

/* Animaci√≥n de carga para botones */
.button-loading {
  position: relative;
  overflow: hidden;
  background-color: #8D432D !important;
}

.button-loading::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: linear-gradient(
    45deg,
    rgba(255, 255, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.2) 75%,
    transparent 75%,
    transparent
  );
  background-size: 30px 30px;
  animation: loading-animation 2s linear infinite;
  z-index: 1;
}

@keyframes loading-animation {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 60px 30px;
  }
}

/* Estilos responsivos */
@media (max-width: 768px) {
  .project-form {
    padding: 15px;
  }
  
  .extra-work-section {
    padding: 12px;
  }
  
  .project-form button {
    width: 100%;
    margin-bottom: 10px;
  }
}

/* Estilo mejorado para el contenedor de detalles del proyecto */
.project-details {
  background-color: #f9f9f9;
  border: 1px solid #e0e0e0;
  border-left: 4px solid #8D432D;
  border-radius: 6px;
  padding: 16px 20px;
  margin: 20px 0 30px 0;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

/* T√≠tulo para la secci√≥n de detalles */
.project-details-title {
  font-family: "Cormorant", serif;
  font-size: 1.2rem;
  font-weight: bold;
  color: #2c3e50;
  margin-top: 0;
  margin-bottom: 15px;
  padding-bottom: 8px;
  border-bottom: 1px solid #eaeaea;
}

/* Estilo para cada l√≠nea de detalle - alineado a la izquierda */
.project-details p {
  margin: 8px 0;
  padding: 4px 0;
  display: block; /* Cambiado de flex a block */
  border-bottom: 1px dotted #eee;
  line-height: 1.6;
}

/* Resaltar etiquetas de los campos */
.project-details .detail-label {
  font-weight: 500;
  color: #555;
  display: inline-block; /* Para mantenerlo en l√≠nea */
  width: auto; /* Sin ancho fijo */
  margin-right: 8px;
}

/* Resaltar valores de los campos */
.project-details .detail-value {
  font-weight: 600;
  color: #2c3e50;
  display: inline-block; /* Para mantenerlo en l√≠nea */
}

/* Informaci√≥n de trabajos extra */
.project-details .extra-work-info {
  background-color: #fff8e1;
  color: #e67e22;
  padding: 8px 12px;
  border-radius: 4px;
  font-weight: 500;
  display: block; /* Cambiado a block para que ocupe toda la l√≠nea */
  margin-top: 10px;
  border-left: 3px solid #e67e22;
}

/* Separador entre selector y detalles */
.project-selector {
  margin-bottom: 10px;
}
</file>

<file path="src/components/reports/details/ReportFixedAmountDetails.js">
// src/components/reports/details/ReportFixedAmountDetails.js
import React from "react";
import { formatCurrency } from "../../../utils/calculationUtils";

const ReportFixedAmountDetails = ({ label, amount }) => {
  return (
    <div className="fixed-budget-details">
      <p><strong>{label}:</strong> {formatCurrency(amount)}</p>
    </div>
  );
};

export default React.memo(ReportFixedAmountDetails);
</file>

<file path="src/components/reports/details/ReportLaborDetails.js">
// src/components/reports/details/ReportLaborDetails.js
import React from "react";
import { formatNumber, formatCurrency } from "../../../utils/calculationUtils";

const ReportLaborDetails = ({ laborCalcs }) => {
  if (!laborCalcs) return null;

  return (
    <div className="labor-details">
      <h5>Mano de obra</h5>
      <p>Oficial: {formatNumber(laborCalcs.officialHours)} h - {formatCurrency(laborCalcs.officialCost)}</p>
      <p>Pe√≥n: {formatNumber(laborCalcs.workerHours)} h - {formatCurrency(laborCalcs.workerCost)}</p>
      <p>Total mano de obra: {formatCurrency(laborCalcs.totalLaborCost)}</p>
    </div>
  );
};

export default React.memo(ReportLaborDetails);
</file>

<file path="src/components/reports/details/ReportMaterialsDetails.js">
// src/components/reports/details/ReportMaterialsDetails.js
import React from "react";
import { formatCurrency } from "../../../utils/calculationUtils";
import { Link } from "@react-pdf/renderer"; // Importar Link si se usa directamente aqu√≠

// Helper interno para renderizar materiales
const renderMaterialsList = (materials = []) => {
  if (!materials || materials.length === 0) {
    return <p>No hay materiales registrados.</p>;
  }

  return (
    <div className="materials-list">
      {materials.map((material, index) => (
        <p key={material.id || index}>
          {material.description} - {formatCurrency(material.cost)} (
          {/* Nota: Link de @react-pdf/renderer no funcionar√° directamente en HTML.
              Si esto se renderiza en web, necesitar√≠as un <a> normal.
              Asumiendo que esto es para la web por ahora. */}
          <a href={material.invoiceUrl} target="_blank" rel="noopener noreferrer">
            Ver factura
          </a>
          )
        </p>
      ))}
    </div>
  );
};

const ReportMaterialsDetails = ({ materials, materialsCalcs }) => {
  if (!materialsCalcs) return null;

  return (
    <div className="materials-details">
      <h5>Materiales</h5>
      {renderMaterialsList(materials)}
      <p>Total materiales: {formatCurrency(materialsCalcs.totalMaterialsCost)}</p>
    </div>
  );
};

export default React.memo(ReportMaterialsDetails);
</file>

<file path="src/components/reports/MaterialsEditor.js">
import React, { useState } from "react";
import { formatCurrency } from "../../utils/formatters";

const MaterialsEditor = ({ 
  materials, 
  onMaterialsChange, 
  projectId, 
  reportDate,
  uploadFile 
}) => {
  const [uploading, setUploading] = useState(false);
  const [uploadError, setUploadError] = useState(null);

  const handleAddMaterial = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const description = prompt("Descripci√≥n del material:") || "";
    const costText = prompt("Coste del material (‚Ç¨):") || "0";
    const cost = parseFloat(costText) || 0;

    if (!description || isNaN(cost) || cost < 0) {
      alert("Por favor, completa la descripci√≥n y un coste v√°lido (num√©rico y positivo).");
      return;
    }

    try {
      setUploading(true);
      setUploadError(null);
      
      const url = await uploadFile(file, "invoices", `${projectId}_${reportDate}`);
      
      if (url) {
        const newMaterial = { id: Date.now(), description, cost, invoiceUrl: url };
        onMaterialsChange([...materials, newMaterial]);
      }
    } catch (err) {
      setUploadError(`Error al subir material: ${err.message}`);
    } finally {
      setUploading(false);
    }
  };

  const handleRemoveMaterial = (id) => {
    onMaterialsChange(materials.filter(m => m.id !== id));
  };

  return (
    <div className="materials-editor">
      <h4>Materiales</h4>
      
      {uploadError && <p className="error-message">{uploadError}</p>}
      
      <div className="materials-list">
        {materials.map(material => (
          <div key={material.id} className="material-item">
            <div className="material-info">
              <input
                type="text"
                value={material.description || ""}
                onChange={(e) => {
                  const updatedMaterials = materials.map(m => 
                    m.id === material.id 
                      ? { ...m, description: e.target.value } 
                      : m
                  );
                  onMaterialsChange(updatedMaterials);
                }}
                placeholder="Descripci√≥n"
              />
              
              <input
                type="number"
                value={material.cost || 0}
                onChange={(e) => {
                  const updatedMaterials = materials.map(m => 
                    m.id === material.id 
                      ? { ...m, cost: parseFloat(e.target.value) || 0 } 
                      : m
                  );
                  onMaterialsChange(updatedMaterials);
                }}
                min="0"
                step="0.01"
                placeholder="Coste (‚Ç¨)"
              />
            </div>
            
            <div className="material-actions">
              <a 
                href={material.invoiceUrl} 
                target="_blank" 
                rel="noopener noreferrer"
                className="invoice-link"
              >
                Ver factura
              </a>
              
              <button 
                type="button" 
                onClick={() => handleRemoveMaterial(material.id)}
                className="remove-button"
              >
                Eliminar
              </button>
            </div>
          </div>
        ))}
      </div>
      
      <div className="upload-container">
        <input 
          type="file" 
          accept=".pdf" 
          onChange={handleAddMaterial} 
          disabled={uploading} 
          id="material-upload"
          className="file-input"
        />
        <label htmlFor="material-upload" className="upload-label">
          {uploading ? "Subiendo..." : "A√±adir material con factura"}
        </label>
      </div>
    </div>
  );
};

export default React.memo(MaterialsEditor);
</file>

<file path="src/components/reports/PhotosEditor.js">
import React, { useState } from "react";

const PhotosEditor = ({ 
  photos, 
  onPhotosChange, 
  projectId, 
  reportDate,
  uploadFile 
}) => {
  const [uploading, setUploading] = useState(false);
  const [uploadError, setUploadError] = useState(null);

  const handleAddPhoto = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Verificar que sea una imagen
    if (!file.type.startsWith('image/')) {
      setUploadError("Por favor, selecciona un archivo de imagen v√°lido.");
      return;
    }

    try {
      setUploading(true);
      setUploadError(null);
      
      const url = await uploadFile(file, "photos", `${projectId}_${reportDate}`);
      
      if (url) {
        const newPhoto = { id: Date.now(), url };
        onPhotosChange([...photos, newPhoto]);
      }
    } catch (err) {
      setUploadError(`Error al subir foto: ${err.message}`);
    } finally {
      setUploading(false);
    }
  };

  const handleRemovePhoto = (id) => {
    onPhotosChange(photos.filter(p => p.id !== id));
  };

  return (
    <div className="photos-editor">
      <h4>Fotograf√≠as</h4>
      
      {uploadError && <p className="error-message">{uploadError}</p>}
      
      <div className="photos-container">
        {photos.map(photo => (
          <div key={photo.id} className="photo-container">
            <img 
              src={photo.url} 
              alt="Foto" 
              className="photo-thumbnail" 
            />
            <button 
              type="button" 
              onClick={() => handleRemovePhoto(photo.id)}
              className="remove-photo-button"
            >
              Eliminar
            </button>
          </div>
        ))}
      </div>
      
      <div className="upload-container">
        <input 
          type="file" 
          accept="image/*" 
          onChange={handleAddPhoto} 
          disabled={uploading} 
          id="photo-upload"
          className="file-input"
        />
        <label htmlFor="photo-upload" className="upload-label">
          {uploading ? "Subiendo..." : "A√±adir fotograf√≠a"}
        </label>
      </div>
    </div>
  );
};

export default React.memo(PhotosEditor);
</file>

<file path="src/components/reports/ReportDeleteModal.js">
import React from "react";

const ReportDeleteModal = ({ onConfirm, onCancel }) => {
  return (
    <div className="modal-overlay">
      <div className="modal">
        <h3>Confirmar eliminaci√≥n</h3>
        <p>¬øEst√°s seguro de que quieres eliminar este parte diario?</p>
        <p className="warning">Esta acci√≥n no se puede deshacer.</p>
        
        <div className="modal-actions">
          <button 
            onClick={onConfirm} 
            className="confirm-button"
          >
            S√≠, eliminar
          </button>
          <button 
            onClick={onCancel} 
            className="cancel-button"
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>
  );
};

export default React.memo(ReportDeleteModal);
</file>

<file path="src/components/reports/ReportsList.js">
import React from "react";
import ReportItem from "./ReportItem";

const ReportsList = ({ reports, projects, onEdit, onDelete }) => {
  if (reports.length === 0) {
    return <p>No hay partes que coincidan con los criterios de b√∫squeda.</p>;
  }

  return (
    <div className="reports-list">
      {reports.map((report) => (
        <ReportItem
          key={report.id}
          report={report}
          project={projects.find(p => p.id === report.projectId) || {}}
          onEdit={() => onEdit(report.id)}
          onDelete={() => onDelete(report.id)}
        />
      ))}
    </div>
  );
};

export default React.memo(ReportsList);
</file>

<file path="src/hooks/__tests__/useCalculationsService.test.js">
// src/hooks/__tests__/useCalculationsService.test.js
import { renderHook } from '@testing-library/react';
import { useCalculationsService } from '../useCalculationsService';

// Mock de los m√≥dulos de utilidades
jest.mock('../../utils/calculations/laborUtils', () => ({
  calculateLabor: jest.fn((labor, project) => ({
    officialHours: 5,
    workerHours: 5,
    officialCost: 100,
    workerCost: 80,
    totalLaborCost: 180
  }))
}));

jest.mock('../../utils/calculations/materialsUtils', () => ({
  calculateMaterials: jest.fn((materials) => ({
    totalMaterialsCost: 150,
    materialItems: materials
  }))
}));

jest.mock('../../utils/calculations/budgetUtils', () => ({
  calculateBudget: jest.fn((project, reports) => ({
    budgetAmount: 5000,
    invoicedTotal: 2000,
    remainingBudget: 3000,
    progressPercentage: 40,
    isOverBudget: false
  }))
}));

jest.mock('../../utils/calculations/extraWorkUtils', () => ({
  calculateExtraWork: jest.fn((reports, project) => ({
    totalExtraBudget: 800,
    totalExtraHours: 250,
    totalExtraMaterials: 100,
    totalExtraCost: 350,
    totalExtra: 1150,
    extraWorkCount: 2,
    extraWorkReports: []
  }))
}));

jest.mock('../../utils/calculations/reportSummaryUtils', () => ({
  calculateReportSummary: jest.fn((reports, projects, selectedProjectId) => ({
    totals: {
      totalLabor: 720,
      totalMaterials: 350,
      totalCost: 1070,
      totalInvoiced: 2500,
      totalHours: 18,
      totalIncome: 3220
    },
    byWeek: [],
    byProject: []
  }))
}));

describe('useCalculationsService', () => {
  // Obtener referencias a los mocks para usarlos en los tests
  const laborUtils = require('../../utils/calculations/laborUtils');
  const materialsUtils = require('../../utils/calculations/materialsUtils');

  // Limpiar mocks despu√©s de cada test
  afterEach(() => {
    jest.clearAllMocks();
  });

  // Verificar que el hook devuelve todas las funciones esperadas
  test('devuelve todas las funciones de c√°lculo esperadas', () => {
    const { result } = renderHook(() => useCalculationsService());
    expect(result.current).toBeInstanceOf(Object);
    expect(result.current).toHaveProperty('calculateLabor');
    expect(result.current).toHaveProperty('calculateMaterials');
    expect(result.current).toHaveProperty('calculateBudget');
    expect(result.current).toHaveProperty('calculateExtraWork');
    expect(result.current).toHaveProperty('calculateReportSummary');
    expect(result.current).toHaveProperty('calculateReportTotalCost');
    expect(result.current).toHaveProperty('calculateReportTotalIncome');
  });

  // Verificar que las funciones importadas son llamadas correctamente
  test('llama a la funci√≥n calculateLabor con los par√°metros correctos', () => {
    const { result } = renderHook(() => useCalculationsService());

    const labor = { officialEntry: '08:00', officialExit: '16:00' };
    const project = { officialPrice: 20, workerPrice: 16 };

    // Obtener una referencia a la funci√≥n mockeada antes de la llamada
    const { calculateLabor } = require('../../utils/calculations/laborUtils');

    // Verificar que la funci√≥n no ha sido llamada a√∫n
    expect(calculateLabor).not.toHaveBeenCalled();

    // Llamar a la funci√≥n
    result.current.calculateLabor(labor, project);
    // Verificar que la funci√≥n fue llamada exactamente una vez
    expect(calculateLabor).toHaveBeenCalledTimes(1);
    // Verificar que fue llamada con los par√°metros correctos
    expect(calculateLabor).toHaveBeenCalledWith(labor, project);
    // Verificar que no fue llamada con otros par√°metros
    expect(calculateLabor).not.toHaveBeenCalledWith({}, {});
  });

  test('llama a la funci√≥n calculateMaterials con los par√°metros correctos', () => {
    const { result } = renderHook(() => useCalculationsService());

    const materials = [{ id: 1, description: 'Material 1', cost: 100 }];

    // Obtener una referencia a la funci√≥n mockeada
    const { calculateMaterials } = require('../../utils/calculations/materialsUtils');
    expect(calculateMaterials).not.toHaveBeenCalled();

    // Llamar a la funci√≥n
    result.current.calculateMaterials(materials);

    // Verificaciones
    expect(calculateMaterials).toHaveBeenCalledTimes(1);
    expect(calculateMaterials).toHaveBeenCalledWith(materials);
    expect(calculateMaterials).not.toHaveBeenCalledWith([]);
  });

  test('llama a la funci√≥n calculateBudget con los par√°metros correctos', () => {
    const { result } = renderHook(() => useCalculationsService());

    const project = { id: 'project1', budgetAmount: 5000 };
    const reports = [{ id: 'report1', projectId: 'project1', invoicedAmount: 2000 }];

    // Obtener una referencia a la funci√≥n mockeada
    const { calculateBudget } = require('../../utils/calculations/budgetUtils');
    expect(calculateBudget).not.toHaveBeenCalled();

    // Llamar a la funci√≥n
    result.current.calculateBudget(project, reports);

    // Verificaciones
    expect(calculateBudget).toHaveBeenCalledTimes(1);
    expect(calculateBudget).toHaveBeenCalledWith(project, reports);

    // Verificar orden de argumentos
    const lastCall = calculateBudget.mock.calls[0];
    expect(lastCall[0]).toEqual(project);
    expect(lastCall[1]).toEqual(reports);
  });

  test('llama a la funci√≥n calculateExtraWork con los par√°metros correctos', () => {
    const { result } = renderHook(() => useCalculationsService());

    const reports = [{ id: 'report1', projectId: 'project1', isExtraWork: true }];
    const project = { id: 'project1' };

    // Obtener una referencia a la funci√≥n mockeada
    const { calculateExtraWork } = require('../../utils/calculations/extraWorkUtils');
    expect(calculateExtraWork).not.toHaveBeenCalled();

    // Llamar a la funci√≥n
    result.current.calculateExtraWork(reports, project);

    // Verificaciones
    expect(calculateExtraWork).toHaveBeenCalledTimes(1);
    expect(calculateExtraWork).toHaveBeenCalledWith(reports, project);

    // Inspeccionar la √∫ltima llamada para verificar argumentos
    const lastCall = calculateExtraWork.mock.lastCall;
    expect(lastCall[0]).toEqual(reports);
    expect(lastCall[1]).toEqual(project);
  });

  test('llama a la funci√≥n calculateReportSummary con los par√°metros correctos', () => {
    const { result } = renderHook(() => useCalculationsService());

    const reports = [{ id: 'report1' }];
    const projects = [{ id: 'project1' }];
    const selectedProjectId = 'project1';

    // Obtener una referencia a la funci√≥n mockeada
    const { calculateReportSummary } = require('../../utils/calculations/reportSummaryUtils');
    expect(calculateReportSummary).not.toHaveBeenCalled();

    // Llamar a la funci√≥n
    result.current.calculateReportSummary(reports, projects, selectedProjectId);

    // Verificaciones
    expect(calculateReportSummary).toHaveBeenCalledTimes(1);
    expect(calculateReportSummary).toHaveBeenCalledWith(reports, projects, selectedProjectId);

    // Verificar todos los argumentos de la √∫ltima llamada
    expect(calculateReportSummary.mock.calls[0]).toEqual([reports, projects, selectedProjectId]);
  });

  // Tests para las funciones propias del hook

  // calculateReportTotalCost para distintos tipos de reportes
  describe('calculateReportTotalCost', () => {
    it('calcula el coste para proyecto por horas', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: false,
        extraWorkType: 'hourly',
        extraBudgetAmount: 0
      };
      const project = { type: 'hourly', officialPrice: 20, workerPrice: 15 };

      // Usar mockReturnValue para los resultados de calculateLabor y calculateMaterials
      laborUtils.calculateLabor.mockReturnValue({ totalLaborCost: 260 });
      materialsUtils.calculateMaterials.mockReturnValue({ totalMaterialsCost: 30 });

      const { result } = renderHook(() => useCalculationsService());
      const cost = result.current.calculateReportTotalCost(report, project);

      expect(cost).toBe(290); // Suma de totalLaborCost y totalMaterialsCost
      expect(laborUtils.calculateLabor).toHaveBeenCalledWith(report.labor, project);
      expect(materialsUtils.calculateMaterials).toHaveBeenCalledWith(report.materials);
    });

    it('calcula el coste para trabajo extra por horas', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [], // Incluir materials
        isExtraWork: true,
        extraWorkType: 'hourly',
        extraBudgetAmount: 0 // Incluir extraBudgetAmount
      };
      const project = { type: 'fixed' }; // El tipo de proyecto es irrelevante para el coste total en este caso

      // Usar mockReturnValue para los resultados de calculateLabor y calculateMaterials
      laborUtils.calculateLabor.mockReturnValue({ totalLaborCost: 260 });
      materialsUtils.calculateMaterials.mockReturnValue({ totalMaterialsCost: 0 });

      const { result } = renderHook(() => useCalculationsService());
      const cost = result.current.calculateReportTotalCost(report, project);

      expect(cost).toBe(260); // Solo coste de labor
      expect(laborUtils.calculateLabor).toHaveBeenCalledWith(report.labor, project);
      expect(materialsUtils.calculateMaterials).toHaveBeenCalledWith(report.materials);
    });

    it('calcula el coste para trabajo extra con presupuesto adicional', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: true,
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1000
      };
      const project = { type: 'fixed' };  // Tipo de proyecto no importa en este caso
      const { result } = renderHook(() => useCalculationsService());
      const cost = result.current.calculateReportTotalCost(report, project);
      expect(cost).toBe(1000);  // Solo el importe adicional
    });


    it('calculateReportTotalCost calcula el coste para proyecto de presupuesto cerrado', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: false,
        extraWorkType: 'hourly',
        extraBudgetAmount: 0,
        invoicedAmount: 500
       };
      const project = { type: 'fixed' }; // Importante: type es 'fixed'
      const { result } = renderHook(() => useCalculationsService());
      const cost = result.current.calculateReportTotalCost(report, project);
      expect(cost).toBe(500);  // Solo el importe facturado
    });
  });

  // Tests para calculateReportTotalIncome
  describe('calculateReportTotalIncome', () => {
    it('calcula los ingresos para proyecto por horas', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' }, // Incluir labor
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: false,
        extraWorkType: 'hourly', // Incluir extraWorkType
        extraBudgetAmount: 0 // Incluir extraBudgetAmount
      };
      const project = { type: 'hourly', officialPrice: 20, workerPrice: 15 };
      laborUtils.calculateLabor.mockReturnValue({ totalLaborCost: 260 });

      const { result } = renderHook(() => useCalculationsService());
      const income = result.current.calculateReportTotalIncome(report, project);
      expect(income).toBe(260); // Ingresos = coste de la mano de obra
      expect(laborUtils.calculateLabor).toHaveBeenCalledWith(report.labor, project);
    });

    it('calcula los ingresos para trabajo extra por horas', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' }, // Incluir labor
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: true,
        extraWorkType: 'hourly',
        extraBudgetAmount: 0 // Incluir extraBudgetAmount
      };
      const project = { type: 'fixed', officialPrice: 20, workerPrice: 15 };
      laborUtils.calculateLabor.mockReturnValue({ totalLaborCost: 260 });
      const { result } = renderHook(() => useCalculationsService());
      const income = result.current.calculateReportTotalIncome(report, project);
      expect(income).toBe(260);  // Ingresos = coste de la mano de obra
      expect(laborUtils.calculateLabor).toHaveBeenCalledWith(report.labor, project);
    });

    it('calcula los ingresos para trabajo extra con presupuesto adicional', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: true,
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1000
      };
      const project = { type: 'fixed' }; // El tipo de proyecto no importa
      const { result } = renderHook(() => useCalculationsService());
      const income = result.current.calculateReportTotalIncome(report, project);
      expect(income).toBe(1000); // Ingresos = importe adicional
    });

    it('calcula los ingresos para proyecto de presupuesto cerrado', () => {
      const report = {
        labor: { officialEntry: '09:00', officialExit: '17:00', workerEntry: '08:00', workerExit: '16:00' },
        materials: [{ cost: 10 }, { cost: 20 }],
        isExtraWork: false,
        extraWorkType: 'hourly',
        extraBudgetAmount: 0,
        invoicedAmount: 500
       };
      const project = { type: 'fixed' }; // Importante: type es 'fixed'
      const { result } = renderHook(() => useCalculationsService());
      const income = result.current.calculateReportTotalIncome(report, project);
      expect(income).toBe(500); // Ingresos = importe facturado
    });
  });
});
</file>

<file path="src/hooks/__tests__/useFormValidation.test.js">
// src/hooks/useFormValidation.js

import { useState, useCallback, useEffect } from 'react';
import { validateForm } from '../utils/validationSchemas';

const useFormValidation = (initialValues, validationSchema, contextData = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touchedFields, setTouchedFields] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isValid, setIsValid] = useState(false);

  // Validar el formulario completo
  const validateFormData = useCallback(() => {
  // Ensure we handle potential undefined returns
  const result = validateForm(values, validationSchema, contextData) || { errors: {}, isValid: false };
  setErrors(result.errors || {});
  setIsValid(result.isValid || false);
  return result;
}, [values, validationSchema, contextData]);

  // Efecto para validar cuando cambian los valores
  useEffect(() => {
    validateFormData();
  }, [values]); // Corrected dependency array

  // Manejar cambios en campos
  const handleChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;
    
    // Manejar diferentes tipos de input
    const inputValue = type === 'checkbox' ? checked : value;
    
    setValues(prevValues => {
      // Manejar campos anidados (e.g., 'labor.officialEntry')
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        
        // Navegar hasta el pen√∫ltimo nivel
        for (let i = 0; i < parts.length - 1; i++) {
          // Crear objeto si no existe
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        
        // Asignar valor al √∫ltimo nivel
        current[parts[parts.length - 1]] = inputValue;
        return newValues;
      }
      
      // Caso simple: campo no anidado
      return { ...prevValues, [name]: inputValue };
    });
    
    // Marcar el campo como tocado
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  // Manejar eventos blur para validaci√≥n
  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  // Verificar si un campo tiene error y ha sido tocado
  const hasError = useCallback((fieldName) => {
  return Boolean(touchedFields[fieldName] && errors[fieldName]);
}, [touchedFields, errors]);

  // Obtener el mensaje de error para un campo
  const getError = useCallback((fieldName) => {
    return hasError(fieldName) ? errors[fieldName] : null;
  }, [hasError, errors]);

  // Manejar env√≠o del formulario
  const handleSubmit = useCallback((onSubmit) => async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    // Marcar todos los campos como tocados para mostrar todos los errores
    const allFields = Object.keys(validationSchema).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouchedFields(allFields);
    
    // Validar antes de enviar
    const validationResult = validateFormData();
    
    if (validationResult.isValid) {
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Error en env√≠o del formulario:', error);
      }
    }
    
    setIsSubmitting(false);
  }, [values, validateFormData, validationSchema]);

  // Resetear el formulario
  const resetForm = useCallback((newValues = initialValues) => {
    setValues(newValues);
    setErrors({});
    setTouchedFields({});
    setIsSubmitting(false);
  }, [initialValues]);

  // Actualizar un valor espec√≠fico program√°ticamente
  const setValue = useCallback((name, value) => {
    setValues(prevValues => {
      // Manejar campos anidados
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        
        current[parts.length - 1]] = value;
        return newValues;
      }
      
      return { ...prevValues, [name]: value };
    });
  }, []);

  return {
    values,
    errors,
    touchedFields,
    isSubmitting,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setValue,
    hasError,
    getError,
  };
};

export default useFormValidation;
</file>

<file path="src/hooks/reports/_useReportSummary.js">
import { useMemo } from "react";

/**
 * Hook personalizado para calcular res√∫menes y estad√≠sticas de reportes
 * @param {Array} reports - Lista de reportes
 * @param {Array} projects - Lista de proyectos
 * @param {string} selectedProjectId - ID del proyecto seleccionado (opcional)
 * @returns {Object} - Objeto con c√°lculos y estad√≠sticas
 */
export const useReportSummary = (reports = [], projects = [], selectedProjectId = "") => {
  // Filtrar por proyecto si es necesario
  const filteredReports = useMemo(() => {
    if (!selectedProjectId) return reports;
    return reports.filter(report => report.projectId === selectedProjectId);
  }, [reports, selectedProjectId]);

  // Obtener tipo de proyecto
  const projectType = useMemo(() => {
    if (!selectedProjectId) return null;
    const project = projects.find(p => p.id === selectedProjectId);
    return project?.type || null;
  }, [projects, selectedProjectId]);

  // Calcular totales generales
  const totals = useMemo(() => {
    let totalLabor = 0;
    let totalMaterials = 0;
    let totalCost = 0;
    let totalInvoiced = 0;
    let totalHours = 0;

    filteredReports.forEach(report => {
      // Costos de mano de obra (proyectos por hora)
      if (report.labor) {
        totalLabor += report.labor.totalLaborCost || 0;
        totalHours += (report.labor.officialHours || 0) + (report.labor.workerHours || 0);
      }
      
      // Costos de materiales
      totalMaterials += report.totalMaterialsCost || 0;
      
      // Coste total
      if (report.totalCost) {
        totalCost += report.totalCost;
      } else if (report.labor) {
        totalCost += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
      }

      // Para proyectos de presupuesto cerrado
      if (report.invoicedAmount) {
        totalInvoiced += report.invoicedAmount;
      }
    });

    return {
      totalLabor,
      totalMaterials,
      totalCost,
      totalInvoiced,
      totalHours
    };
  }, [filteredReports]);

  // Calcular resumen por semanas
  const weeklySummary = useMemo(() => {
    if (filteredReports.length === 0) return [];

    const weekMap = {};
    
    filteredReports.forEach(report => {
      const weekKey = `${report.weekNumber}-${new Date(report.reportDate).getFullYear()}`;
      
      if (!weekMap[weekKey]) {
        weekMap[weekKey] = {
          weekNumber: report.weekNumber,
          year: new Date(report.reportDate).getFullYear(),
          label: `Semana ${report.weekNumber}/${new Date(report.reportDate).getFullYear()}`,
          laborCost: 0,
          materialsCost: 0,
          totalCost: 0,
          invoicedAmount: 0,
          reports: 0
        };
      }
      
      // Incrementar contadores
      weekMap[weekKey].reports += 1;
      
      // Para proyectos por hora
      if (report.labor) {
        weekMap[weekKey].laborCost += report.labor.totalLaborCost || 0;
      }
      
      weekMap[weekKey].materialsCost += report.totalMaterialsCost || 0;
      
      // Coste total
      if (report.totalCost) {
        weekMap[weekKey].totalCost += report.totalCost;
      } else if (report.labor) {
        weekMap[weekKey].totalCost += (report.labor.totalLaborCost || 0) + (report.totalMaterialsCost || 0);
      }
      
      // Para proyectos de presupuesto cerrado
      if (report.invoicedAmount) {
        weekMap[weekKey].invoicedAmount += report.invoicedAmount;
      }
    });

    // Convertir a array y ordenar por semana/a√±o
    return Object.values(weekMap).sort((a, b) => {
      if (a.year !== b.year) return a.year - b.year;
      return a.weekNumber - b.weekNumber;
    });
  }, [filteredReports]);

  // Calcular presupuesto restante para proyectos de presupuesto cerrado
  const budgetSummary = useMemo(() => {
    if (projectType !== 'fixed' || !selectedProjectId) return null;
    
    const project = projects.find(p => p.id === selectedProjectId);
    if (!project) return null;
    
    const budgetAmount = project.budgetAmount || 0;
    const invoicedTotal = totals.totalInvoiced;
    const remainingBudget = budgetAmount - invoicedTotal;
    const progressPercentage = budgetAmount > 0 ? (invoicedTotal / budgetAmount) * 100 : 0;
    
    return {
      budgetAmount,
      invoicedTotal,
      remainingBudget,
      progressPercentage: Math.min(progressPercentage, 100), // Limitar a 100%
      isOverBudget: remainingBudget < 0
    };
  }, [projectType, selectedProjectId, projects, totals.totalInvoiced]);

  return {
    totals,
    weeklySummary,
    budgetSummary,
    projectType,
    reportCount: filteredReports.length
  };
};

export default useReportSummary;
</file>

<file path="src/hooks/reports/useReportSummary.js">
// src/hooks/reports/useReportSummary.js
import { useMemo } from "react";
// Importamos la √öNICA funci√≥n de c√°lculo que debe existir
import { calculateReportSummary } from "../../utils/calculations/reportSummaryUtils";

/**
 * Hook personalizado que act√∫a como un simple 'wrapper' memoizado
 * para la funci√≥n de c√°lculo de resumen principal.
 * 
 * @param {Array} reports - La lista completa de reportes a analizar.
 * @param {Array} projects - La lista de proyectos.
 * @param {string} selectedProjectId - El ID del proyecto para filtrar (o "" para todos).
 * @returns {Object} - El objeto completo de resultados de calculateReportSummary, principalmente `{ totals, byWeek, byProject }`.
 */
export const useReportSummary = (reports = [], projects = [], selectedProjectId = "") => {
  // useMemo asegura que el c√°lculo complejo solo se ejecuta si los datos de entrada cambian.
  const summary = useMemo(() => {
    // Llama a la funci√≥n de c√°lculo maestra y robusta.
    // Esta es la √∫nica fuente de verdad para los c√°lculos del resumen.
    return calculateReportSummary(reports, projects, selectedProjectId);
  }, [reports, projects, selectedProjectId]);

  return summary;
};

export default useReportSummary;
</file>

<file path="src/hooks/useCalculationsService.js">
// src/hooks/useCalculationsService.js - Versi√≥n refactorizada
import { useMemo } from 'react';

// Importar funciones de utilidad puras
import { calculateLabor } from '../utils/calculations/laborUtils';
import { calculateMaterials } from '../utils/calculations/materialsUtils';
import { calculateBudget } from '../utils/calculations/budgetUtils';
import { calculateExtraWork } from '../utils/calculations/extraWorkUtils';
import { calculateReportSummary } from '../utils/calculations/reportSummaryUtils';

/**
 * Hook principal que centraliza todos los servicios de c√°lculo
 * 
 * Este hook es el punto de entrada √∫nico para todos los c√°lculos de la aplicaci√≥n.
 * Proporciona una API unificada para acceder a todos los c√°lculos necesarios,
 * eliminando la duplicaci√≥n de l√≥gica y garantizando consistencia.
 * 
 * @returns {Object} API de servicios de c√°lculo
 */
export const useCalculationsService = () => {
  // Usar useMemo para garantizar la estabilidad de referencia del servicio
  const calculationService = useMemo(() => {
    /**
     * Calcula el coste total de un reporte
     * 
     * @param {Object} report - Datos del reporte
     * @param {Object} project - Datos del proyecto
     * @returns {number} Coste total calculado
     */
    const calculateReportTotalCost = (report, project) => {
      if (!report || !project) return 0;

      if (project.type === 'hourly' || (report.isExtraWork && report.extraWorkType === 'hourly')) {
        const laborResult = calculateLabor(report.labor, project);
        const materialsResult = calculateMaterials(report.materials);
        
        return laborResult.totalLaborCost + materialsResult.totalMaterialsCost;
      } else if (report.isExtraWork && report.extraWorkType === 'additional_budget') {
        return report.extraBudgetAmount || 0;
      } else {
        return report.invoicedAmount || 0;
      }
    };

    /**
     * Calcula los ingresos totales de un reporte
     * 
     * @param {Object} report - Datos del reporte
     * @param {Object} project - Datos del proyecto
     * @returns {number} Ingresos totales calculados
     */
    const calculateReportTotalIncome = (report, project) => {
      if (!report || !project) return 0;

      // Para proyectos por horas, los ingresos son la mano de obra
      if (project.type === 'hourly') {
        const laborResult = calculateLabor(report.labor, project);
        return laborResult.totalLaborCost;
      } 
      // Para trabajos extra por horas, tambi√©n son la mano de obra
      else if (report.isExtraWork && report.extraWorkType === 'hourly') {
        const laborResult = calculateLabor(report.labor, project);
        return laborResult.totalLaborCost;
      } 
      // Para trabajos extra con presupuesto adicional, es el importe adicional
      else if (report.isExtraWork && report.extraWorkType === 'additional_budget') {
        return report.extraBudgetAmount || 0;
      } 
      // Para proyectos de presupuesto cerrado, son los importes facturados
      else {
        return report.invoicedAmount || 0;
      }
    };

    // Devolver la API completa del servicio de c√°lculos
    return {
      // Exponer directamente las funciones de utilidad importadas
      calculateLabor,
      calculateMaterials,
      calculateBudget,
      calculateExtraWork,
      calculateReportSummary,
      
      // Funciones adicionales espec√≠ficas de este servicio
      calculateReportTotalCost,
      calculateReportTotalIncome
    };
  }, []);

  return calculationService;
};
</file>

<file path="src/hooks/useLabor.js">
import { useMemo } from "react";

export const useLabor = (labor, project) => {
  return useMemo(() => {
    const { officialEntry, officialExit, workerEntry, workerExit } = labor;
    const officialStart = officialEntry ? new Date(`2025-01-01T${officialEntry}`) : null;
    const officialEnd = officialExit ? new Date(`2025-01-01T${officialExit}`) : null;
    const workerStart = workerEntry ? new Date(`2025-01-01T${workerEntry}`) : null;
    const workerEnd = workerExit ? new Date(`2025-01-01T${workerExit}`) : null;

    if (officialStart && officialEnd && officialEnd < officialStart) {
      officialEnd.setDate(officialEnd.getDate() + 1);
    }
    if (workerStart && workerEnd && workerEnd < workerStart) {
      workerEnd.setDate(workerEnd.getDate() + 1);
    }

    const officialHours = officialStart && officialEnd ? (officialEnd - officialStart) / 3600000 : 0;
    const workerHours = workerStart && workerEnd ? (workerEnd - workerStart) / 3600000 : 0;
    const officialCost = officialHours * (project?.officialPrice || 0);
    const workerCost = workerHours * (project?.workerPrice || 0);

    return {
      officialHours,
      workerHours,
      officialCost,
      workerCost,
      totalLaborCost: officialCost + workerCost,
    };
  }, [labor, project]);
};
</file>

<file path="src/hooks/useLocalStorage.js">
// src/hooks/useLocalStorage.js - Hook para persistir datos en localStorage
import { useState, useEffect } from 'react';

/**
 * Hook personalizado para persistir datos en localStorage
 * @param {string} key - Clave para almacenar en localStorage
 * @param {any} initialValue - Valor inicial si no existe la clave
 * @returns {Array} - [storedValue, setValue] similar a useState
 */
export const useLocalStorage = (key, initialValue) => {
  // Estado para almacenar el valor
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // Obtener del localStorage por la clave
      const item = window.localStorage.getItem(key);
      // Analizar el JSON almacenado o devolver initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // Si hay error al leer localStorage, devolver initialValue
      console.error(`Error al leer '${key}' de localStorage:`, error);
      return initialValue;
    }
  });

  // Funci√≥n para actualizar localStorage y el estado
  const setValue = (value) => {
    try {
      // Permitir que value sea una funci√≥n como en useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      
      // Guardar en el estado
      setStoredValue(valueToStore);
      
      // Guardar en localStorage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error al guardar '${key}' en localStorage:`, error);
    }
  };

  // Efecto para actualizar localStorage si la clave cambia
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.error(`Error al sincronizar '${key}' con localStorage:`, error);
    }
  }, [key, storedValue]);

  return [storedValue, setValue];
};

export default useLocalStorage;
</file>

<file path="src/hooks/useQueryUser.js">
// src/hooks/useQueryUser.js
import { useQuery } from '@tanstack/react-query';
import { collection, getDocs } from 'firebase/firestore';
import { db } from '../firebase';

/**
 * Hook para consultar usuarios desde Firestore
 * @returns {Object} Objeto con datos de usuarios, estado de carga y error
 */
export const useQueryUser = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      try {
        const querySnapshot = await getDocs(collection(db, 'users'));
        return querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (error) {
        console.error("Error al consultar usuarios:", error);
        return []; // Devolver array vac√≠o en caso de error
      }
    },
    // No refetch autom√°ticamente, los usuarios no suelen cambiar con frecuencia
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000, // 5 minutos
  });
};

export default useQueryUser;
</file>

<file path="src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="src/reportWebVitals.js">
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="src/tests/examples/asyncTestExample.test.js">
// Este archivo muestra c√≥mo testear operaciones as√≠ncronas correctamente

// Mock de una funci√≥n as√≠ncrona (similar a una llamada a Firestore)
const mockFetchData = jest.fn(async () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        id: 'project1',
        client: 'Cliente Test',
        budgetAmount: 5000
      });
    }, 100);
  });
});

// Funci√≥n que usa la operaci√≥n as√≠ncrona
const getProjectDetails = async (projectId) => {
  try {
    const data = await mockFetchData(projectId);
    return data;
  } catch (error) {
    throw new Error(`Error al obtener datos: ${error.message}`);
  }
};

// Tests para funciones as√≠ncronas
describe('Ejemplo de Tests As√≠ncronos', () => {
  // Resetear mocks despu√©s de cada test
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  // M√©todo 1: Usando async/await
  test('m√©todo 1: async/await para operaciones as√≠ncronas', async () => {
    // Configurar mock para este test espec√≠fico
    mockFetchData.mockResolvedValueOnce({
      id: 'project1',
      client: 'Cliente Espec√≠fico',
      budgetAmount: 10000
    });
    
    // Llamar a la funci√≥n as√≠ncrona
    const result = await getProjectDetails('project1');
    
    // Verificar resultado
    expect(result).toEqual({
      id: 'project1',
      client: 'Cliente Espec√≠fico',
      budgetAmount: 10000
    });
    
    // Verificar que la funci√≥n mock fue llamada
    expect(mockFetchData).toHaveBeenCalledTimes(1);
    expect(mockFetchData).toHaveBeenCalledWith('project1');
  });
  
  // M√©todo 2: Usando then/catch con done callback (estilo antiguo)
  test('m√©todo 2: then/catch con done callback', (done) => {
    mockFetchData.mockResolvedValueOnce({
      id: 'project2',
      client: 'Otro Cliente',
      budgetAmount: 7500
    });
    
    getProjectDetails('project2')
      .then(result => {
        try {
          expect(result).toEqual({
            id: 'project2',
            client: 'Otro Cliente',
            budgetAmount: 7500
          });
          expect(mockFetchData).toHaveBeenCalledWith('project2');
          done(); // Importante: indicar que el test ha finalizado
        } catch (error) {
          done(error); // Si hay un error en las aserciones, pasarlo a done
        }
      })
      .catch(error => {
        done(error); // Si hay un error en la promesa, pasarlo a done
      });
  });
  
  // M√©todo 3: Usando resolves/rejects (muy claro y conciso)
  test('m√©todo 3: expect con resolves', async () => {
    mockFetchData.mockResolvedValueOnce({
      id: 'project3',
      client: 'Tercer Cliente',
      budgetAmount: 3000
    });
    
    // Usar resolves para esperar que la promesa se resuelva y cumplir las condiciones
    await expect(getProjectDetails('project3')).resolves.toEqual({
      id: 'project3',
      client: 'Tercer Cliente',
      budgetAmount: 3000
    });
  });
  
  // Test para casos de error
  test('maneja correctamente los errores', async () => {
    // Configurar mock para que rechace la promesa
    mockFetchData.mockRejectedValueOnce(new Error('Error en la base de datos'));
    
    // Comprobar que la funci√≥n propaga el error correctamente
    await expect(getProjectDetails('error-id')).rejects.toThrow('Error al obtener datos');
    
    // Verificar que la funci√≥n mock fue llamada antes de fallar
    expect(mockFetchData).toHaveBeenCalledTimes(1);
    expect(mockFetchData).toHaveBeenCalledWith('error-id');
  });
});
</file>

<file path="src/tests/integration/calculationsIntegration.test.js">
import { renderHook } from '@testing-library/react';
import { useCalculationsService } from '../../hooks/useCalculationsService';

// Nota: Aqu√≠ usamos las implementaciones reales, no los mocks
jest.unmock('../../utils/calculations/laborUtils');
jest.unmock('../../utils/calculations/materialsUtils');
jest.unmock('../../utils/calculations/budgetUtils');
jest.unmock('../../utils/calculations/extraWorkUtils');
jest.unmock('../../utils/calculations/reportSummaryUtils');

describe('Tests de Integraci√≥n - C√°lculos', () => {
  /**
   * Escenario 1: Proyecto por horas con varios reportes
   * - Calcular costes de cada reporte individual
   * - Calcular resumen general de todos los reportes
   */
  test('Escenario 1: Proyecto por horas con varios reportes', () => {
    const { result } = renderHook(() => useCalculationsService());

    // Datos del proyecto
    const project = {
      id: 'proyecto-hora',
      type: 'hourly',
      officialPrice: 25,
      workerPrice: 15,
      client: 'Cliente de prueba'
    };

    // Reportes de trabajo
    const reports = [
      {
        id: 'report1',
        projectId: 'proyecto-hora',
        reportDate: '2023-10-15',
        weekNumber: 41,
        labor: {
          officialEntry: '08:00',
          officialExit: '14:00',  // 6 horas
          workerEntry: '08:00',
          workerExit: '14:00'     // 6 horas
        },
        materials: [
          { id: 'mat1', description: 'Material 1', cost: 50 },
          { id: 'mat2', description: 'Material 2', cost: 75 }
        ]
      },
      {
        id: 'report2',
        projectId: 'proyecto-hora',
        reportDate: '2023-10-16',
        weekNumber: 42,
        labor: {
          officialEntry: '09:00',
          officialExit: '17:00',  // 8 horas
          workerEntry: '09:00',
          workerExit: '17:00'     // 8 horas
        },
        materials: [
          { id: 'mat3', description: 'Material 3', cost: 120 }
        ]
      }
    ];

    // Calcular informaci√≥n para cada reporte
    const report1Labor = result.current.calculateLabor(reports[0].labor, project);
    const report1Materials = result.current.calculateMaterials(reports[0].materials);
    const report1Cost = result.current.calculateReportTotalCost(reports[0], project);
    const report1Income = result.current.calculateReportTotalIncome(reports[0], project);

    const report2Labor = result.current.calculateLabor(reports[1].labor, project);
    const report2Materials = result.current.calculateMaterials(reports[1].materials);
    const report2Cost = result.current.calculateReportTotalCost(reports[1], project);
    const report2Income = result.current.calculateReportTotalIncome(reports[1], project);

    // Calculamos valores esperados
    const expectedReport1OfficialCost = 6 * 25; // 150
    const expectedReport1WorkerCost = 6 * 15;  // 90
    const expectedReport1LaborCost = 150 + 90; // 240
    const expectedReport1MaterialsCost = 50 + 75; // 125
    const expectedReport1TotalCost = 240 + 125; // 365

    const expectedReport2OfficialCost = 8 * 25; // 200
    const expectedReport2WorkerCost = 8 * 15;  // 120
    const expectedReport2LaborCost = 200 + 120; // 320
    const expectedReport2MaterialsCost = 120;
    const expectedReport2TotalCost = 320 + 120; // 440

    // Verificar c√°lculos de reportes individuales
    expect(report1Labor.officialHours).toBe(6);
    expect(report1Labor.workerHours).toBe(6);
    expect(report1Labor.officialCost).toBe(expectedReport1OfficialCost);
    expect(report1Labor.workerCost).toBe(expectedReport1WorkerCost);
    expect(report1Labor.totalLaborCost).toBe(expectedReport1LaborCost);

    expect(report1Materials.totalMaterialsCost).toBe(expectedReport1MaterialsCost);
    expect(report1Cost).toBe(expectedReport1TotalCost);
    expect(report1Income).toBe(expectedReport1LaborCost); // En hourly, el ingreso es la mano de obra

    expect(report2Labor.officialHours).toBe(8);
    expect(report2Labor.workerHours).toBe(8);
    expect(report2Labor.totalLaborCost).toBe(expectedReport2LaborCost);

    expect(report2Materials.totalMaterialsCost).toBe(expectedReport2MaterialsCost);
    expect(report2Cost).toBe(expectedReport2TotalCost);
    expect(report2Income).toBe(expectedReport2LaborCost);

    // Ahora calculamos y verificamos el resumen global
    // Actualizamos los reportes con los valores calculados para que reportSummary pueda usarlos
    const enrichedReports = [
      {
        ...reports[0],
        labor: { ...reports[0].labor, ...report1Labor },
        totalMaterialsCost: report1Materials.totalMaterialsCost,
        totalCost: report1Cost
      },
      {
        ...reports[1],
        labor: { ...reports[1].labor, ...report2Labor },
        totalMaterialsCost: report2Materials.totalMaterialsCost,
        totalCost: report2Cost
      }
    ];

    const summary = result.current.calculateReportSummary(enrichedReports, [project]);

    // Verificar totales del resumen
    const expectedTotalLabor = expectedReport1LaborCost + expectedReport2LaborCost; // 240 + 320 = 560
    const expectedTotalMaterials = expectedReport1MaterialsCost + expectedReport2MaterialsCost; // 125 + 120 = 245
    const expectedTotalCost = expectedReport1TotalCost + expectedReport2TotalCost; // 365 + 440 = 805
    const expectedTotalHours = (6 + 6) + (8 + 8); // 28

    expect(summary.totals.totalLabor).toBe(expectedTotalLabor);
    expect(summary.totals.totalMaterials).toBe(expectedTotalMaterials);
    expect(summary.totals.totalCost).toBe(expectedTotalCost);
    expect(summary.totals.totalHours).toBe(expectedTotalHours);
    expect(summary.totals.totalIncome).toBe(expectedTotalLabor); // En hourly, el ingreso es la mano de obra

    // Verificar agrupaci√≥n por semana
    expect(summary.byWeek).toHaveLength(2); // Dos semanas diferentes

    const week41 = summary.byWeek.find(w => w.weekNumber === 41);
    const week42 = summary.byWeek.find(w => w.weekNumber === 42);

    expect(week41.laborCost).toBe(expectedReport1LaborCost);
    expect(week41.materialsCost).toBe(expectedReport1MaterialsCost);

    expect(week42.laborCost).toBe(expectedReport2LaborCost);
    expect(week42.materialsCost).toBe(expectedReport2MaterialsCost);

    // Verificar agrupaci√≥n por proyecto
    expect(summary.byProject).toHaveLength(1); // Solo un proyecto
    expect(summary.byProject[0].projectId).toBe('proyecto-hora');
    expect(summary.byProject[0].laborCost).toBe(expectedTotalLabor);
    expect(summary.byProject[0].materialsCost).toBe(expectedTotalMaterials);
  });

  /**
   * Escenario 2: Proyecto de presupuesto cerrado con trabajos extra
   * - Calcular importes facturados normales
   * - Calcular importes de trabajos extra (presupuesto adicional y por horas)
   * - Calcular resumen general
   */
  // src/tests/integration/calculationsIntegration.test.js
// ... (rest of the file) ...

  test('Escenario 2: Proyecto de presupuesto cerrado con trabajos extra', () => {
    const { result } = renderHook(() => useCalculationsService());

    // Datos del proyecto
    const project = {
      id: 'proyecto-cerrado',
      type: 'fixed',
      budgetAmount: 10000,
      allowExtraWork: true,
      officialPrice: 30, // Para trabajos extra por horas
      workerPrice: 20,   // Para trabajos extra por horas
      client: 'Cliente de presupuesto cerrado'
    };

    // Reportes de trabajo
    const reports = [
      // Reporte normal dentro del presupuesto
      {
        id: 'report1',
        projectId: 'proyecto-cerrado',
        reportDate: '2023-10-15',
        weekNumber: 41,
        isExtraWork: false,
        invoicedAmount: 3000,
        workPerformed: { description: 'Trabajo normal' }
      },
      // Otro reporte normal
      {
        id: 'report2',
        projectId: 'proyecto-cerrado',
        reportDate: '2023-10-22',
        weekNumber: 42,
        isExtraWork: false,
        invoicedAmount: 4000,
        workPerformed: { description: 'Trabajo normal 2' }
      },
      // Trabajo extra con presupuesto adicional
      {
        id: 'report3',
        projectId: 'proyecto-cerrado',
        reportDate: '2023-10-25',
        weekNumber: 43,
        isExtraWork: true,
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1500,
        workPerformed: { description: 'Trabajo extra presupuestado' }
      },
      // Trabajo extra por horas
      {
        id: 'report4',
        projectId: 'proyecto-cerrado',
        reportDate: '2023-10-28',
        weekNumber: 43,
        isExtraWork: true,
        extraWorkType: 'hourly',
        labor: {
          officialEntry: '09:00',
          officialExit: '15:00',  // 6 horas
          workerEntry: '09:00',
          workerExit: '15:00'     // 6 horas
        },
        materials: [
          { id: 'matExtra', description: 'Material para trabajo extra', cost: 200 }
        ],
        workPerformed: { description: 'Trabajo extra por horas' }
      }
    ];

    // Calculamos datos del presupuesto
    const budgetSummary = result.current.calculateBudget(project, reports);

    // C√°lculos para trabajo extra por horas (report4)
    const extraWorkLabor = result.current.calculateLabor(reports[3].labor, project);
    const extraWorkMaterials = result.current.calculateMaterials(reports[3].materials);


    // *** FIX: Enriquecer report4 con los c√°lculos ANTES de llamar a calculateExtraWork ***
    const enrichedReport4 = {
      ...reports[3],
      labor: { ...reports[3].labor, ...extraWorkLabor }, // Add calculated labor data
      totalMaterialsCost: extraWorkMaterials.totalMaterialsCost, // Add calculated materials cost
    };

    // Create a new array with the enriched report
    const enrichedReports = [...reports];
    enrichedReports[3] = enrichedReport4;


    // C√°lculos de trabajos extra
    // *** FIX: Usar enrichedReports en lugar de reports ***
    const extraWorkSummary = result.current.calculateExtraWork(enrichedReports, project);


    // Calcular resumen general
    const summary = result.current.calculateReportSummary(enrichedReports, [project]);

    // Verificar c√°lculos del presupuesto
    expect(budgetSummary.budgetAmount).toBe(10000);
    expect(budgetSummary.invoicedTotal).toBe(7000); // 3000 + 4000
    expect(budgetSummary.remainingBudget).toBe(3000); // 10000 - 7000
    expect(budgetSummary.progressPercentage).toBe(70); // (7000 / 10000) * 100
    expect(budgetSummary.isOverBudget).toBe(false);

    // Verificar c√°lculos del trabajo extra por horas
    const expectedExtraLaborCost = (6 * 30) + (6 * 20); // 6h oficial * 30‚Ç¨ + 6h pe√≥n * 20‚Ç¨ = 180 + 120 = 300
    expect(extraWorkLabor.totalLaborCost).toBe(expectedExtraLaborCost);
    expect(extraWorkMaterials.totalMaterialsCost).toBe(200);

    // Verificar resumen de trabajos extra
    expect(extraWorkSummary.totalExtraBudget).toBe(1500); // Del report3
    expect(extraWorkSummary.totalExtraLaborCost).toBe(expectedExtraLaborCost); // labor cost del trabajo por horas
    expect(extraWorkSummary.totalExtraMaterials).toBe(200); // materials cost del trabajo por horas
    expect(extraWorkSummary.totalExtraCost).toBe(expectedExtraLaborCost + 200); // 300 + 200 = 500
    expect(extraWorkSummary.totalExtra).toBe(1500 + 500); // 2000
    expect(extraWorkSummary.extraWorkCount).toBe(2); // Dos reportes de trabajo extra

    // Verificar resumen general
    const summary_totals = summary.totals;
    expect(summary_totals.totalInvoiced).toBe(7000); // 3000 + 4000
    expect(summary_totals.totalExtraBudget).toBe(1500);
    expect(summary_totals.totalExtraCost).toBe(500); // 300 + 200

    // Ingresos totales: facturado normal + trabajos extra
    expect(summary_totals.totalIncome).toBe(7000); // En fixed, el ingreso es lo facturado
    expect(summary_totals.grandTotal).toBe(7000 + 1500 + 500); // 9000
  });

// ... (rest of the file) ...
});
</file>

<file path="src/utils/__tests__/calculationUtils.test.js">
// src/utils/__tests__/calculationUtils.test.js
import {
  calculateTimeDifference,
  convertToHours,
  getWeekNumber,
  formatCurrency,
  formatNumber,
} from '../calculationUtils';

describe('calculationUtils', () => {
  describe('calculateTimeDifference', () => {
    test('calcula correctamente la diferencia entre dos horas', () => {
      expect(calculateTimeDifference('08:00', '10:30')).toBe(2.5);
      expect(calculateTimeDifference('22:00', '01:00')).toBe(3); // Cruza medianoche
      expect(calculateTimeDifference('10:00', '10:00')).toBe(0);
      expect(calculateTimeDifference('10:45', '10:15')).toBe(23.5); //Caso donde la hora de salida es inferior a la de entrada.
    });

    test('maneja formatos inv√°lidos de hora devolviendo 0', () => {
      expect(calculateTimeDifference('invalid', '12:00')).toBe(0);
      expect(calculateTimeDifference('08:00', 'invalid')).toBe(0);
      expect(calculateTimeDifference('25:00', '12:00')).toBe(0);
      expect(calculateTimeDifference('08:00', '24:30')).toBe(0);
      expect(calculateTimeDifference('', '')).toBe(0);
      expect(calculateTimeDifference(null, null)).toBe(0);
      expect(calculateTimeDifference(undefined, undefined)).toBe(0);
    });
  });

  describe('convertToHours', () => {
    test('convierte correctamente string de tiempo a horas decimales', () => {
      expect(convertToHours('08:00')).toBe(8);
      expect(convertToHours('08:30')).toBe(8.5);
      expect(convertToHours('08:15')).toBe(8.25);
      expect(convertToHours('08:45')).toBe(8.75);
    });

    test('devuelve 0 cuando faltan datos', () => {
      expect(convertToHours('')).toBe(0);
      expect(convertToHours(null)).toBe(0);
      expect(convertToHours(undefined)).toBe(0);
    });

    test('maneja formatos inv√°lidos devolviendo 0', () => {
      expect(convertToHours('invalid')).toBe(0);
      // Este caso depende de la implementaci√≥n; si split() sobre un string inv√°lido
      // no devuelve un array con elementos v√°lidos, podr√≠a resultar en NaN
    });
  });

  describe('getWeekNumber', () => {
    test('calcula correctamente el n√∫mero de semana', () => {
      // Fechas espec√≠ficas con semanas conocidas
      expect(getWeekNumber('2023-01-01')).toBe(52);  // 2023-01-01 es semana 52 del a√±o 2022
      expect(getWeekNumber('2023-03-15')).toBe(11);
      expect(getWeekNumber('2023-12-25')).toBe(52);
      expect(getWeekNumber('2024-01-01')).toBe(1);   // 2024-01-01 s√≠ es semana 1 de 2024
    });

    test('maneja fechas inv√°lidas', () => {
      // Esto depende de la implementaci√≥n; en algunos casos podr√≠a devolver undefined o NaN
      // en lugar de un n√∫mero espec√≠fico
      expect(typeof getWeekNumber('invalid-date')).toBe('number');
    });
  });

  describe('formatCurrency', () => {
    test('formatea correctamente valores de moneda', () => {
      expect(formatCurrency(1234.56)).toBe('1.234,56¬†‚Ç¨');
      expect(formatCurrency(0)).toBe('0,00¬†‚Ç¨');
      expect(formatCurrency(1)).toBe('1,00¬†‚Ç¨');
      expect(formatCurrency(1000)).toBe('1.000,00¬†‚Ç¨');
    });

    test('maneja valores especiales', () => {
      expect(formatCurrency(null)).toBe('0,00¬†‚Ç¨');
      expect(formatCurrency(undefined)).toBe('0,00¬†‚Ç¨');
      expect(formatCurrency('')).toBe('0,00¬†‚Ç¨');
      expect(formatCurrency(NaN)).toBe('0,00¬†‚Ç¨');
    });
  });

  describe('formatNumber', () => {
    test('formatea correctamente n√∫meros con dos decimales', () => {
      expect(formatNumber(1234.567)).toBe('1234.57');
      expect(formatNumber(0)).toBe('0.00');
      expect(formatNumber(1)).toBe('1.00');
      expect(formatNumber(1.5)).toBe('1.50');
      expect(formatNumber(1000)).toBe('1000.00');
    });

    test('maneja valores especiales', () => {
      expect(formatNumber(null)).toBe('0.00');
      expect(formatNumber(undefined)).toBe('0.00');
      expect(formatNumber('')).toBe('0.00');
      expect(formatNumber(NaN)).toBe('0.00'); //Ahora devuelve 0.00
    });
  });
});
</file>

<file path="src/utils/calculations/__tests__/budgetUtils.test.js">
import { calculateBudget } from '../budgetUtils';

describe('budgetUtils - calculateBudget', () => {
  // Proyecto con reportes
  test('calcula correctamente el presupuesto, facturado y restante', () => {
    const project = {
      id: 'project1',
      budgetAmount: 10000
    };
    
    const reports = [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false },
      { id: '2', projectId: 'project1', invoicedAmount: 3000, isExtraWork: false },
      { id: '3', projectId: 'project1', invoicedAmount: 1500, isExtraWork: false }
    ];
    
    const result = calculateBudget(project, reports);
    
    expect(result.budgetAmount).toBe(10000);
    expect(result.invoicedTotal).toBe(6500); // 2000 + 3000 + 1500
    expect(result.remainingBudget).toBe(3500); // 10000 - 6500
    expect(result.progressPercentage).toBe(65); // (6500 / 10000) * 100
    expect(result.isOverBudget).toBe(false);
  });
  
  // Caso de presupuesto excedido
  test('identifica correctamente cuando se excede el presupuesto', () => {
    const project = {
      id: 'project1',
      budgetAmount: 5000
    };
    
    const reports = [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false },
      { id: '2', projectId: 'project1', invoicedAmount: 3500, isExtraWork: false }
    ];
    
    const result = calculateBudget(project, reports);
    
    expect(result.budgetAmount).toBe(5000);
    expect(result.invoicedTotal).toBe(5500); // 2000 + 3500
    expect(result.remainingBudget).toBe(-500); // 5000 - 5500
    // El porcentaje no deber√≠a superar el 100% aunque se haya excedido el presupuesto
    expect(result.progressPercentage).toBe(100);
    expect(result.isOverBudget).toBe(true);
  });
  
  // Caso con trabajos extra que no deben contabilizarse
  test('no incluye trabajos extra en el c√°lculo del presupuesto', () => {
    const project = {
      id: 'project1',
      budgetAmount: 5000
    };
    
    const reports = [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false },
      { id: '2', projectId: 'project1', invoicedAmount: 1500, isExtraWork: false },
      { id: '3', projectId: 'project1', invoicedAmount: 3000, isExtraWork: true } // Trabajo extra
    ];
    
    const result = calculateBudget(project, reports);
    
    // El trabajo extra no debe incluirse en el total facturado contra el presupuesto
    expect(result.invoicedTotal).toBe(3500); // 2000 + 1500 (excluye 3000)
    expect(result.remainingBudget).toBe(1500); // 5000 - 3500
    expect(result.progressPercentage).toBe(70); // (3500 / 5000) * 100
    expect(result.isOverBudget).toBe(false);
  });
  
  // Caso de filtrado de reportes por projectId
  test('solo incluye reportes del proyecto actual', () => {
    const project = {
      id: 'project1',
      budgetAmount: 8000
    };
    
    const reports = [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false },
      { id: '2', projectId: 'project2', invoicedAmount: 5000, isExtraWork: false }, // Otro proyecto
      { id: '3', projectId: 'project1', invoicedAmount: 1000, isExtraWork: false }
    ];
    
    const result = calculateBudget(project, reports);
    
    // Solo debe contar los reportes del proyecto1
    expect(result.invoicedTotal).toBe(3000); // 2000 + 1000 (excluye 5000)
  });
  
  // Caso sin datos
  test('devuelve valores por defecto cuando no hay proyecto o reportes', () => {
    // Sin proyecto ni reportes
    let result = calculateBudget();
    
    expect(result.budgetAmount).toBe(0);
    expect(result.invoicedTotal).toBe(0);
    expect(result.remainingBudget).toBe(0);
    expect(result.progressPercentage).toBe(0);
    expect(result.isOverBudget).toBe(false);
    
    // Con proyecto pero sin reportes
    result = calculateBudget({ id: 'project1', budgetAmount: 5000 });
    
    expect(result.budgetAmount).toBe(5000);
    expect(result.invoicedTotal).toBe(0);
    expect(result.remainingBudget).toBe(5000);
    expect(result.progressPercentage).toBe(0);
    
    // Con reportes pero sin proyecto
    result = calculateBudget(null, [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false }
    ]);
    
    expect(result.budgetAmount).toBe(0);
    expect(result.invoicedTotal).toBe(0);
  });
  
  // Caso con presupuesto cero
  test('maneja correctamente proyectos con presupuesto cero', () => {
    const project = {
      id: 'project1',
      budgetAmount: 0
    };
    
    const reports = [
      { id: '1', projectId: 'project1', invoicedAmount: 2000, isExtraWork: false }
    ];
    
    const result = calculateBudget(project, reports);
    
    expect(result.budgetAmount).toBe(0);
    expect(result.invoicedTotal).toBe(2000);
    expect(result.remainingBudget).toBe(-2000);
    // Evitar divisi√≥n por cero
    expect(result.progressPercentage).toBe(0);
    expect(result.isOverBudget).toBe(true);
  });
});
</file>

<file path="src/utils/calculations/__tests__/extraWorkUtils.test.js">
import { calculateExtraWork } from '../extraWorkUtils';

describe('extraWorkUtils - calculateExtraWork', () => {
  // Caso b√°sico con distintos tipos de trabajo extra
  test('calcula correctamente totales para diferentes tipos de trabajos extra', () => {
    const project = {
      id: 'project1',
      type: 'fixed'
    };
    
    const reports = [
      // Trabajos extra con presupuesto adicional
      { 
        id: '1', 
        projectId: 'project1', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1500 
      },
      { 
        id: '2', 
        projectId: 'project1', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 2000 
      },
      // Trabajos extra por horas
      {
        id: '3',
        projectId: 'project1',
        isExtraWork: true,
        extraWorkType: 'hourly',
        labor: { totalLaborCost: 800 },
        totalMaterialsCost: 400
      },
      // Reporte normal (no extra work)
      {
        id: '4',
        projectId: 'project1',
        isExtraWork: false,
        invoicedAmount: 3000
      }
    ];
    
    const result = calculateExtraWork(reports, project);
    
    // Verificar c√°lculos
    expect(result.totalExtraBudget).toBe(3500); // 1500 + 2000
    expect(result.totalExtraLaborCost).toBe(800);  // labor cost del trabajo por horas
    expect(result.totalExtraMaterials).toBe(400); // materials cost del trabajo por horas
    expect(result.totalExtraCost).toBe(1200); // 800 + 400
    expect(result.totalExtra).toBe(4700); // 3500 + 1200
    expect(result.extraWorkCount).toBe(3); // Total de reportes de trabajos extra
    expect(result.extraWorkReports).toHaveLength(3);
  });
  
  // Caso sin trabajos extra
  test('devuelve valores por defecto cuando no hay trabajos extra', () => {
    const project = {
      id: 'project1',
      type: 'fixed'
    };
    
    const reports = [
      // Solo reportes normales
      {
        id: '1',
        projectId: 'project1',
        isExtraWork: false,
        invoicedAmount: 2000
      },
      {
        id: '2',
        projectId: 'project1',
        isExtraWork: false,
        invoicedAmount: 3000
      }
    ];
    
    const result = calculateExtraWork(reports, project);
    
    // Verificar que todos los valores son cero
    expect(result.totalExtraBudget).toBe(0);
    expect(result.totalExtraLaborCost).toBe(0);
    expect(result.totalExtraMaterials).toBe(0);
    expect(result.totalExtraCost).toBe(0);
    expect(result.totalExtra).toBe(0);
    expect(result.extraWorkCount).toBe(0);
    expect(result.extraWorkReports).toEqual([]);
  });
  
  // Caso con m√∫ltiples proyectos (debe filtrar solo el seleccionado)
  test('solo incluye trabajos extra del proyecto especificado', () => {
    const project = {
      id: 'project1',
      type: 'fixed'
    };
    
    const reports = [
      // Trabajo extra del proyecto1
      { 
        id: '1', 
        projectId: 'project1', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1500 
      },
      // Trabajo extra del proyecto2 (no deber√≠a contarse)
      { 
        id: '2', 
        projectId: 'project2', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 3000 
      }
    ];
    
    const result = calculateExtraWork(reports, project);
    
    // Solo debe contar el trabajo extra del proyecto1
    expect(result.totalExtraBudget).toBe(1500);
    expect(result.extraWorkCount).toBe(1);
  });
  
  // Caso sin datos
  test('devuelve valores por defecto cuando no hay datos', () => {
    // Sin reportes ni proyecto
    let result = calculateExtraWork();
    
    expect(result.totalExtraBudget).toBe(0);
    expect(result.totalExtraLaborCost).toBe(0);
    expect(result.totalExtraMaterials).toBe(0);
    expect(result.totalExtraCost).toBe(0);
    expect(result.totalExtra).toBe(0);
    expect(result.extraWorkCount).toBe(0);
    expect(result.extraWorkReports).toEqual([]);
    
    // Con proyecto pero sin reportes
    result = calculateExtraWork([], { id: 'project1' });
    
    expect(result.totalExtraBudget).toBe(0);
    expect(result.extraWorkCount).toBe(0);
    
    // Con reportes pero sin proyecto
    result = calculateExtraWork([
      { 
        id: '1', 
        projectId: 'project1', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget',
        extraBudgetAmount: 1500 
      }
    ]);
    
    // Deber√≠a devolver valores por defecto si no se proporciona proyecto
    expect(result.totalExtraBudget).toBe(0);
    expect(result.extraWorkCount).toBe(0);
  });
  
  // Caso con datos incompletos en reportes de trabajo extra
  test('maneja correctamente reportes con datos incompletos', () => {
    const project = {
      id: 'project1',
      type: 'fixed'
    };
    
    const reports = [
      // Trabajo extra sin extraBudgetAmount
      { 
        id: '1', 
        projectId: 'project1', 
        isExtraWork: true, 
        extraWorkType: 'additional_budget'
        // Falta extraBudgetAmount
      },
      // Trabajo extra por horas sin datos de mano de obra
      {
        id: '2',
        projectId: 'project1',
        isExtraWork: true,
        extraWorkType: 'hourly'
        // Faltan labor y totalMaterialsCost
      }
    ];
    
    const result = calculateExtraWork(reports, project);
    
    // Deber√≠a manejar los valores faltantes como cero
    expect(result.totalExtraBudget).toBe(0);
    expect(result.totalExtraLaborCost).toBe(0);
    expect(result.totalExtraMaterials).toBe(0);
    expect(result.extraWorkCount).toBe(2); // A√∫n cuenta los reportes aunque falten datos
  });
});
</file>

<file path="src/utils/calculations/__tests__/laborUtils.test.js">
import { calculateLabor } from '../laborUtils';

describe('laborUtils - calculateLabor', () => {
  // Caso b√°sico con todos los datos correctos
  test('calcula correctamente las horas y costes cuando todos los datos son v√°lidos', () => {
    const labor = {
      officialEntry: '08:00',
      officialExit: '16:00',
      workerEntry: '08:00',
      workerExit: '16:00'
    };
    
    const project = {
      officialPrice: 25,
      workerPrice: 18
    };
    
    const result = calculateLabor(labor, project);
    
    // Comprobamos que las horas se calculan correctamente (8 horas)
    expect(result.officialHours).toBe(8);
    expect(result.workerHours).toBe(8);
    
    // Comprobamos que los costes se calculan correctamente
    expect(result.officialCost).toBe(200); // 8 horas * 25‚Ç¨
    expect(result.workerCost).toBe(144);   // 8 horas * 18‚Ç¨
    expect(result.totalLaborCost).toBe(344); // 200‚Ç¨ + 144‚Ç¨
  });
  
  // Caso donde se cruza la medianoche
  test('maneja correctamente casos donde la hora de salida es menor que la de entrada (cruce de medianoche)', () => {
    const labor = {
      officialEntry: '22:00',
      officialExit: '06:00',
      workerEntry: '22:00',
      workerExit: '06:00'
    };
    
    const project = {
      officialPrice: 30,
      workerPrice: 20
    };
    
    const result = calculateLabor(labor, project);
    
    // Comprobamos que las horas se calculan correctamente (8 horas)
    expect(result.officialHours).toBe(8);
    expect(result.workerHours).toBe(8);
    
    // Comprobamos que los costes se calculan correctamente
    expect(result.officialCost).toBe(240); // 8 horas * 30‚Ç¨
    expect(result.workerCost).toBe(160);   // 8 horas * 20‚Ç¨
    expect(result.totalLaborCost).toBe(400); // 240‚Ç¨ + 160‚Ç¨
  });
  
  // Caso de datos incompletos (solo oficial, no hay pe√≥n)
  test('calcula correctamente cuando solo hay datos del oficial', () => {
    const labor = {
      officialEntry: '09:00',
      officialExit: '15:00',
      workerEntry: '', // Sin datos de pe√≥n
      workerExit: ''
    };
    
    const project = {
      officialPrice: 22,
      workerPrice: 16
    };
    
    const result = calculateLabor(labor, project);
    
    // Comprobamos que las horas del oficial se calculan bien y las del pe√≥n son 0
    expect(result.officialHours).toBe(6);
    expect(result.workerHours).toBe(0);
    
    // Comprobamos que los costes se calculan correctamente
    expect(result.officialCost).toBe(132); // 6 horas * 22‚Ç¨
    expect(result.workerCost).toBe(0);    // No hay horas de pe√≥n
    expect(result.totalLaborCost).toBe(132); // 132‚Ç¨ + 0‚Ç¨
  });
  
  // Caso sin datos (valores por defecto)
  test('devuelve valores por defecto cuando no hay datos', () => {
    const result = calculateLabor();
    
    expect(result.officialHours).toBe(0);
    expect(result.workerHours).toBe(0);
    expect(result.officialCost).toBe(0);
    expect(result.workerCost).toBe(0);
    expect(result.totalLaborCost).toBe(0);
  });
  
  // Caso de horas parciales
  test('calcula correctamente horas parciales', () => {
    const labor = {
      officialEntry: '08:00',
      officialExit: '13:30', // 5.5 horas
      workerEntry: '08:30',
      workerExit: '13:00'    // 4.5 horas
    };
    
    const project = {
      officialPrice: 25,
      workerPrice: 18
    };
    
    const result = calculateLabor(labor, project);
    
    // Comprobamos que las horas se calculan correctamente
    expect(result.officialHours).toBe(5.5);
    expect(result.workerHours).toBe(4.5);
    
    // Comprobamos que los costes se calculan correctamente
    expect(result.officialCost).toBe(137.5); // 5.5 horas * 25‚Ç¨
    expect(result.workerCost).toBe(81);      // 4.5 horas * 18‚Ç¨
    expect(result.totalLaborCost).toBe(218.5); // 137.5‚Ç¨ + 81‚Ç¨
  });
  
  // Caso de datos inv√°lidos
  test('maneja datos inv√°lidos de manera segura', () => {
    const labor = {
      officialEntry: 'invalid',
      officialExit: 'invalid',
      workerEntry: 'invalid',
      workerExit: 'invalid'
    };
    
    const project = {
      officialPrice: 25,
      workerPrice: 18
    };
    
    const result = calculateLabor(labor, project);
    
    // En caso de datos inv√°lidos, deber√≠a devolverse 0 para evitar fallos
    expect(result.officialHours).toBe(0);
    expect(result.workerHours).toBe(0);
    expect(result.totalLaborCost).toBe(0);
  });
});
</file>

<file path="src/utils/calculations/__tests__/materialsUtils.test.js">
import { calculateMaterials } from '../materialsUtils';

describe('materialsUtils - calculateMaterials', () => {
  // Caso b√°sico con lista de materiales
  test('calcula correctamente el coste total de materiales', () => {
    const materials = [
      { id: 1, description: 'Material 1', cost: 100.5 },
      { id: 2, description: 'Material 2', cost: 50.75 },
      { id: 3, description: 'Material 3', cost: 200 }
    ];
    
    const result = calculateMaterials(materials);
    
    // Verificar el c√°lculo del coste total
    expect(result.totalMaterialsCost).toBe(351.25); // 100.5 + 50.75 + 200
    
    // Verificar que devuelve la lista formateada
    expect(result.materialItems).toHaveLength(3);
    expect(result.materialItems[0].formattedCost).toBe(100.5);
  });
  
  // Caso de lista vac√≠a
  test('devuelve cero cuando la lista de materiales est√° vac√≠a', () => {
    const materials = [];
    
    const result = calculateMaterials(materials);
    
    expect(result.totalMaterialsCost).toBe(0);
    expect(result.materialItems).toEqual([]);
  });
  
  // Caso sin datos (valores por defecto)
  test('devuelve valores por defecto cuando no hay datos', () => {
    const result = calculateMaterials();
    
    expect(result.totalMaterialsCost).toBe(0);
    expect(result.materialItems).toEqual([]);
  });
  
  // Caso con valores no num√©ricos
  test('maneja correctamente materiales con costes no num√©ricos', () => {
    const materials = [
      { id: 1, description: 'Material 1', cost: '100.5' }, // String que se puede parsear
      { id: 2, description: 'Material 2', cost: 'no es un n√∫mero' }, // No se puede parsear
      { id: 3, description: 'Material 3', cost: undefined }, // Undefined
      { id: 4, description: 'Material 4', cost: null }    // Null
    ];
    
    const result = calculateMaterials(materials);
    
    // Solo el primer valor debe contarse correctamente
    expect(result.totalMaterialsCost).toBe(100.5);
    
    // Verificar que los valores no num√©ricos se convierten a 0
    expect(result.materialItems[1].formattedCost).toBe(0);
    expect(result.materialItems[2].formattedCost).toBe(0);
    expect(result.materialItems[3].formattedCost).toBe(0);
  });
  
  // Caso con coste negativo (que no deber√≠a ocurrir en un caso real)
  test('maneja correctamente materiales con costes negativos', () => {
    const materials = [
      { id: 1, description: 'Material con descuento', cost: -50 },
      { id: 2, description: 'Material normal', cost: 150 }
    ];
    
    const result = calculateMaterials(materials);
    
    // Los costes negativos deber√≠an contarse (si la l√≥gica de negocio lo permite)
    expect(result.totalMaterialsCost).toBe(100); // -50 + 150
  });
  
  // Caso con propiedades faltantes
  test('maneja correctamente materiales con propiedades faltantes', () => {
    const materials = [
      { id: 1 }, // Sin descripci√≥n ni coste
      { id: 2, description: 'Solo descripci√≥n' }, // Sin coste
      { cost: 100 } // Sin ID ni descripci√≥n
    ];
    
    const result = calculateMaterials(materials);
    
    // Deber√≠a contar solo el √∫ltimo coste v√°lido
    expect(result.totalMaterialsCost).toBe(100);
    
    // Verificar formattedCost para cada material
    expect(result.materialItems[0].formattedCost).toBe(0);
    expect(result.materialItems[1].formattedCost).toBe(0);
    expect(result.materialItems[2].formattedCost).toBe(100);
  });
});
</file>

<file path="src/utils/calculations/__tests__/reportSummaryUtils.test.js">
import { calculateReportSummary } from '../reportSummaryUtils';

describe('reportSummaryUtils - calculateReportSummary', () => {
  // Datos de prueba comunes
  const sampleProjects = [
    { id: 'project1', type: 'hourly', client: 'Cliente 1' },
    { id: 'project2', type: 'fixed', client: 'Cliente 2' }
  ];
  
  const sampleReports = [
    // Proyecto por horas
    {
      id: 'report1',
      projectId: 'project1',
      reportDate: '2023-01-15',
      weekNumber: 2,
      labor: { 
        totalLaborCost: 400,
        officialHours: 5,
        workerHours: 5
      },
      totalMaterialsCost: 150,
      totalCost: 550
    },
    {
      id: 'report2',
      projectId: 'project1',
      reportDate: '2023-01-16',
      weekNumber: 3,
      labor: { 
        totalLaborCost: 320,
        officialHours: 4,
        workerHours: 4
      },
      totalMaterialsCost: 200,
      totalCost: 520
    },
    // Proyecto de presupuesto cerrado
    {
      id: 'report3',
      projectId: 'project2',
      reportDate: '2023-01-15',
      weekNumber: 2,
      invoicedAmount: 1000
    },
    {
      id: 'report4',
      projectId: 'project2',
      reportDate: '2023-01-22',
      weekNumber: 3,
      invoicedAmount: 1500
    },
    // Trabajo extra (presupuesto adicional)
    {
      id: 'report5',
      projectId: 'project2',
      reportDate: '2023-01-23',
      weekNumber: 4,
      isExtraWork: true,
      extraWorkType: 'additional_budget',
      extraBudgetAmount: 800
    },
    // Trabajo extra (por horas)
    {
      id: 'report6',
      projectId: 'project2',
      reportDate: '2023-01-24',
      weekNumber: 4,
      isExtraWork: true,
      extraWorkType: 'hourly',
      labor: {
        totalLaborCost: 250,
        officialHours: 3,
        workerHours: 3
      },
      totalMaterialsCost: 100,
      totalCost: 350
    }
  ];
  
  // Caso b√°sico con todos los reportes
  test('calcula correctamente totales generales para todos los reportes', () => {
    const result = calculateReportSummary(sampleReports, sampleProjects);
    
    // Verificar totales
    expect(result.totals.totalLabor).toBe(720); // 400 + 320
    expect(result.totals.totalMaterials).toBe(350); // 150 + 200
    expect(result.totals.totalCost).toBe(1070); // 550 + 520
    expect(result.totals.totalInvoiced).toBe(2500); // 1000 + 1500
    expect(result.totals.totalHours).toBe(18); // 5+5 + 4+4
    expect(result.totals.totalIncome).toBe(3220); // 720 + 2500 (labor en hourly + invoiced en fixed)
    expect(result.totals.totalExtraBudget).toBe(800);
    expect(result.totals.totalExtraCost).toBe(350); // 250 + 100
  });
  
  // Filtrado por proyecto
  test('filtra correctamente por proyecto seleccionado', () => {
    const result = calculateReportSummary(sampleReports, sampleProjects, 'project1');
    
    // Solo debe incluir datos del proyecto1
    expect(result.totals.totalLabor).toBe(720); // 400 + 320
    expect(result.totals.totalMaterials).toBe(350); // 150 + 200
    expect(result.totals.totalInvoiced).toBe(0); // No hay invoiced en proyecto1
    expect(result.totals.totalExtraBudget).toBe(0); // No hay trabajos extra en proyecto1
    
    // Verificar agrupaci√≥n por proyecto
    expect(result.byProject).toHaveLength(1);
    expect(result.byProject[0].projectId).toBe('project1');
  });
  
  // Agrupaci√≥n por semana
  test('agrupa correctamente por semana', () => {
    const result = calculateReportSummary(sampleReports, sampleProjects);
    
    // Debe haber 3 semanas diferentes
    expect(result.byWeek).toHaveLength(3);
    
    // Verificar algunas semanas espec√≠ficas
    const week2 = result.byWeek.find(w => w.weekNumber === 2);
    expect(week2).toBeDefined();
    expect(week2.laborCost).toBe(400);
    expect(week2.materialsCost).toBe(150);
    expect(week2.invoicedAmount).toBe(1000);
    
    const week4 = result.byWeek.find(w => w.weekNumber === 4);
    expect(week4).toBeDefined();
    expect(week4.extraBudget).toBe(800);
    expect(week4.extraCost).toBe(350);
  });
  
  // Agrupaci√≥n por proyecto
  test('agrupa correctamente por proyecto', () => {
    const result = calculateReportSummary(sampleReports, sampleProjects);
    
    // Debe haber 2 proyectos
    expect(result.byProject).toHaveLength(2);
    
    // Verificar proyecto1 (hourly)
    const project1Data = result.byProject.find(p => p.projectId === 'project1');
    expect(project1Data).toBeDefined();
    expect(project1Data.type).toBe('hourly');
    expect(project1Data.laborCost).toBe(720);
    expect(project1Data.materialsCost).toBe(350);
    expect(project1Data.totalIncome).toBe(720); // En hourly, el ingreso es la mano de obra
    
    // Verificar proyecto2 (fixed)
    const project2Data = result.byProject.find(p => p.projectId === 'project2');
    expect(project2Data).toBeDefined();
    expect(project2Data.type).toBe('fixed');
    expect(project2Data.invoicedAmount).toBe(2500);
    expect(project2Data.extraBudget).toBe(800);
    expect(project2Data.extraCost).toBe(350);
    expect(project2Data.totalIncome).toBe(2500); // En fixed, el ingreso es lo facturado
  });
  
  // Caso sin datos
  test('devuelve valores por defecto cuando no hay datos', () => {
    // Sin reportes ni proyectos
    let result = calculateReportSummary();
    
    expect(result.totals.totalLabor).toBe(0);
    expect(result.totals.totalInvoiced).toBe(0);
    expect(result.byWeek).toEqual([]);
    expect(result.byProject).toEqual([]);
    
    // Con proyectos pero sin reportes
    result = calculateReportSummary([], sampleProjects);
    
    expect(result.totals.totalLabor).toBe(0);
    expect(result.byWeek).toEqual([]);
    
    // Con reportes pero sin proyectos
    result = calculateReportSummary(sampleReports, []);
    
    // Deber√≠a calcular los totales pero no podr√° clasificar bien por tipo de proyecto
    expect(result.totals.totalLabor).toBe(720);
    expect(result.totals.totalInvoiced).toBe(2500);
  });
  
  // Reportes con datos incompletos
  test('maneja correctamente reportes con datos incompletos', () => {
    const incompleteReports = [
      // Reporte por horas sin labor
      {
        id: 'report1',
        projectId: 'project1',
        reportDate: '2023-01-15',
        weekNumber: 2,
        // Sin labor
        totalMaterialsCost: 150
      },
      // Reporte por horas sin totalMaterialsCost
      {
        id: 'report2',
        projectId: 'project1',
        reportDate: '2023-01-16',
        weekNumber: 3,
        labor: { 
          totalLaborCost: 320,
          officialHours: 4,
          workerHours: 4
        }
        // Sin totalMaterialsCost
      },
      // Reporte fixed sin invoicedAmount
      {
        id: 'report3',
        projectId: 'project2',
        reportDate: '2023-01-15',
        weekNumber: 2
        // Sin invoicedAmount
      }
    ];
    
    const result = calculateReportSummary(incompleteReports, sampleProjects);
    
    // Deber√≠a manejar los valores faltantes como cero
    expect(result.totals.totalLabor).toBe(320); // Solo del report2
    expect(result.totals.totalMaterials).toBe(150); // Solo del report1
    expect(result.totals.totalInvoiced).toBe(0); // El report3 no tiene invoicedAmount
  });
  
  // Ordenaci√≥n de reportes por semana/a√±o
  test('ordena correctamente los reportes por semana y a√±o', () => {
    const multiYearReports = [
      // A√±o 2022
      {
        id: 'report1',
        projectId: 'project1',
        reportDate: '2022-12-25',
        weekNumber: 52,
        labor: { totalLaborCost: 100 },
        totalMaterialsCost: 50
      },
      // A√±o 2023
      {
        id: 'report2',
        projectId: 'project1',
        reportDate: '2023-01-01',
        weekNumber: 1,
        labor: { totalLaborCost: 200 },
        totalMaterialsCost: 100
      },
      // Mismo a√±o, semana anterior
      {
        id: 'report3',
        projectId: 'project1',
        reportDate: '2023-02-15',
        weekNumber: 7,
        labor: { totalLaborCost: 300 },
        totalMaterialsCost: 150
      }
    ];
    
    const result = calculateReportSummary(multiYearReports, sampleProjects);
    
    // Las semanas deben estar ordenadas por a√±o y n√∫mero de semana
    expect(result.byWeek).toHaveLength(3);
    expect(result.byWeek[0].year).toBe(2022);
    expect(result.byWeek[0].weekNumber).toBe(52);
    expect(result.byWeek[1].year).toBe(2023);
    expect(result.byWeek[1].weekNumber).toBe(1);
    expect(result.byWeek[2].year).toBe(2023);
    expect(result.byWeek[2].weekNumber).toBe(7);
  });
  
  // Ordenaci√≥n de proyectos por ingreso total
  test('ordena correctamente los proyectos por ingreso total', () => {
    const result = calculateReportSummary(sampleReports, sampleProjects);
    
    // Los proyectos deben estar ordenados por totalIncome (de mayor a menor)
    expect(result.byProject).toHaveLength(2);
    expect(result.byProject[0].totalIncome).toBeGreaterThanOrEqual(result.byProject[1].totalIncome);
  });
});
</file>

<file path="src/utils/calculations/extraWorkUtils.js">
// src/utils/calculations/extraWorkUtils.js

/**
 * Calcula los datos relacionados con trabajos extra
 *
 * @param {Array} reports - Lista de reportes
 * @param {Object} project - Datos del proyecto
 * @returns {Object} Resultados de los c√°lculos de trabajos extra
 */
export function calculateExtraWork(reports = [], project = {}) {
  if (!reports || !Array.isArray(reports) || !project) {
    return {
      totalExtraBudget: 0,
      totalExtraLaborCost: 0, // Renamed for clarity
      totalExtraMaterials: 0,
      totalExtraCost: 0,
      totalExtra: 0,
      extraWorkCount: 0,
      extraWorkReports: []
    };
  }

  // Filtrar reportes de trabajos extra para este proyecto
  const extraWorkReports = reports.filter(
    report => report.projectId === project.id && report.isExtraWork
  );

  let totalExtraBudget = 0;
  let totalExtraLaborCost = 0; // Renamed for clarity
  let totalExtraMaterials = 0;
  let totalExtraCost = 0;

  // Calcular totales para cada tipo de trabajo extra
  extraWorkReports.forEach(report => {
    if (report.extraWorkType === 'additional_budget') {
      totalExtraBudget += report.extraBudgetAmount || 0;
    } else if (report.extraWorkType === 'hourly') {
      // More thorough check for labor.totalLaborCost
      // Check both direct totalLaborCost on report or in report.labor
      const laborCost = report.totalLaborCost || (report.labor && report.labor.totalLaborCost) || 0;
      const materialsCost = report.totalMaterialsCost || 0;

      totalExtraLaborCost += laborCost; // Use the renamed variable
      totalExtraMaterials += materialsCost;
      totalExtraCost += report.totalCost || laborCost + materialsCost; // Consider totalCost at the root of the report
    }
  });

  const totalExtra = totalExtraBudget + totalExtraCost;

  return {
    totalExtraBudget,
    totalExtraLaborCost, // Renamed for clarity
    totalExtraMaterials,
    totalExtraCost,
    totalExtra,
    extraWorkCount: extraWorkReports.length,
    extraWorkReports
  };
}
</file>

<file path="src/utils/calculations/laborUtils.js">
// src/utils/calculations/laborUtils.js
import { calculateTimeDifference } from '../calculationUtils';

/**
 * Calcula los datos relacionados con la mano de obra
 *
 * @param {Object} labor - Datos de mano de obra (horas de entrada/salida)
 * @param {Object} project - Datos del proyecto (tarifas)
 * @returns {Object} Resultados de los c√°lculos de mano de obra
 */
export function calculateLabor(labor = {}, project = {}) {
  // Si no hay datos de labor o proyecto, devolver valores por defecto
  if (!labor || !project) {
    return {
      officialHours: 0,
      workerHours: 0,
      officialCost: 0,
      workerCost: 0,
      totalLaborCost: 0
    };
  }

  const { officialEntry, officialExit, workerEntry, workerExit } = labor;
  const { officialPrice = 0, workerPrice = 0 } = project;

  // Calcular horas trabajadas
  const officialHours = calculateTimeDifference(officialEntry, officialExit);
  const workerHours = calculateTimeDifference(workerEntry, workerExit);

  // Calcular costes
  const officialCost = officialHours * officialPrice;
  const workerCost = workerHours * workerPrice;
  const totalLaborCost = officialCost + workerCost;

  return {
    officialHours,
    workerHours,
    officialCost,
    workerCost,
    totalLaborCost
  };
}
</file>

<file path="src/utils/calculations/materialsUtils.js">
// src/utils/calculations/materialsUtils.js

/**
 * Calcula los datos relacionados con materiales
 * 
 * @param {Array} materials - Lista de materiales con costes
 * @returns {Object} Resultados de los c√°lculos de materiales
 */
export function calculateMaterials(materials = []) {
  if (!materials || !Array.isArray(materials)) {
    return {
      totalMaterialsCost: 0,
      materialItems: []
    };
  }

  // Calcular el coste total de materiales
  const totalMaterialsCost = materials.reduce((sum, material) => {
    return sum + (parseFloat(material.cost) || 0);
  }, 0);

  // Devolver tambi√©n la lista de materiales procesada
  const materialItems = materials.map(material => ({
    ...material,
    formattedCost: parseFloat(material.cost) || 0
  }));

  return {
    totalMaterialsCost,
    materialItems
  };
}
</file>

<file path="src/utils/calculationUtils.js">
// src/utils/calculationUtils.js

/**
 * Calcula la diferencia de tiempo entre dos horas en formato "HH:MM"
 * @param {string} startTime - Hora de inicio en formato "HH:MM"
 * @param {string} endTime - Hora de fin en formato "HH:MM"
 * @returns {number} Diferencia en horas (decimal)
 */
export const calculateTimeDifference = (startTime, endTime) => {
  if (!startTime || !endTime) return 0;

  // Crear objetos de fecha para hoy con las horas especificadas
  const today = new Date().toDateString();
  let start = new Date(`${today} ${startTime}`);
  let end = new Date(`${today} ${endTime}`);

  // Si la hora de fin es menor que la de inicio, asumir que es del d√≠a siguiente
  if (end < start) {
    end = new Date(end.getTime() + 24 * 60 * 60 * 1000);
  }

  // Calcular diferencia en milisegundos y convertir a horas
  const diffMs = end - start;
    //Asegurar que sea un n√∫mero para no causar problemas al usarlo
  const diffHours =  Number(diffMs / (1000 * 60 * 60)) || 0;

  return diffHours;
};

/**
 * Convierte una cadena de tiempo "HH:MM" a horas decimales
 * @param {string} timeString - Tiempo en formato "HH:MM"
 * @returns {number} Horas en formato decimal
 */
 export const convertToHours = (timeString) => {
  if (!timeString) return 0;

  const [hours, minutes] = timeString.split(':');
    // Usar parseInt con base 10 y manejar NaN
  const parsedHours = parseInt(hours, 10);
  const parsedMinutes = parseInt(minutes, 10);
  if (isNaN(parsedHours) || isNaN(parsedMinutes)) {
    return 0; //Devolver NaN
  }

  return parsedHours + (parsedMinutes / 60);
};

/**
 * Calcula el n√∫mero de semana del a√±o para una fecha dada (ISO-8601)
 * @param {string} dateString - Fecha en formato "YYYY-MM-DD"
 * @returns {number} N√∫mero de semana
 */
export const getWeekNumber = (dateString) => {
  const date = new Date(dateString);
  const dayNum = date.getUTCDay() || 7; // Obtener d√≠a (0-6, 0 es Domingo).  Si es 0, convertir a 7.
  date.setUTCDate(date.getUTCDate() + 4 - dayNum); // Ajustar al JUEVES de la semana.
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1)); // 1 de enero del a√±o.
  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7); // Calcular n√∫mero de semana.
};


/**
 * Formatea un n√∫mero como moneda en euros
 * @param {number} value - Valor a formatear
 * @returns {string} Valor formateado como moneda (ej: "1.234,56¬†‚Ç¨")
 */
export const formatCurrency = (value) => {
  const numValue = Number(value) || 0; 
  return new Intl.NumberFormat('es-ES', {
    style: 'currency',
    currency: 'EUR',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
    useGrouping: true // Asegura que se usen separadores de miles
  }).format(numValue);
};

/**
 * Formatea un n√∫mero con dos decimales
 * @param {number} value - Valor a formatear
 * @returns {string} Valor formateado con dos decimales
 */
export const formatNumber = (value) => {
    // Usar 0 como valor por defecto si es null o undefined
  const numValue = Number(value) || 0; // Convertir a n√∫mero y manejar NaN
  return numValue.toFixed(2);
};
</file>

<file path="src/utils/formatters.js">
export const formatNumber = (num) => parseFloat(num).toFixed(2);
export const formatCurrency = (num) => `‚Ç¨${formatNumber(num)}`;
export const formatFullDate = (date) =>
  new Date(date).toLocaleDateString("es-ES", { weekday: "long", day: "numeric", month: "long", year: "numeric" });
export const getWeekNumber = (date) => {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
};
</file>

<file path="src/utils/PdfDownload.js">
// src/utils/PdfDownload.js - Versi√≥n simplificada
import React from 'react';
import { pdf } from '@react-pdf/renderer';
import { saveAs } from 'file-saver';

const PDFDownloadButton = ({ 
  Document, 
  documentProps = {}, 
  fileName = 'document.pdf',
  buttonProps = {},
  children
}) => {
  const generatePdf = async () => {
    try {
      // Crear el PDF sin complicaciones adicionales
      const blob = await pdf(<Document {...documentProps} />).toBlob();
      saveAs(blob, fileName);
    } catch (err) {
      console.error('Error al generar PDF:', err);
      alert('Error al generar el PDF. Por favor, int√©ntalo de nuevo.');
    }
  };

  return (
    <div className="pdf-download-container">
      <button
        onClick={generatePdf}
        {...buttonProps}
      >
        {children || 'Descargar PDF'}
      </button>
    </div>
  );
};

export const generateAndDownloadPDF = async (Document, documentProps = {}, fileName = 'document.pdf') => {
  try {
    const blob = await pdf(<Document {...documentProps} />).toBlob();
    saveAs(blob, fileName);
    return { success: true };
  } catch (err) {
    console.error('Error al generar PDF:', err);
    return { success: false, error: err.message };
  }
};

export default PDFDownloadButton;
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "partesdiarios-bbcc1",
    "test": "partesdiarios-bbcc1",
    "partes-diarios": "partesdiarios-bbcc1"
  },
  "targets": {},
  "etags": {}
}
</file>

<file path="cors.json">
[
  {
    "origin": ["https://partes-diarios.vercel.app", "http://localhost:3000"],
    "method": ["GET", "PUT", "POST", "DELETE"],
    "maxAgeSeconds": 3600,
    "headers": ["Content-Type", "Authorization"]
  }
]
</file>

<file path="firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "weekNumber", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "weekNumber", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "reportDate", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "reportDate", "order": "ASCENDING" },
        { "fieldPath": "projectId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "dailyReports",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "reportDate", "order": "DESCENDING" },
        { "fieldPath": "projectId", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "projectId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "file_metadata",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "folder", "order": "ASCENDING" },
        { "fieldPath": "fileName", "order": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
</file>

<file path="firestore.rules">
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Regla b√°sica: cualquier usuario autenticado puede leer/escribir
    // Esta es una configuraci√≥n balanceada entre seguridad y facilidad de desarrollo
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
    
    // Definimos reglas espec√≠ficas para debug_collection (que usamos en pruebas)
    match /debug_collection/{document} {
      allow read, write: if request.auth != null;
    }
  }
}
</file>

<file path="functions/package.json">
{
  "name": "functions",
  "description": "Cloud Functions para la aplicaci√≥n Partes Diarios",
  "scripts": {
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^13.2.0",
    "firebase-functions": "^6.3.2"
  },
  "private": true
}
</file>

<file path="public/manifest.json">
{
  "short_name": "alqatifa",
  "name": "alqatifa - Partes de trabajo",
   "icons": [
     {
       "src": "favicon.png",
       "sizes": "64x64 32x32 24x24 16x16",
       "type": "image/png"
     },
     {
       "src": "favicon.png",  // Tambi√©n puedes tener versiones m√°s grandes
       "type": "image/png",
       "sizes": "192x192"
     },
     {
       "src": "favicon.png", //  Versi√≥n m√°s grande
       "type": "image/png",
       "sizes": "512x512"
     }
   ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="README.md">
HEAD
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)
=======
# partes-diarios
2189e9e73a0a5b38d0ed3eb8542ce620c56ab919
</file>

<file path="src/components/dashboard/DashboardCharts.js">
// src/components/dashboard/DashboardCharts.js - Refactorizado para usar useCalculationsService
import React from "react";
import ProjectCostChart from "./ProjectCostChart";
import TimelineChart from "./TimelineChart";
import EmptyState from "../common/EmptyState";
import { useCalculationsService } from "../../hooks/useCalculationsService";

/**
 * Componente para la secci√≥n de gr√°ficos del dashboard
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.reports - Lista de reportes filtrados
 * @param {Array} props.projects - Lista de proyectos
 * @param {string} props.selectedProject - ID del proyecto seleccionado
 * @param {Object} props.dateRange - Rango de fechas
 * @param {string} props.activeView - Vista activa ('costes' o 'timeline')
 * @param {Function} props.onViewChange - Funci√≥n para cambiar la vista
 */
const DashboardCharts = ({
  reports,
  projects,
  selectedProject,
  dateRange,
  activeView,
  onViewChange
}) => {
  // Usamos el servicio centralizado de c√°lculos
  const { calculateReportSummary } = useCalculationsService();
  
  // Obtenemos los datos calculados del servicio
  const { byProject, byWeek } = calculateReportSummary(
    reports, 
    projects, 
    selectedProject !== "all" ? selectedProject : ""
  );

  return (
    <div className="chart-container" role="tabpanel">
      <div className="chart-tab-buttons" role="tablist">
        <button 
          role="tab"
          aria-selected={activeView === "costes"}
          className={activeView === "costes" ? "active" : ""}
          onClick={() => onViewChange("costes")}
        >
          Costes por Proyecto
        </button>
        <button 
          role="tab"
          aria-selected={activeView === "timeline"}
          className={activeView === "timeline" ? "active" : ""}
          onClick={() => onViewChange("timeline")}
        >
          Evoluci√≥n Temporal
        </button>
      </div>
      
      <div className="chart-wrapper">
        {activeView === "costes" ? (
          byProject.length > 0 ? (
            <ProjectCostChart data={byProject} />
          ) : (
            <EmptyState 
              message="No hay datos suficientes para mostrar el gr√°fico de costes." 
              icon="üìä" 
            />
          )
        ) : (
          byWeek.length > 0 ? (
            <TimelineChart data={byWeek} />
          ) : (
            <EmptyState 
              message="No hay datos suficientes para mostrar la evoluci√≥n temporal." 
              icon="üìà" 
            />
          )
        )}
      </div>
    </div>
  );
};

export default React.memo(DashboardCharts);
</file>

<file path="src/components/dashboard/DashboardFilters.js">
// src/components/dashboard/DashboardFilters.js
import React, { useCallback, useMemo } from "react"; // Importar useMemo

/**
 * Componente para filtros del dashboard
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.projects - Lista de proyectos
 * @param {string} props.selectedProject - ID del proyecto seleccionado ("all" o un ID espec√≠fico)
 * @param {Object} props.dateRange - Rango de fechas {startDate, endDate}
 * @param {Function} props.onFiltersChange - Funci√≥n para manejar cambios en filtros
 */
const DashboardFilters = ({
  projects,
  selectedProject, // Puede ser "all" o un ID
  dateRange,
  onFiltersChange
}) => {

  // Ordenar los proyectos alfab√©ticamente descendente por ID
  const sortedProjects = useMemo(() => {
    return [...projects].sort((a, b) => {
      return (b.id || "").localeCompare(a.id || "");
    });
  }, [projects]); // Dependencia: reordenar solo si 'projects' cambia

  // Manejar cambio de proyecto
  const handleProjectChange = useCallback((e) => {
    const newProjectId = e.target.value;
    onFiltersChange({
      // Pasar "" si es "all", o el ID si es un proyecto espec√≠fico
      projectId: newProjectId !== "all" ? newProjectId : ""
    });
  }, [onFiltersChange]);

  // Manejar cambio en fechas
  const handleDateChange = useCallback((e) => {
    const { name, value } = e.target;
    onFiltersChange({ [name]: value });
  }, [onFiltersChange]);

  return (
    <div className="dashboard-filter" role="search">
      <h3>Filtros</h3>

      {/* Selector de proyecto */}
      <div className="filter-group">
        <label htmlFor="project-select-dashboard">Proyecto:</label>
        {/* Usar la lista ordenada */}
        <select
          id="project-select-dashboard"
          // El valor debe ser "all" si no hay un ID espec√≠fico
          value={selectedProject || "all"}
          onChange={handleProjectChange}
          className="project-selector"
          aria-label="Seleccionar proyecto"
        >
          <option value="all">Todos los proyectos</option>
          {sortedProjects.map(project => (
            <option key={project.firestoreId} value={project.id}>
              {project.id} - {project.client}
            </option>
          ))}
        </select>
      </div>

      {/* Filtro de fechas */}
      <div className="date-range">
        <div className="date-field">
          <label htmlFor="startDate-dashboard">Fecha inicial:</label>
          <input
            id="startDate-dashboard"
            type="date"
            name="startDate"
            value={dateRange.startDate || ""} // Controlar valor undefined/null
            onChange={handleDateChange}
            aria-label="Fecha inicial para filtrar"
          />
        </div>
        <div className="date-field">
          <label htmlFor="endDate-dashboard">Fecha final:</label>
          <input
            id="endDate-dashboard"
            type="date"
            name="endDate"
            value={dateRange.endDate || ""} // Controlar valor undefined/null
            onChange={handleDateChange}
            aria-label="Fecha final para filtrar"
          />
        </div>
      </div>
    </div>
  );
};

export default React.memo(DashboardFilters);
</file>

<file path="src/components/ImageUploader.js">
import React, { useState, useCallback, useRef } from "react";
import { useStorage } from "../hooks/useStorage";
import "./ImageUploader.css"; // A√±adiremos los estilos en un archivo separado

const ImageUploader = ({ 
  onImagesUploaded, 
  folder, 
  prefix, 
  maxFiles = 10, 
  acceptedTypes = "image/*",
  existingImages = []
}) => {
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [uploadProgress, setUploadProgress] = useState({});
  const [uploadErrors, setUploadErrors] = useState([]);
  const fileInputRef = useRef(null);
  
  // eslint-disable-next-line no-unused-vars
  const { uploadFile, uploading, error: uploadError } = useStorage();

  // Prevenir comportamiento por defecto para eventos de arrastrar y soltar
  const preventDefaults = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  // Procesar los archivos seleccionados
  const handleFiles = useCallback((newFiles) => {
    // Filtrar solo im√°genes si es necesario
    const imageFiles = newFiles.filter(file => file.type.startsWith('image/'));
    
    // Verificar l√≠mite de archivos
    const totalFiles = files.length + imageFiles.length;
    if (totalFiles > maxFiles) {
      alert(`No puedes subir m√°s de ${maxFiles} im√°genes a la vez.`);
      return;
    }
    
    // Actualizar estado de archivos
    setFiles(prevFiles => [...prevFiles, ...imageFiles]);
    
    // Crear vistas previas
    imageFiles.forEach(file => {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviews(prevPreviews => [
          ...prevPreviews, 
          { id: Date.now() + Math.random(), file, preview: reader.result }
        ]);
      };
      reader.readAsDataURL(file);
    });
  }, [files, maxFiles]);

  // Manejar entrada en la zona de drop
  const handleDragEnter = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(true);
  }, [preventDefaults]);

  // Manejar salida de la zona de drop
  const handleDragLeave = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(false);
  }, [preventDefaults]);

  // Manejar el evento de soltar archivos
  const handleDrop = useCallback((e) => {
    preventDefaults(e);
    setIsDragging(false);
    
    const droppedFiles = Array.from(e.dataTransfer.files);
    handleFiles(droppedFiles);
  }, [preventDefaults, handleFiles]);

  // Manejar selecci√≥n de archivos desde el input
  const handleFileSelect = useCallback((e) => {
    const selectedFiles = Array.from(e.target.files);
    handleFiles(selectedFiles);
    // Limpiar el input para permitir seleccionar el mismo archivo de nuevo
    e.target.value = null;
  }, [handleFiles]);

  // Eliminar una imagen de la lista
  const handleRemoveFile = useCallback((id) => {
    setPreviews(prevPreviews => prevPreviews.filter(item => item.id !== id));
    // Tambi√©n actualizamos el array de archivos
    setFiles(prevFiles => {
      const previewToRemove = previews.find(p => p.id === id);
      if (previewToRemove) {
        return prevFiles.filter(f => f !== previewToRemove.file);
      }
      return prevFiles;
    });
  }, [previews]);

  // Eliminar una imagen ya subida
  const handleRemoveExistingImage = useCallback((id) => {
    if (onImagesUploaded && typeof onImagesUploaded === 'function') {
      onImagesUploaded({ type: 'remove', id });
    }
  }, [onImagesUploaded]);

  // Subir todas las im√°genes
  const handleUploadAll = useCallback(async () => {
    if (files.length === 0) return;
    
    setUploadErrors([]);
    const uploadedImages = [];
    const newProgress = {};
    
    // Subir cada archivo individualmente
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const preview = previews.find(p => p.file === file);
      
      if (!preview) continue;
      
      try {
        newProgress[preview.id] = 0;
        setUploadProgress(prev => ({ ...prev, [preview.id]: 0 }));
        
        // Aqu√≠ usamos tu hook de useStorage
        const url = await uploadFile(file, folder, prefix);
        
        if (url) {
          uploadedImages.push({ id: Date.now() + i, url });
          newProgress[preview.id] = 100;
          setUploadProgress(prev => ({ ...prev, [preview.id]: 100 }));
        } else {
          setUploadErrors(prev => [...prev, `Error al subir ${file.name}`]);
          newProgress[preview.id] = -1;
          setUploadProgress(prev => ({ ...prev, [preview.id]: -1 }));
        }
      } catch (error) {
        console.error("Error al subir imagen:", error);
        setUploadErrors(prev => [...prev, `Error al subir ${file.name}: ${error.message}`]);
        newProgress[preview.id] = -1;
        setUploadProgress(prev => ({ ...prev, [preview.id]: -1 }));
      }
    }
    
    // Limpiar despu√©s de subir exitosamente
    if (uploadedImages.length > 0) {
      if (onImagesUploaded && typeof onImagesUploaded === 'function') {
        onImagesUploaded({ type: 'add', images: uploadedImages });
      }
      setFiles([]);
      setPreviews([]);
      setUploadProgress({});
    }
  }, [files, previews, uploadFile, folder, prefix, onImagesUploaded]);

  // Abrir el selector de archivos al hacer clic en el √°rea de drop
  const openFileSelector = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="image-uploader">
      {/* √Årea para arrastrar y soltar */}
      <div 
        className={`drop-area ${isDragging ? 'dragging' : ''}`}
        onDragEnter={handleDragEnter}
        onDragOver={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={openFileSelector}
      >
        <input 
          type="file" 
          ref={fileInputRef}
          accept={acceptedTypes}
          multiple 
          onChange={handleFileSelect}
          style={{ display: 'none' }}
        />
        <div className="drop-message">
          <i className="upload-icon">üìÅ</i>
          <p>Arrastra im√°genes aqu√≠ o haz clic para seleccionarlas</p>
          <span className="file-info">Acepta m√∫ltiples im√°genes (m√°x. {maxFiles})</span>
        </div>
      </div>
      
      {/* Vista previa de im√°genes seleccionadas */}
      {previews.length > 0 && (
        <div className="preview-container">
          <h4>Im√°genes seleccionadas ({previews.length})</h4>
          <div className="previews">
            {previews.map((item) => (
              <div key={item.id} className="preview-item">
                <img src={item.preview} alt="Vista previa" />
                <div className="preview-info">
                  <span className="file-name">{item.file.name}</span>
                  <span className="file-size">{(item.file.size / 1024).toFixed(1)} KB</span>
                  {uploadProgress[item.id] !== undefined && (
                    <div className={`upload-progress ${uploadProgress[item.id] === -1 ? 'error' : ''}`}>
                      {uploadProgress[item.id] === -1 ? 
                        'Error' : 
                        `${uploadProgress[item.id]}%`
                      }
                    </div>
                  )}
                </div>
                <button 
                  className="remove-button" 
                  onClick={() => handleRemoveFile(item.id)}
                  title="Eliminar"
                >
                  √ó
                </button>
              </div>
            ))}
          </div>
          <button 
            className="upload-button" 
            onClick={handleUploadAll}
            disabled={uploading || previews.length === 0}
          >
            {uploading ? 'Subiendo...' : 'Subir todas las im√°genes'}
          </button>
        </div>
      )}
      
      {/* Mostrar errores */}
      {uploadErrors.length > 0 && (
        <div className="upload-errors">
          <h4>Errores de carga</h4>
          <ul>
            {uploadErrors.map((error, index) => (
              <li key={index} className="error-message">{error}</li>
            ))}
          </ul>
        </div>
      )}
      
      {/* Im√°genes ya subidas */}
      {existingImages && existingImages.length > 0 && (
        <div className="existing-images">
          <h4>Im√°genes subidas ({existingImages.length})</h4>
          <div className="previews">
            {existingImages.map((image) => (
              <div key={image.id} className="preview-item">
                <img src={image.url} alt="Imagen subida" />
                <button 
                  className="remove-button" 
                  onClick={() => handleRemoveExistingImage(image.id)}
                  title="Eliminar"
                >
                  √ó
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default ImageUploader;
</file>

<file path="src/components/LaborForm.js">
import React, { useCallback, useEffect } from "react";
import { useCalculationsService } from "../hooks/useCalculationsService";
import { formatNumber, formatCurrency } from "../utils/calculationUtils";

const LaborForm = ({ labor, onLaborChange, project }) => {
  // Usamos el servicio centralizado de c√°lculos
  const { calculateLabor } = useCalculationsService();
  const calculatedLabor = calculateLabor(labor, project);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    let newLabor = { ...labor, [name]: value };

    // Si se cambia una hora del oficial, copiar al pe√≥n autom√°ticamente
    if (name === "officialEntry") {
      newLabor.workerEntry = value; // Copiar entrada del oficial al pe√≥n
    } else if (name === "officialExit") {
      newLabor.workerExit = value; // Copiar salida del oficial al pe√≥n
    }

    onLaborChange(newLabor);
  }, [labor, onLaborChange]);

  // Efecto para sincronizar las horas iniciales si ya existen
  useEffect(() => {
    if (labor.officialEntry && !labor.workerEntry) {
      onLaborChange({ ...labor, workerEntry: labor.officialEntry });
    }
    if (labor.officialExit && !labor.workerExit) {
      onLaborChange({ ...labor, workerExit: labor.officialExit });
    }
  }, [labor, onLaborChange]);

  return (
    <div className="labor-form">
      <h3>Mano de obra</h3>
      <div className="labor-row">
        <div className="labor-field">
          <label>Hora entrada oficial</label>
          <input
            type="time"
            name="officialEntry"
            value={labor.officialEntry}
            onChange={handleChange}
            className="time-input"
          />
        </div>
        <div className="labor-field">
          <label>Hora salida oficial</label>
          <input
            type="time"
            name="officialExit"
            value={labor.officialExit}
            onChange={handleChange}
            className="time-input"
          />
        </div>
      </div>
      <div className="labor-row">
        <div className="labor-field">
          <label>Hora entrada pe√≥n</label>
          <input
            type="time"
            name="workerEntry"
            value={labor.workerEntry}
            onChange={handleChange}
            className="time-input"
          />
        </div>
        <div className="labor-field">
          <label>Hora salida pe√≥n</label>
          <input
            type="time"
            name="workerExit"
            value={labor.workerExit}
            onChange={handleChange}
            className="time-input"
          />
        </div>
      </div>
      {project && (
        <div className="labor-summary">
          <p>
            Oficial: {formatNumber(calculatedLabor.officialHours)} h - {formatCurrency(calculatedLabor.officialCost)}
          </p>
          <p>
            Pe√≥n: {formatNumber(calculatedLabor.workerHours)} h - {formatCurrency(calculatedLabor.workerCost)}
          </p>
          <p>
            Total: {formatCurrency(calculatedLabor.totalLaborCost)}
          </p>
        </div>
      )}
    </div>
  );
};

export default React.memo(LaborForm);
</file>

<file path="src/components/LoginForm.js">
// src/components/LoginForm.js
import React, { useState } from 'react';
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "firebase/auth";
import { app } from '../firebase'; // Importa 'app' desde tu archivo firebase.js

function LoginForm() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [isRegistering, setIsRegistering] = useState(false); // Controla si el usuario se registra o inicia sesi√≥n
    const [error, setError] = useState(null);
    const [user, setUser] = useState(null); // Almacena la informaci√≥n del usuario

    const auth = getAuth(app);

    // Lista blanca de correos electr√≥nicos permitidos (¬°Ajusta esto a tus necesidades!)
    const allowedEmails = ['info@alqatifa.com', 'jesusmabas@gmail.com']; // ¬°Coma agregada!

    const handleSubmit = async (event) => {
        event.preventDefault();
        setError(null); // Limpia errores anteriores

        try {
            if (isRegistering) {
                // --- VERIFICACI√ìN DE LISTA BLANCA (solo para registro) ---
                if (!allowedEmails.includes(email)) {
                    setError('Este correo electr√≥nico no est√° autorizado para registrarse.');
                    return; // Detiene la ejecuci√≥n si el correo no es v√°lido
                }

                // --- REGISTRO (si el correo es v√°lido) ---
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                setUser(userCredential.user);
                console.log("Usuario registrado:", userCredential.user);
            } else {
                // --- INICIO DE SESI√ìN (sin cambios) ---
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                setUser(userCredential.user);
                console.log("Usuario logueado:", userCredential.user);
            }
        } catch (error) {
            setError(error.message); // Muestra el mensaje de error de Firebase
            console.error("Error:", error);
        }
    };

    const handleSignOut = async () => {
        try {
            await signOut(auth);
            setUser(null);
            console.log("Usuario deslogueado");
        } catch (error) {
            setError(error.message);
            console.error("Error al desloguear:", error);
        }
    };

    return (
        <div>
            {user ? ( // Muestra informaci√≥n del usuario si est√° logueado
                <div>
                    <p>Bienvenido, {user.email}</p>
                    <button onClick={handleSignOut}>Cerrar Sesi√≥n</button>
                </div>
            ) : (
                <form onSubmit={handleSubmit} className="login-form">
                    <h2>{isRegistering ? 'Registrarse' : 'Iniciar Sesi√≥n'}</h2>
                    {error && <p style={{ color: 'red' }}>{error}</p>}
                    <div>
                        <label htmlFor="email">Correo Electr√≥nico:</label>
                        <input
                            type="email"
                            id="email"
                            value={email}
                            onChange={(e) => setEmail(e.target.value)}
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="password">Contrase√±a:</label>
                        <input
                            type="password"
                            id="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required
                        />
                    </div>
                    <button type="submit">{isRegistering ? 'Registrarse' : 'Iniciar Sesi√≥n'}</button>
                    <button type="button" onClick={() => setIsRegistering(!isRegistering)}>
                        {isRegistering ? '¬øYa tienes cuenta? Inicia Sesi√≥n' : '¬øNo tienes cuenta? Reg√≠strate'}
                    </button>
                </form>
            )}
        </div>
    );
}

export default LoginForm;
</file>

<file path="src/components/ProjectForm.js">
// src/components/ProjectForm.js - Modificaci√≥n para incluir campos de trabajo extra

import React, { useState } from "react";
import { getFunctions, httpsCallable } from "firebase/functions";
import useFormValidation from "../hooks/useFormValidation";
import { projectSchema } from "../utils/validationSchemas";
import { formatCurrency } from "../utils/formatters";

const ProjectForm = ({ onProjectAdded }) => {
  const [serverError, setServerError] = useState(null);
  const [serverSuccess, setServerSuccess] = useState(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Valores iniciales del formulario con campos adicionales
  const initialValues = {
    id: "",
    client: "",
    address: "",
    nifNie: "",
    type: "hourly",
    officialPrice: 0,
    workerPrice: 0,
    budgetAmount: 0,
    allowExtraWork: false  // Nuevo campo para habilitar trabajos extra
  };

  // Usar nuestro hook personalizado para formularios
  const {
    values,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    hasError,
    getError,
    isValid
  } = useFormValidation(initialValues, projectSchema);

  // Funci√≥n para manejar el env√≠o del formulario
  const submitForm = async (formData) => {
    setIsSubmitting(true);
    setServerError(null);
    setServerSuccess(null);
    
    try {
      // Usar Cloud Functions para validaci√≥n server-side
      const functions = getFunctions();
      const createProject = httpsCallable(functions, 'createProject');
      
      // Enviar datos para validaci√≥n y creaci√≥n
      const result = await createProject(formData);
      
      // Manejar respuesta exitosa
      setServerSuccess(result.data.message || 'Proyecto a√±adido correctamente');
      resetForm();
      
      // Notificar al componente padre
      if (onProjectAdded && typeof onProjectAdded === 'function') {
        onProjectAdded(result.data);
      }
    } catch (error) {
      // Manejar errores
      console.error("Error al crear proyecto:", error);
      setServerError(error.message || 'Error al crear el proyecto');
      
      // Si hay errores de validaci√≥n espec√≠ficos del servidor
      if (error.details && typeof error.details === 'object') {
        // Aqu√≠ se podr√≠an mostrar errores espec√≠ficos por campo
        setServerError(`Error de validaci√≥n: ${Object.values(error.details).join(', ')}`);
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  // Funci√≥n para manejar el cambio en el checkbox de trabajos extra
  const handleAllowExtraWorkChange = (e) => {
    const { checked } = e.target;
    handleChange({
      target: {
        name: 'allowExtraWork',
        value: checked
      }
    });
  };

  return (
    <form onSubmit={handleSubmit(submitForm)} className="project-form">
      {serverError && <p className="error-message">{serverError}</p>}
      {serverSuccess && <p className="success-message">{serverSuccess}</p>}

      {/* ID del Proyecto */}
      <div className="form-group">
        <label htmlFor="project-id">ID del proyecto</label>
        <input
          id="project-id"
          type="text"
          name="id"
          value={values.id}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('id') ? 'input-error' : ''}
          placeholder="Identificador √∫nico del proyecto"
        />
        {hasError('id') && <p className="error-message">{getError('id')}</p>}
      </div>

      {/* Cliente */}
      <div className="form-group">
        <label htmlFor="project-client">Cliente</label>
        <input
          id="project-client"
          type="text"
          name="client"
          value={values.client}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('client') ? 'input-error' : ''}
          placeholder="Nombre del cliente"
        />
        {hasError('client') && <p className="error-message">{getError('client')}</p>}
      </div>

      {/* Direcci√≥n */}
      <div className="form-group">
        <label htmlFor="project-address">Direcci√≥n</label>
        <input
          id="project-address"
          type="text"
          name="address"
          value={values.address}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('address') ? 'input-error' : ''}
          placeholder="Direcci√≥n del proyecto"
        />
        {hasError('address') && <p className="error-message">{getError('address')}</p>}
      </div>

      {/* NIF/NIE */}
      <div className="form-group">
        <label htmlFor="project-nifnie">NIF/NIE</label>
        <input
          id="project-nifnie"
          type="text"
          name="nifNie"
          value={values.nifNie}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('nifNie') ? 'input-error' : ''}
          placeholder="NIF o NIE del cliente"
        />
        {hasError('nifNie') && <p className="error-message">{getError('nifNie')}</p>}
      </div>

      {/* Tipo de Proyecto */}
      <div className="form-group">
        <label htmlFor="project-type">Tipo de proyecto</label>
        <select
          id="project-type"
          name="type"
          value={values.type}
          onChange={handleChange}
          onBlur={handleBlur}
          className={hasError('type') ? 'input-error' : ''}
        >
          <option value="hourly">Por horas</option>
          <option value="fixed">Presupuesto cerrado</option>
        </select>
        {hasError('type') && <p className="error-message">{getError('type')}</p>}
      </div>

      {/* Campos espec√≠ficos seg√∫n el tipo */}
      {values.type === "hourly" ? (
        <>
          <div className="form-group">
            <label htmlFor="project-official-price">Precio oficial (‚Ç¨/h)</label>
            <input
              id="project-official-price"
              type="number"
              name="officialPrice"
              value={values.officialPrice}
              onChange={handleChange}
              onBlur={handleBlur}
              className={hasError('officialPrice') ? 'input-error' : ''}
              min="0"
              step="0.01"
              placeholder="Precio por hora del oficial"
            />
            {hasError('officialPrice') && <p className="error-message">{getError('officialPrice')}</p>}
          </div>

          <div className="form-group">
            <label htmlFor="project-worker-price">Precio pe√≥n (‚Ç¨/h)</label>
            <input
              id="project-worker-price"
              type="number"
              name="workerPrice"
              value={values.workerPrice}
              onChange={handleChange}
              onBlur={handleBlur}
              className={hasError('workerPrice') ? 'input-error' : ''}
              min="0"
              step="0.01"
              placeholder="Precio por hora del pe√≥n"
            />
            {hasError('workerPrice') && <p className="error-message">{getError('workerPrice')}</p>}
          </div>
        </>
      ) : (
        <>
          <div className="form-group">
            <label htmlFor="project-budget">Importe presupuestado (‚Ç¨)</label>
            <input
              id="project-budget"
              type="number"
              name="budgetAmount"
              value={values.budgetAmount}
              onChange={handleChange}
              onBlur={handleBlur}
              className={hasError('budgetAmount') ? 'input-error' : ''}
              min="0"
              step="0.01"
              placeholder="Importe total presupuestado"
            />
            {hasError('budgetAmount') && <p className="error-message">{getError('budgetAmount')}</p>}
          </div>
          
          {/* Opci√≥n para habilitar trabajos extra en proyectos de presupuesto cerrado */}
          <div className="form-group checkbox-group">
            <input
              id="project-allow-extra"
              type="checkbox"
              name="allowExtraWork"
              checked={values.allowExtraWork}
              onChange={handleAllowExtraWorkChange}
              className="checkbox-input"
            />
            <label htmlFor="project-allow-extra" className="checkbox-label">
              Permitir trabajos extra fuera de presupuesto
            </label>
          </div>
          
          {/* Si se habilitan trabajos extra, mostrar campos de precios por hora */}
          {values.allowExtraWork && (
            <div className="extra-work-section">
              <h4>Tarifas para trabajos extra por horas</h4>
              <p className="hint-text">Estos precios se aplicar√°n solo a trabajos extra facturados por horas</p>
              
              <div className="form-group">
                <label htmlFor="project-extra-official-price">Precio oficial para extras (‚Ç¨/h)</label>
                <input
                  id="project-extra-official-price"
                  type="number"
                  name="officialPrice"
                  value={values.officialPrice}
                  onChange={handleChange}
                  onBlur={handleBlur}
                  className={hasError('officialPrice') ? 'input-error' : ''}
                  min="0"
                  step="0.01"
                  placeholder="Precio por hora del oficial para trabajos extra"
                />
              </div>

              <div className="form-group">
                <label htmlFor="project-extra-worker-price">Precio pe√≥n para extras (‚Ç¨/h)</label>
                <input
                  id="project-extra-worker-price"
                  type="number"
                  name="workerPrice"
                  value={values.workerPrice}
                  onChange={handleChange}
                  onBlur={handleBlur}
                  className={hasError('workerPrice') ? 'input-error' : ''}
                  min="0"
                  step="0.01"
                  placeholder="Precio por hora del pe√≥n para trabajos extra"
                />
              </div>
            </div>
          )}
        </>
      )}

      {/* Bot√≥n de env√≠o */}
      <button
        type="submit"
        disabled={isSubmitting || !isValid}
        className={!isValid ? 'button-disabled' : ''}
      >
        {isSubmitting ? "A√±adiendo..." : "A√±adir proyecto"}
      </button>

      {/* Bot√≥n para resetear el formulario */}
      <button
        type="button"
        onClick={() => resetForm()}
        disabled={isSubmitting}
        className="button-secondary"
      >
        Limpiar formulario
      </button>
    </form>
  );
};

export default ProjectForm;
</file>

<file path="src/hooks/reports/useReportActions.js">
// src/hooks/reports/useReportActions.js (Completo)
import { useCallback, useState } from "react";
import {
  doc,
  updateDoc,
  deleteDoc,
  addDoc,
  collection,
  getDoc,
  getDocs,
  query,
  orderBy,
  where
} from "firebase/firestore";
import { ref, deleteObject } from "firebase/storage";
import { db, storage } from "../../firebase";
import { getWeekNumber } from "../../utils/calculationUtils"; // Aseg√∫rate que sea calculationUtils

/**
 * Hook personalizado para gestionar acciones CRUD de reportes
 * @returns {Object} - Objeto con funciones y estados para gestionar reportes
 */
export const useReportActions = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  // Funci√≥n para borrar mensajes de estado
  const clearMessages = useCallback(() => {
    setError(null);
    setSuccess(null);
  }, []);

  // Funci√≥n para obtener todos los reportes (con filtro isBilled)
  const fetchReports = useCallback(async (filters = {}) => {
    setLoading(true);
    clearMessages();

    try {
      let reportsQuery = collection(db, "dailyReports");
      const queryFilters = [];

      // Aplicar filtros si se proporcionan
      if (filters.projectId) {
        queryFilters.push(where("projectId", "==", filters.projectId));
      }
      if (filters.userId) {
        queryFilters.push(where("userId", "==", filters.userId));
      }
      if (filters.startDate) {
        queryFilters.push(where("reportDate", ">=", filters.startDate));
      }
      if (filters.endDate) {
        queryFilters.push(where("reportDate", "<=", filters.endDate));
      }
      // NUEVO FILTRO: isBilled
      if (filters.isBilled !== undefined) {
        if (filters.isBilled === false) {
            // Consulta compuesta:  isBilled == false OR isBilled == null
            reportsQuery = query(reportsQuery,
                where("isBilled", "in", [false, null]) // Usar 'in'
            );

        } else {
          queryFilters.push(where("isBilled", "==", filters.isBilled));

      // Construir la consulta con filtros y ordenamiento
      if (queryFilters.length > 0) {
        reportsQuery = query(
          reportsQuery,
          ...queryFilters,
          orderBy("reportDate", "desc")
        );
      } else {
        reportsQuery = query(
          reportsQuery,
          orderBy("reportDate", "desc")
        );
      }

      const querySnapshot = await getDocs(reportsQuery);
      const reportsList = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));

      setSuccess("Reportes obtenidos correctamente");
      return reportsList;
    } catch (err) {
      console.error("Error al obtener reportes:", err);
      setError(`Error al obtener reportes: ${err.message}`);
      return [];
    } finally {
      setLoading(false);
    }
  }, [clearMessages]);



  // Funci√≥n para crear un nuevo reporte
  const createReport = useCallback(async (reportData, userId) => {
    if (!reportData || !userId) {
      setError("Datos de reporte o ID de usuario no proporcionados");
      return null;
    }

    setLoading(true);
    clearMessages();

    try {
      // Asegurar que tiene una fecha y calcular semana
      if (!reportData.reportDate) {
        reportData.reportDate = new Date().toISOString().split("T")[0];
      }

      const weekNumber = getWeekNumber(reportData.reportDate);

      // Preparar datos para guardar
      const newReportData = {
        ...reportData,
        weekNumber,
        userId,
        createdAt: new Date(),
        isBilled: false, // NUEVO: isBilled por defecto es false
      };

      // Guardar en Firestore
      const docRef = await addDoc(collection(db, "dailyReports"), newReportData);

      setSuccess("Reporte creado correctamente");
      return { id: docRef.id, ...newReportData };
    } catch (err) {
      console.error("Error al crear reporte:", err);
      setError(`Error al crear reporte: ${err.message}`);
      return null;
    } finally {
      setLoading(false);
    }
  }, [clearMessages]);

  // Funci√≥n para actualizar un reporte existente
  const updateReport = useCallback(async (reportId, updatedData) => {
    if (!reportId || !updatedData) {
      setError("ID de reporte o datos actualizados no proporcionados");
      return false;
    }

    setLoading(true);
    clearMessages();

    try {
      // Obtener el reporte actual primero
      const reportRef = doc(db, "dailyReports", reportId);
      const reportSnap = await getDoc(reportRef);

      if (!reportSnap.exists()) {
        throw new Error("El reporte no existe");
      }

      // Si hay una fecha nueva, recalcular el n√∫mero de semana
      if (updatedData.reportDate && updatedData.reportDate !== reportSnap.data().reportDate) {
        updatedData.weekNumber = getWeekNumber(updatedData.reportDate);
      }

      // Actualizar timestamp
      updatedData.updatedAt = new Date();

      // Actualizar en Firestore
      await updateDoc(reportRef, updatedData);

      setSuccess("Reporte actualizado correctamente");
      return true;
    } catch (err) {
      console.error("Error al actualizar reporte:", err);
      setError(`Error al actualizar reporte: ${err.message}`);
      return false;
    } finally {
      setLoading(false);
    }
  }, [clearMessages]);



// Funci√≥n para eliminar un reporte y sus archivos asociados (sin cambios)
  const deleteReport = useCallback(async (reportId) => {
    if (!reportId) {
      setError("ID de reporte no proporcionado");
      return false;
    }

    setLoading(true);
    clearMessages();

    try {
      // Obtener el reporte primero para saber qu√© archivos eliminar
      const reportRef = doc(db, "dailyReports", reportId);
      const reportSnap = await getDoc(reportRef);

      if (!reportSnap.exists()) {
        throw new Error("El reporte no existe");
      }

      const reportData = reportSnap.data();

      // Funci√≥n auxiliar mejorada para eliminar archivos de Storage
      const deleteFileFromStorage = async (url) => {
        if (!url || typeof url !== 'string') return;

        try {
          // Convertir URL a ruta de Storage
          let path;

          // Ejemplo: https://firebasestorage.googleapis.com/v0/b/BUCKET/o/PATH?token=TOKEN
          // Necesitamos extraer PATH
          if (url.includes('firebasestorage.googleapis.com')) {
            const startIndex = url.indexOf('/o/') + 3;
            const endIndex = url.indexOf('?', startIndex);

            if (startIndex > 2 && endIndex > startIndex) {
              path = decodeURIComponent(url.substring(startIndex, endIndex));
            } else {
              console.warn("Formato de URL no reconocido:", url);
              return;
            }
          } else {
            // Si es una ruta directa, usarla tal cual
            path = url;
          }

          console.log("Intentando eliminar archivo:", path);
          const fileRef = ref(storage, path);
          await deleteObject(fileRef);
        } catch (err) {
          console.error(`Error al eliminar archivo ${url}:`, err);
          // Continuamos con la eliminaci√≥n aunque falle un archivo
        }
      };

      // Eliminar facturas de materiales
      if (reportData.materials && Array.isArray(reportData.materials)) {
        for (const material of reportData.materials) {
          if (material && material.invoiceUrl) {
            await deleteFileFromStorage(material.invoiceUrl);
          }
        }
      }

      // Eliminar fotos
      if (reportData.workPerformed && reportData.workPerformed.photos &&
          Array.isArray(reportData.workPerformed.photos)) {
        for (const photo of reportData.workPerformed.photos) {
          if (photo && photo.url) {
            await deleteFileFromStorage(photo.url);
          }
        }
      }

      // Eliminar el documento de Firestore
      await deleteDoc(reportRef);

      setSuccess("Reporte eliminado correctamente");
      return true;
    } catch (err) {
      console.error("Error al eliminar reporte:", err);
      setError(`Error al eliminar reporte: ${err.message}`);
      return false;
    } finally {
      setLoading(false);
    }
  }, [clearMessages]);

  // Obtener un reporte espec√≠fico por ID (sin cambios)
  const getReportById = useCallback(async (reportId) => {
    if (!reportId) {
      setError("ID de reporte no proporcionado");
      return null;
    }

    setLoading(true);
    clearMessages();

    try {
      const reportRef = doc(db, "dailyReports", reportId);
      const reportSnap = await getDoc(reportRef);

      if (!reportSnap.exists()) {
        throw new Error("El reporte no existe");
      }

      return { id: reportSnap.id, ...reportSnap.data() };
    } catch (err) {
      console.error(`Error al obtener reporte ${reportId}:`, err);
      setError(`Error al obtener reporte: ${err.message}`);
      return null;
    } finally {
      setLoading(false);
    }
  }, [clearMessages]);

  return {
    createReport,
    updateReport,
    deleteReport,
    fetchReports,
    getReportById,
    loading,
    error,
    success,
    clearMessages
  };
};
</file>

<file path="src/hooks/useQueryReports.js">
// src/hooks/useQueryReports.js (Completo)
import { useInfiniteQuery, useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  collection,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  getDocs,
  getDoc,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  serverTimestamp
} from 'firebase/firestore';
import { ref, deleteObject } from 'firebase/storage';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { db, storage } from '../firebase';

// Clave de cach√© para reportes
const REPORTS_CACHE_KEY = 'reports';

// Obtener reportes con filtros y paginaci√≥n  (MODIFICADO: Manejo de undefined)
const fetchReports = async ({ pageParam = null, ...filters }) => {
  const pageSize = filters.pageSize || 10;

  let q = collection(db, 'dailyReports');
  const conditions = [];

  // Aplicar filtros
  if (filters.projectId) {
    conditions.push(where("projectId", "==", filters.projectId));
  }
  if (filters.userId) {
    conditions.push(where("userId", "==", filters.userId));
  }
  if (filters.weekNumber) {
    conditions.push(where("weekNumber", "==", filters.weekNumber));
  }
  if (filters.startDate) {
    conditions.push(where("reportDate", ">=", filters.startDate));
  }
  if (filters.endDate) {
    conditions.push(where("reportDate", "<=", filters.endDate));
  }
  // NUEVO FILTRO (Manejo expl√≠cito de undefined)
  if (filters.isBilled !== undefined) {  // <-- CAMBIO CRUCIAL AQU√ç
    conditions.push(where("isBilled", "==", filters.isBilled));
  }

  // Ordenamiento
  const orderByField = filters.orderBy || 'reportDate';
  const orderDirection = filters.orderDirection || 'desc';

  q = query(q, ...conditions, orderBy(orderByField, orderDirection));

  // Aplicar paginaci√≥n
  q = query(q, limit(pageSize));

  if (pageParam) {
    q = query(q, startAfter(pageParam));
  }

  const querySnapshot = await getDocs(q);
  const lastDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
  const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

  return {
    items,
    lastDoc,
    hasMore: items.length === pageSize,
  };
};

// Obtener un reporte por ID
const fetchReportById = async (reportId) => {
  if (!reportId) return null;

  const docRef = doc(db, "dailyReports", reportId);
  const docSnap = await getDoc(docRef);

  if (docSnap.exists()) {
    return { id: docSnap.id, ...docSnap.data() };
  }

  return null;
};

// Hook para obtener reportes con paginaci√≥n infinita
export const useQueryReportsInfinite = (filters = {}) => {
  return useInfiniteQuery({
    queryKey: [REPORTS_CACHE_KEY, filters],
    queryFn: ({ pageParam }) => fetchReports({ pageParam, ...filters }),
    getNextPageParam: (lastPage) => lastPage.hasMore ? lastPage.lastDoc : undefined,
  });
};

// Hook para obtener un reporte espec√≠fico
export const useQueryReport = (reportId) => {
  return useQuery({
    queryKey: [REPORTS_CACHE_KEY, reportId],
    queryFn: () => fetchReportById(reportId),
    enabled: !!reportId, // Solo ejecutar si hay un reportId
  });
};

// Hook para agregar un reporte
export const useAddReport = () => {
  const queryClient = useQueryClient();
  const functions = getFunctions();
  const createReportFunction = httpsCallable(functions, 'createDailyReport');

  return useMutation({
    mutationFn: async (reportData) => {
      // Usar Cloud Function para validaci√≥n y creaci√≥n
      const result = await createReportFunction(reportData);
      return result.data;
    },
    // Invalidar cach√© al finalizar
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
    },
  });
};

// Hook para actualizar un reporte (MODIFICADO: Optimistic Update)
export const useUpdateReport = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ reportId, data }) => {
      const reportRef = doc(db, "dailyReports", reportId);
      const updateData = { ...data, updatedAt: serverTimestamp() }; // Incluye isBilled y cualquier otro dato
      await updateDoc(reportRef, updateData);
      return { id: reportId, ...updateData }; // Devuelve datos actualizados
    },
    // Optimistic Update
    onMutate: async ({ reportId, data }) => {
      await queryClient.cancelQueries({ queryKey: [REPORTS_CACHE_KEY, reportId] });
      const previousReport = queryClient.getQueryData([REPORTS_CACHE_KEY, reportId]);

      queryClient.setQueryData([REPORTS_CACHE_KEY, reportId], old => ({
        ...old,
        ...data, // Aplica los cambios de 'data' (incluyendo isBilled)
      }));

       // Actualiza tambi√©n la lista de reportes (optimistic update)
        queryClient.setQueryData([REPORTS_CACHE_KEY], (oldData) => {
          if (!oldData || !oldData.pages) return oldData;

          const newPages = oldData.pages.map((page) => {
            return {
              ...page,
              items: page.items.map((item) => {
                if (item.id === reportId) {
                  return { ...item, ...data }; // Aplica cambios al reporte correcto
                }
                return item;
              }),
            };
          });

          return { ...oldData, pages: newPages };
        });

      return { previousReport };
    },
    onError: (err, { reportId }, context) => {
      if (context?.previousReport) {
        queryClient.setQueryData([REPORTS_CACHE_KEY, reportId], context.previousReport);
      }
    },
    onSettled: (data, error, { reportId }) => {
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY, reportId] });
      queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
    },
  });
};

// Hook para eliminar un reporte (sin cambios)
export const useDeleteReport = () => {
    const queryClient = useQueryClient();

    return useMutation({
      mutationFn: async (reportId) => {
        const reportRef = doc(db, 'dailyReports', reportId);
        const reportSnap = await getDoc(reportRef);

        if (!reportSnap.exists()) {
          throw new Error('Reporte no encontrado');
        }

        const report = reportSnap.data();

        const deleteFileFromStorage = async (url) => {
            if (!url || typeof url !== 'string') return;
            try {
              let path;
              if (url.includes('firebasestorage.googleapis.com')) {
                const startIndex = url.indexOf('/o/') + 3;
                const endIndex = url.indexOf('?', startIndex);
                if (startIndex > 2 && endIndex > startIndex) {
                  path = decodeURIComponent(url.substring(startIndex, endIndex));
                } else {
                  console.warn("Formato de URL no reconocido:", url);
                  return;
                }
              } else {
                path = url;
              }
              console.log("Intentando eliminar archivo:", path);
              const fileRef = ref(storage, path);
              await deleteObject(fileRef);
            } catch (err) {
              console.error(`Error al eliminar archivo ${url}:`, err);
            }
        };

          if (report.materials && Array.isArray(report.materials)) {
            for (const material of report.materials) {
              if (material && material.invoiceUrl) {
                await deleteFileFromStorage(material.invoiceUrl);
              }
            }
          }

          if (report.workPerformed?.photos && Array.isArray(report.workPerformed.photos)) {
            for (const photo of report.workPerformed.photos) {
              if (photo && photo.url) {
                await deleteFileFromStorage(photo.url);
              }
            }
          }

        await deleteDoc(reportRef);
        return reportId;
      },

        onMutate: async (reportId) => {
          await queryClient.cancelQueries({ queryKey: [REPORTS_CACHE_KEY] });
          const previousCacheData = queryClient.getQueryState([REPORTS_CACHE_KEY]);

            queryClient.setQueriesData(
            { queryKey: [REPORTS_CACHE_KEY] },
            (oldData) => {
              if (!oldData || !oldData.pages) return oldData;
              return {
                ...oldData,
                pages: oldData.pages.map(page => ({
                  ...page,
                  items: page.items.filter(item => item.id !== reportId),
                })),
              };
            }
          );

        return { previousCacheData };
        },

      onSettled: () => {
        queryClient.invalidateQueries({ queryKey: [REPORTS_CACHE_KEY] });
      },
    });
  };
</file>

<file path="src/hooks/useStorage.js">
// src/hooks/useStorage.js - Versi√≥n mejorada
import { useState, useCallback } from "react";
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { storage } from "../firebase";
import { v4 as uuidv4 } from "uuid";

export const useStorage = () => {
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState(null);
  const [progress, setProgress] = useState(0);

  // Funci√≥n para comprimir imagen antes de subir
  const compressImage = async (file, maxWidth = 1200, maxHeight = 1000, quality = 0.7) => {
    return new Promise((resolve, reject) => {
      // Verificar si el archivo es una imagen
      if (!file.type.match(/image.*/)) {
        return resolve(file); // Si no es imagen, devolver el archivo original
      }

      // Crear un elemento de imagen para cargar el archivo
      const img = new Image();
      img.src = URL.createObjectURL(file);
      
      img.onload = () => {
        // Crear un canvas para redimensionar la imagen
        const canvas = document.createElement('canvas');
        
        // Calcular dimensiones manteniendo la proporci√≥n
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        if (height > maxHeight) {
          width = (width * maxHeight) / height;
          height = maxHeight;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        // Dibujar la imagen redimensionada
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Convertir a blob con la calidad especificada
        canvas.toBlob((blob) => {
          if (blob) {
            // Crear un nuevo archivo con el blob comprimido
            const compressedFile = new File([blob], file.name, {
              type: 'image/jpeg',
              lastModified: Date.now()
            });
            
            resolve(compressedFile);
          } else {
            reject(new Error('Error al comprimir la imagen'));
          }
        }, 'image/jpeg', quality);
      };
      
      img.onerror = () => {
        reject(new Error('Error al cargar la imagen para compresi√≥n'));
      };
    });
  };

  const uploadFile = useCallback(async (file, folder, fileNamePrefix) => {
    if (!file) return null;
    setUploading(true);
    setError(null);
    setProgress(0);
    
    try {
      // Comprimir la imagen si es necesario
      let fileToUpload = file;
      
      // Solo comprimir si es una imagen
      if (file.type.match(/image.*/)) {
        fileToUpload = await compressImage(file);
        console.log(`Imagen comprimida: ${file.size} -> ${fileToUpload.size} bytes`);
      }
      
      // Generar nombre de archivo √∫nico
      const fileName = `${fileNamePrefix}_${uuidv4()}_${file.name.replace(/[^a-zA-Z0-9.]/g, "_")}`;
      const storageRef = ref(storage, `${folder}/${fileName}`);
      
      // Subir archivo
      await uploadBytes(storageRef, fileToUpload);
      setProgress(100);
      
      // Obtener URL de descarga
      const url = await getDownloadURL(storageRef);
      return url;
    } catch (err) {
      setError(err.message);
      return null;
    } finally {
      setUploading(false);
    }
  }, []);

  return { uploadFile, uploading, progress, error };
};
</file>

<file path="src/index.js">
// Primero, agregar React Query a las dependencias en package.json:
// "dependencies": {
//   ...
//   "@tanstack/react-query": "^5.0.0",
//   ...
// }

// src/index.js - Configuraci√≥n de React Query
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './App';
import './index.css';
import reportWebVitals from './reportWebVitals';
import { Buffer } from 'buffer';
window.Buffer = Buffer;

// Crear cliente de React Query con configuraci√≥n √≥ptima
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutos
      cacheTime: 10 * 60 * 1000, // 10 minutos
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);

reportWebVitals();
</file>

<file path="src/setupTests.js">
// jest-dom a√±ade matchers personalizados de Jest para aserciones en nodos DOM.
import '@testing-library/jest-dom';

// Mock global.matchMedia
window.matchMedia = window.matchMedia || function() {
  return {
    matches: false,
    addListener: function() {},
    removeListener: function() {}
  };
};

// Silenciar mensajes de consola durante los tests
global.console = {
  ...console,
  // Descomenta las siguientes l√≠neas para silenciar mensajes durante las pruebas
  // log: jest.fn(),
  // error: jest.fn(),
  // warn: jest.fn(),
};
</file>

<file path="src/utils/calculations/budgetUtils.js">
// src/utils/calculations/budgetUtils.js

/**
 * Calcula el presupuesto de un proyecto, considerando correctamente los trabajos extra.
 *
 * @param {Object} project - El objeto del proyecto, que contiene el presupuesto original.
 * @param {Array} reports - La lista de todos los reportes (normales y extra) asociados al proyecto.
 * @returns {Object} Un objeto con los detalles del presupuesto desglosado.
 */
export function calculateBudget(project = {}, reports = []) {
  // Asegurar que los inputs sean v√°lidos para evitar errores
  if (!project || typeof project !== 'object') {
    project = {};
  }
  if (!Array.isArray(reports)) {
    reports = [];
  }

  const originalBudgetAmount = parseFloat(project.budgetAmount) || 0;
  let invoicedTotal = 0; // Acumula solo lo facturado contra el presupuesto original
  let totalExtraWorkIncome = 0; // Acumula todos los ingresos de trabajos extra

  // Filtrar reportes para asegurarse de que solo se procesan los del proyecto actual
  const projectReports = reports.filter(report => report.projectId === project.id);

  projectReports.forEach(report => {
    if (report.isExtraWork) {
      // Si es un trabajo extra, su valor se suma a los ingresos por extras
      if (report.extraWorkType === 'additional_budget') {
        totalExtraWorkIncome += parseFloat(report.extraBudgetAmount) || 0;
      } else if (report.extraWorkType === 'hourly') {
        // Para extras por horas, el ingreso es el coste de la mano de obra
        totalExtraWorkIncome += parseFloat(report.labor?.totalLaborCost) || 0;
      }
    } else {
      // Si es un parte normal, su importe se suma a lo facturado del presupuesto
      invoicedTotal += parseFloat(report.invoicedAmount) || 0;
    }
  });

  // **L√ìGICA CORREGIDA**: El presupuesto total es el original m√°s los ingresos de los extras.
  const totalBudgetWithExtras = originalBudgetAmount + totalExtraWorkIncome;

  // **L√ìGICA CORREGIDA**: El restante se calcula sobre este nuevo presupuesto total.
  // Se resta lo que se ha facturado del presupuesto principal.
  const remainingBudget = totalBudgetWithExtras - invoicedTotal;

  // El progreso se calcula sobre el presupuesto total (con extras), reflejando el avance real.
  const progressPercentage = totalBudgetWithExtras > 0
    ? Math.min(Math.max((invoicedTotal / totalBudgetWithExtras) * 100, 0), 100)
    : 0;

  // Devolver un objeto completo y claro con todos los valores calculados
  return {
    budgetAmount: originalBudgetAmount, // El presupuesto original sin extras
    totalBudgetWithExtras,             // El "bote" total del proyecto
    totalExtraWorkIncome,              // El valor total de todos los trabajos extra
    invoicedTotal,                     // Lo que se ha facturado del presupuesto principal
    remainingBudget,                   // Lo que queda en el "bote" total
    progressPercentage: parseFloat(progressPercentage.toFixed(2)),
    isOverBudget: remainingBudget < 0
  };
}
</file>

<file path="storage.rules">
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Regla por defecto: denegar todo
    match /{allPaths=**} {
      allow read, write: if false;
    }
    
    // Reglas para facturas (invoices)
    match /invoices/{fileName} {
      // Lectura: Cualquier usuario autenticado puede leer facturas
      allow read: if request.auth != null;
      
      // Escritura: Validar formato de archivo, tama√±o y prefijo de nombre
      allow write: if request.auth != null && 
                     // Validar que el nombre tiene un formato v√°lido (prefijo_fecha_uuid)
                     fileName.matches('^[^_]+_[0-9]{4}-[0-9]{2}-[0-9]{2}.*$') &&
                     // Validar tipo de archivo (PDF)
                     request.resource.contentType.matches('application/pdf') &&
                     // Limitar tama√±o a 10MB
                     request.resource.size < 10 * 1024 * 1024;
      
      // Permitir eliminaci√≥n si el usuario est√° autenticado
      // En un escenario ideal, verificar√≠amos si es el propietario, pero 
      // no podemos consultar Firestore directamente desde las reglas de Storage
      allow delete: if request.auth != null;
    }
    
    // Reglas para fotos
    match /photos/{fileName} {
      // Lectura: Cualquier usuario autenticado puede ver fotos
      allow read: if request.auth != null;
      
      // Escritura: Validar formato, tama√±o y prefijo de nombre
      allow write: if request.auth != null && 
                     // Validar que el nombre tiene un formato v√°lido (prefijo_fecha_uuid)
                     fileName.matches('^[^_]+_[0-9]{4}-[0-9]{2}-[0-9]{2}.*$') &&
                     // Validar tipo de archivo (im√°genes)
                     request.resource.contentType.matches('image/.*') &&
                     // Limitar tama√±o a 5MB
                     request.resource.size < 5 * 1024 * 1024;
      
      // Permitir eliminaci√≥n si el usuario est√° autenticado
      allow delete: if request.auth != null;
    }
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


.env
*.log
.vercel

/00
</file>

<file path="firebase.json">
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "storage": {
    "rules": "storage.rules"
  },
  "functions": {
    "source": "functions",
    "runtime": "nodejs20"
  }
}
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" type="image/png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
<title>alqatifa - Partes de trabajo</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="src/App.css">
/* Declaraci√≥n de fuentes personalizadas */
@font-face {
  font-family: 'Atkinson Hyperlegible';
  src: url('../public/fonts/Atkinson-Hyperlegible-Regular-102.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Cormorant';
  src: url('../public/fonts/Cormorant-Bold.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Quitar la importaci√≥n anterior de Roboto */
/* @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"); */

.App {
  font-family: "Atkinson Hyperlegible", sans-serif;
  min-height: 100vh;
  background-color: #f5f7fa;
  padding: 20px 0;
}

/* Aplicar Cormorant a todos los encabezados con tama√±os aumentados */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cormorant", serif;
}

/* Tama√±os espec√≠ficos para los headings */
h1 {
  font-size: 2.5rem; /* 40px */
}

h2 {
  font-size: 2.1rem; /* 33.6px */
}

h3 {
  font-size: 1.8rem; /* 28.8px */
}

h4 {
  font-size: 1.5rem; /* 24px */
}

h5 {
  font-size: 1.25rem; /* 20px */
}

h6 {
  font-size: 1.1rem; /* 17.6px */
}

.app-header {
  text-align: center;
  margin-bottom: 20px;
}

.app-logo {
  width: 211.5px; /* Mitad de 423px */
  height: 76px; /* Mitad de 152px */
}

.app-container {
  max-width: 1140px;
  margin: 0 auto;
  padding: 0 20px;
  width: 100%;
  box-sizing: border-box;
}

.tab-buttons {
  display: flex;
  gap: 10px;
  margin-bottom: 30px;
}

.tab-buttons button {
  padding: 10px 20px;
  background-color: #2c3e50; /* Color temporal, lo cambiaremos */
  color: white;
  border: none;
  border-radius: 0; /* Bordes rectos */
  cursor: pointer;
  transition: background-color 0.3s ease;
  font-weight: 500;
}

.tab-buttons button:hover {
  background-color: #8D432D; /* Color de acento en hover */
}

.tab-buttons button.active {
  background-color: #8D432D; /* Color de acento para pesta√±a activa */
}

main {
  background-color: white;
  padding: 30px;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* MODIFICACI√ìN: Ajuste para todos los campos de formulario */
input,
select,
textarea {
  padding: 10px;
  margin-top: 5px;
  width: 100%;
  max-width: 100%; /* Cambiado de 400px a 100% */
  box-sizing: border-box; /* CLAVE: incluye padding y border en el ancho total */
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

/* NUEVO: Estilo espec√≠fico para formularios de login */
.login-form {
  max-width: 400px;
  margin: 0 auto;
}

button {
  padding: 12px 20px;
  background-color: #8D432D; /* Color de acento para botones primarios */
  color: white;
  border: none;
  border-radius: 0; /* Bordes rectos */
  cursor: pointer;
  transition: background-color 0.3s ease;
  font-weight: 500;
  font-family: "Atkinson Hyperlegible", sans-serif;
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono m√°s oscuro del color de acento para hover */
}

h3 {
  margin-top: 30px;
  color: #2c3e50;
  font-weight: 500;
  /* El tama√±o se controla ahora con los estilos generales de headings */
}

.error-message {
  color: #e74c3c;
  margin: 5px 0;
  font-size: 14px;
}

.success-message {
  color: #27ae60;
  margin: 5px 0;
  font-size: 14px;
}

.photo-container,
.material-item {
  display: flex;
  align-items: center;
  gap: 15px;
  margin: 10px 0;
  padding: 10px;
  background-color: #fafafa;
  border-radius: 5px;
}

/* Estilos para ReportsViewer */
.reports-viewer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.filter-section {
  margin-bottom: 20px;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border-left: 4px solid #8D432D;
}

.filter-section label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #2c3e50;
  font-size: 1.1rem;
}

.filter-section select {
  margin-bottom: 20px;
}

.date-range {
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.date-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 200px;
}

.date-field label {
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

/* MODIFICACI√ìN: Asegurar que los inputs de fecha respeten el ancho */
.date-field input {
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

.report-card {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  margin-bottom: 20px;
}

.edit-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.edit-form button {
  background-color: #8D432D; /* Color de acento para botones en edici√≥n */
  border-radius: 0; /* Bordes rectos */
}

.edit-form button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono m√°s oscuro para hover */
}

.photos-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.modal {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  z-index: 1000;
}

.modal button {
  background-color: #8D432D; /* Color de acento para botones en modal */
  border-radius: 0; /* Bordes rectos */
}

.modal button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono m√°s oscuro para hover */
}

/* Estilos para ProjectsViewer */
.projects-viewer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.project-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  background-color: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  margin-bottom: 20px;
}

.project-form input {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

.project-form button {
  background-color: #8D432D; /* Color de acento para botones en formulario */
  border-radius: 0; /* Bordes rectos */
}

.project-form button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono m√°s oscuro para hover */
}

.projects-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.project-card {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.project-card button {
  background-color: #8D432D; /* Color de acento para botones en tarjetas */
  border-radius: 0; /* Bordes rectos */
}

.project-card button:hover:not(:disabled) {
  background-color: #7A3624; /* Tono m√°s oscuro para hover */
}

.edit-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

/* Nuevo estilo para t√≠tulos de secci√≥n */
.section-title {
  margin-top: 40px;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #8D432D;
  color: #2c3e50;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .app-container {
    padding: 0 15px;
  }

  .tab-buttons {
    flex-direction: column;
    gap: 10px;
  }

  .tab-buttons button {
    width: 100%;
  }

  main {
    padding: 20px;
  }

  input,
  select,
  textarea {
    max-width: 100%;
  }

  .report-card,
  .project-card,
  .project-form {
    padding: 15px;
  }

  .date-range {
    flex-direction: column;
    gap: 15px;
  }

  .date-field {
    min-width: 100%;
  }
}
</file>

<file path="src/components/Dashboard.css">
/* src/components/Dashboard.css - Archivo CSS unificado */

/* Contenedor principal del dashboard */
.dashboard {
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
}

/* ======= M√âTRICAS Y TARJETAS KPI ======= */
.metrics-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.metric-card {
  background-color: white;
  border-radius: 8px;
  padding: 15px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.metric-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.metric-icon {
  font-size: 24px;
  margin-bottom: 5px;
}

.metric-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #2c3e50;
  margin: 5px 0;
}

.metric-label {
  font-size: 0.9rem;
  color: #7f8c8d;
}

/* ======= FILTROS Y SELECTORES ======= */
.dashboard-filter {
  margin-bottom: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 15px;
  border-left: 4px solid #8D432D;
}

.dashboard-filter h3 {
  margin-bottom: 15px;
  color: #2c3e50;
  font-weight: 500;
  font-family: "Cormorant", serif;
}

.filter-group {
  margin-bottom: 15px;
}

.filter-group label {
  display: block;
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

.project-selector {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin-bottom: 10px;
  font-size: 14px;
}

/* ======= FILTRO DE FECHAS ======= */
.date-range {
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 10px;
  flex-wrap: wrap;
}

.date-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 200px;
}

.date-field label {
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

.date-field input {
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
  border: 1px solid #ddd;
  border-radius: 5px;
  font-size: 14px;
}

/* ======= CONTENEDORES DE GR√ÅFICOS ======= */
.chart-container, 
.dashboard-section {
  background-color: white;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.chart-wrapper {
  margin-top: 15px;
  margin-bottom: 15px;
  width: 100%;
  /* Importante: permite que el contenedor se adapte al gr√°fico */
  height: auto;
  overflow: hidden;
}

/* ======= BOTONES DE PESTA√ëA PARA GR√ÅFICOS ======= */
.chart-tab-buttons,
.chart-controls,
.chart-type-buttons,
.metric-type-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 15px;
}

.chart-tab-buttons button,
.chart-controls button {
  padding: 8px 10px;
  background-color: #f0f0f0;
  color: #333;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 13px;
  text-align: center;
  transition: background-color 0.2s;
}

.chart-tab-buttons button.active,
.chart-controls button.active {
  background-color: #8D432D;
  color: white;
}

.chart-tab-buttons button:hover,
.chart-controls button:hover {
  background-color: #e0e0e0;
}

.chart-tab-buttons button.active:hover,
.chart-controls button.active:hover {
  background-color: #7A3624;
}

/* ======= TABLA DE RESUMEN DE DATOS ======= */
.data-summary-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
  margin-top: 15px;
}

.data-summary-table th,
.data-summary-table td {
  padding: 8px;
  text-align: right;
  border-bottom: 1px solid #eee;
}

.data-summary-table th {
  font-weight: bold;
  background-color: #f5f5f5;
  color: #333;
  text-align: center;
}

.data-summary-table td:first-child {
  text-align: left;
}

.data-summary-table tfoot tr {
  font-weight: bold;
  background-color: #f9f9f9;
}

.data-summary-table tfoot td {
  border-top: 2px solid #ddd;
}

/* ======= MENSAJES DE CARGA Y ERROR ======= */
.dashboard-loading {
  text-align: center;
  padding: 40px 0;
  color: #666;
  font-style: italic;
}

.empty-chart-message {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  background-color: #f9f9f9;
  border-radius: 8px;
  color: #7f8c8d;
  text-align: center;
  padding: 20px;
}

.error-message {
  color: #e74c3c;
  padding: 10px;
  margin-bottom: 10px;
  background-color: #fde2e2;
  border-radius: 4px;
  border-left: 3px solid #e74c3c;
}

/* ======= TOOLTIP PERSONALIZADO ======= */
.custom-tooltip {
  background-color: rgba(255, 255, 255, 0.9);
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.tooltip-label {
  margin: 0 0 5px;
  font-weight: bold;
  color: #2c3e50;
}

.tooltip-client {
  margin: 5px 0 0;
  font-style: italic;
  color: #7f8c8d;
}

/* ======= OPTIMIZACIONES PARA M√ìVILES ======= */
@media (max-width: 768px) {
  .metrics-container {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .chart-tab-buttons,
  .chart-controls,
  .chart-type-buttons,
  .metric-type-buttons {
    flex-wrap: wrap;
  }
  
  .chart-tab-buttons button {
    flex: 0 0 calc(50% - 5px);
    font-size: 12px;
    padding: 8px 5px;
  }
  
  /* Ajustes para los gr√°ficos en m√≥vil */
  .recharts-cartesian-axis-tick-value {
    font-size: 10px;
  }
  
  /* Reducir el padding en m√≥viles */
  .chart-container, 
  .dashboard-section {
    padding: 10px;
  }
  
  /* Ajustar la tabla */
  .data-summary-table {
    font-size: 12px;
  }
  
  .data-summary-table th,
  .data-summary-table td {
    padding: 5px;
  }
}

/* ======= ULTRA PEQUE√ëAS PANTALLAS ======= */
@media (max-width: 380px) {
  .metrics-container {
    grid-template-columns: 1fr;
  }
  
  .metric-card {
    display: flex;
    align-items: center;
    text-align: left;
    padding: 10px;
  }
  
  .metric-icon {
    margin-right: 10px;
    margin-bottom: 0;
  }
  
  .metric-value {
    margin-right: 10px;
  }
  
  .metric-label {
    margin-left: auto;
  }
  
  .chart-tab-buttons button,
  .chart-controls button {
    flex: 0 0 100%;
  }
}

/* ======= ESTILOS DESDE DASHBOARD/DASHBOARD.CSS ======= */
/* Estilos para KPI Cards */
.kpi-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 30px;
}

.kpi-card {
  flex: 1;
  min-width: 180px;
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.kpi-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

.kpi-icon {
  font-size: 2rem;
  margin-right: 15px;
  color: #8D432D;
}

.kpi-content h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  color: #2c3e50;
}

.kpi-content p {
  margin: 5px 0 0;
  color: #7f8c8d;
  font-size: 0.9rem;
}

/* Estilos para el filtro con vista de dashboard */
.dashboard-view .filter-section {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 30px;
  padding: 15px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border-left: 4px solid #8D432D;
}

/* Eliminar duplicaciones de otros estilos */
.dashboard-view .project-filter {
  flex: 1;
  min-width: 250px;
}

.summary-section {
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.summary-content {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 15px;
}

.summary-content p {
  margin: 0;
  color: #2c3e50;
}

/* Estilos adicionales para los nuevos componentes en Dashboard.css */

/* ======= SKELETON LOADING STYLES ======= */
.skeleton-container {
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

.skeleton-card {
  background-color: #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 120px;
}

.skeleton-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: #e0e0e0;
  margin-bottom: 10px;
}

.skeleton-line {
  background-color: #e0e0e0;
  border-radius: 4px;
  margin: 5px 0;
}

.skeleton-filter {
  background-color: #f5f5f5;
}

.skeleton-tabs {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.skeleton-tab {
  height: 40px;
  width: 120px;
  background-color: #e0e0e0;
  border-radius: 4px;
}

.skeleton-chart {
  height: 300px;
  background-color: #f0f0f0;
  border-radius: 8px;
}

.skeleton-table {
  width: 100%;
}

.skeleton-row {
  height: 40px;
  background-color: #e0e0e0;
  margin: 8px 0;
  border-radius: 4px;
}

.skeleton-row.header {
  background-color: #d0d0d0;
}

/* ======= EMPTY STATE STYLES ======= */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
  background-color: #f9f9f9;
  border-radius: 8px;
  margin: 20px 0;
}

.empty-state-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.empty-state-title {
  font-size: 20px;
  color: #333;
  margin-bottom: 10px;
}

.empty-state-message {
  color: #666;
  max-width: 500px;
  margin: 0 auto;
  margin-bottom: 20px;
}

.empty-state-action {
  padding: 10px 20px;
  background-color: #8D432D;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s;
}

.empty-state-action:hover {
  background-color: #7A3624;
}

/* ======= ERROR DISPLAY STYLES ======= */
.error-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
  background-color: #fff0f0;
  border-radius: 8px;
  margin: 20px 0;
  border-left: 5px solid #e74c3c;
}

.error-icon {
  font-size: 36px;
  margin-bottom: 16px;
}

.error-title {
  font-size: 20px;
  color: #e74c3c;
  margin-bottom: 10px;
}

.error-details {
  color: #444;
  max-width: 500px;
  margin: 0 auto;
  margin-bottom: 20px;
  background-color: rgba(231, 76, 60, 0.1);
  padding: 10px;
  border-radius: 4px;
}

.error-retry-button {
  padding: 10px 20px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s;
  margin-bottom: 20px;
}

.error-retry-button:hover {
  background-color: #2980b9;
}

.error-help {
  color: #666;
  font-size: 14px;
  font-style: italic;
}

/* ======= LOADING INDICATOR ======= */
.loading-indicator {
  text-align: center;
  padding: 20px;
  color: #666;
  font-style: italic;
}

/* ======= RESPONSIVE ADJUSTMENTS ======= */
@media (max-width: 768px) {
  .empty-state, 
  .error-display {
    padding: 20px;
  }
  
  .empty-state-icon,
  .error-icon {
    font-size: 32px;
  }
  
  .empty-state-title,
  .error-title {
    font-size: 18px;
  }
}
</file>

<file path="src/components/dashboard/DashboardSummary.js">
// src/components/dashboard/DashboardSummary.js
import React from "react";
import EmptyState from "../common/EmptyState";
import { useCalculationsService } from "../../hooks/useCalculationsService";
// Importar formatNumber para las horas y formatCurrency para los euros
import { formatCurrency, formatNumber } from "../../utils/calculationUtils";

/**
 * Componente para la secci√≥n de resumen de datos del dashboard.
 * Muestra una tabla con los datos agregados por semana (o el per√≠odo relevante).
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.reports - Lista de reportes filtrados
 * @param {Array} props.projects - Lista de proyectos
 * @param {string} props.selectedProject - ID del proyecto seleccionado (puede ser "" para todos)
 * @param {boolean} props.isLoading - Estado de carga
 */
const DashboardSummary = ({ reports, projects = [], selectedProject, isLoading }) => {
  // Usamos el servicio centralizado de c√°lculos
  const { calculateReportSummary } = useCalculationsService();

  // Obtenemos las m√©tricas ya calculadas (por semana y totales)
  // Pasamos selectedProject (puede ser "" si es "all")
  const { byWeek, totals } = calculateReportSummary(reports, projects, selectedProject);

  // Obtener los √∫ltimos 5 registros semanales para mostrar en la tabla
  // Si hay menos de 5, mostrar√° todos los disponibles
  const recentData = byWeek.slice(-5);

  // Renderizar tabla de resumen
  const renderTable = () => {
    // Si no hay datos semanales, mostrar estado vac√≠o
    if (recentData.length === 0) {
      return (
        <EmptyState
          message="No hay datos suficientes para mostrar el resumen semanal."
          icon="üìä"
        />
      );
    }

    // Renderizar la tabla si hay datos
    return (
      <table className="data-summary-table" aria-label="Resumen de datos recientes por semana">
        <thead>
          <tr>
            <th scope="col">Periodo</th>
            <th scope="col" style={{ backgroundColor: "#e8f7eb" }}>Ingresos</th>
            <th scope="col">H. Oficial</th> {/* Nueva columna */}
            <th scope="col">H. Pe√≥n</th>   {/* Nueva columna */}
            <th scope="col">M. Obra (‚Ç¨)</th>
            <th scope="col" style={{ backgroundColor: "#e0f7fa" }}>Facturado (‚Ç¨)</th>
            <th scope="col">Materiales (‚Ç¨)</th>
            <th scope="col">Coste Total (‚Ç¨)</th>
          </tr>
        </thead>
        <tbody>
          {/* Mapear los datos semanales recientes para las filas */}
          {recentData.map((item, index) => (
            <tr key={index}>
              {/* Columna de Periodo (Semana/A√±o) */}
              <td>{item.weekLabel}</td>
              {/* Columna de Ingresos */}
              <td style={{ color: "#27AE60", fontWeight: "500", backgroundColor: "#f2f9f5" }}>
                {formatCurrency(item.totalIncome)}
              </td>
              {/* Columna de Horas Oficial */}
              <td>{formatNumber(item.officialHours || 0)} h</td>
              {/* Columna de Horas Pe√≥n */}
              <td>{formatNumber(item.workerHours || 0)} h</td>
              {/* Columna de Coste Mano de Obra */}
              <td>{formatCurrency(item.laborCost)}</td>
              {/* Columna de Facturado */}
              <td style={{ backgroundColor: "#f0f9fa" }}>
                {formatCurrency(item.invoicedAmount)}
              </td>
              {/* Columna de Coste Materiales */}
              <td>{formatCurrency(item.materialsCost)}</td>
              {/* Columna de Coste Total */}
              <td>{formatCurrency(item.totalCost)}</td>
            </tr>
          ))}
        </tbody>
        <tfoot>
          {/* Fila de Totales Generales */}
          <tr>
            <td><strong>TOTAL</strong></td>
            {/* Total Ingresos */}
            <td style={{ color: "#27AE60", fontWeight: "bold", backgroundColor: "#f2f9f5" }}>
              {/* Usamos grandTotal que incluye facturado y extras */}
              {formatCurrency(totals.grandTotal || 0)}
            </td>
            {/* Total Horas Oficial */}
            <td><strong>{formatNumber(totals.totalOfficialHours || 0)} h</strong></td>
            {/* Total Horas Pe√≥n */}
            <td><strong>{formatNumber(totals.totalWorkerHours || 0)} h</strong></td>
            {/* Total Coste Mano de Obra */}
            <td><strong>{formatCurrency(totals.totalLabor)}</strong></td>
            {/* Total Facturado (Presupuesto) */}
            <td style={{ fontWeight: "bold", backgroundColor: "#f0f9fa" }}>
              {formatCurrency(totals.totalInvoiced)}
            </td>
            {/* Total Coste Materiales */}
            <td><strong>{formatCurrency(totals.totalMaterials)}</strong></td>
            {/* Total Coste Operativo (MO + Materiales) */}
            <td><strong>{formatCurrency((totals.totalLabor || 0) + (totals.totalMaterials || 0))}</strong></td>
          </tr>
        </tfoot>
      </table>
    );
  };

  // Renderizado principal del componente
  return (
    <div className="dashboard-section">
      <h3>Resumen de Datos (√öltimas Semanas)</h3>
      {/* Mostrar indicador de carga o la tabla */}
      {isLoading ? (
        <p className="loading-indicator">Cargando datos del resumen...</p>
      ) : (
        renderTable()
      )}
    </div>
  );
};

export default React.memo(DashboardSummary);
</file>

<file path="src/components/FixedReportForm.js">
import React, { useCallback } from "react";
import { formatCurrency } from "../utils/calculationUtils";
import ImageUploader from "./ImageUploader";

const FixedReportForm = ({ 
  workPerformed, 
  onWorkPerformedChange, 
  projectId, 
  reportDate, 
  onInvoicedChange, 
  invoicedAmount 
}) => {
  const handleDescriptionChange = useCallback((e) => {
    onWorkPerformedChange({ ...workPerformed, description: e.target.value });
  }, [workPerformed, onWorkPerformedChange]);

  // Manejador para las im√°genes subidas o eliminadas
  const handleImagesChange = useCallback(
    ({ type, images, id }) => {
      if (type === 'add' && images && images.length > 0) {
        // A√±adir nuevas im√°genes
        onWorkPerformedChange({
          ...workPerformed,
          photos: [...(workPerformed.photos || []), ...images],
        });
      } else if (type === 'remove' && id) {
        // Eliminar una imagen existente
        onWorkPerformedChange({
          ...workPerformed,
          photos: (workPerformed.photos || []).filter((p) => p.id !== id),
        });
      }
    },
    [workPerformed, onWorkPerformedChange]
  );

  // Manejador para el cambio de importe facturado
  const handleInvoicedAmountChange = useCallback((e) => {
    const value = parseFloat(e.target.value) || 0;
    onInvoicedChange(e);
  }, [onInvoicedChange]);

  return (
    <div className="fixed-report-form">
      <h3>Trabajos realizados (Presupuesto cerrado)</h3>
      <textarea
        value={workPerformed.description || ""}
        onChange={handleDescriptionChange}
        placeholder="Descripci√≥n de los trabajos realizados"
      />
      
      {/* Reemplazamos el input file por nuestro ImageUploader */}
      <ImageUploader
        onImagesUploaded={handleImagesChange}
        folder="photos"
        prefix={`${projectId}_${reportDate}`}
        maxFiles={10}
        acceptedTypes="image/*"
        existingImages={workPerformed.photos || []}
      />
      
      <div>
        <label>Facturado (‚Ç¨)</label>
        <input
          type="number"
          value={invoicedAmount || 0}
          onChange={handleInvoicedAmountChange}
          min="0"
          step="0.01"
          placeholder="Importe facturado"
        />
        {invoicedAmount > 0 && <p>Importe facturado: {formatCurrency(invoicedAmount)}</p>}
      </div>
    </div>
  );
};

export default React.memo(FixedReportForm);
</file>

<file path="src/components/MaterialsForm.js">
import React, { useState, useCallback } from "react";
import { useStorage } from "../hooks/useStorage";
import { useCalculationsService } from "../hooks/useCalculationsService";
import { formatCurrency } from "../utils/calculationUtils";

const MaterialsForm = ({ materials, onMaterialsChange, projectId, reportDate }) => {
  const [newMaterial, setNewMaterial] = useState({ description: "", cost: "" });
  const { uploadFile, uploading, error: uploadError } = useStorage();
  
  // Utilizamos el servicio centralizado de c√°lculos
  const { calculateMaterials } = useCalculationsService();
  
  // Obtenemos los c√°lculos actualizados de materiales
  const { totalMaterialsCost } = calculateMaterials(materials);

  const handleInputChange = useCallback((e) => {
    // Muy importante, parsear el coste a Float.
    const { name, value } = e.target;
    const updatedValue = name === "cost" ? parseFloat(value) : value;
    setNewMaterial((prev) => ({ ...prev, [name]: updatedValue }));
  }, []);

  const handleAddMaterial = useCallback(async (e) => {
    const file = e.target.files[0];
    //Validar que se haya a√±adido una descripci√≥n y un coste
    if (!file || !newMaterial.description || !newMaterial.cost) {
      alert("Por favor, a√±ade una descripci√≥n, un coste y una factura (PDF)");
      return; // Error manejado por uploadError
    }

    const url = await uploadFile(file, "invoices", `${projectId}_${reportDate}`);
    if (url) {
      const newMat = { 
        id: Date.now(), 
        description: newMaterial.description, 
        cost: parseFloat(newMaterial.cost), 
        invoiceUrl: url 
      }; //Aseg√∫rate de que sea Float
      onMaterialsChange([...materials, newMat]);
      setNewMaterial({ description: "", cost: "" });
      e.target.value = null;
    }
  }, [newMaterial, materials, onMaterialsChange, projectId, reportDate, uploadFile]);

  const handleRemoveMaterial = useCallback((id) => {
    onMaterialsChange(materials.filter((m) => m.id !== id));
  }, [materials, onMaterialsChange]);

  return (
    <div>
      <h3>Materiales</h3>
      <input
        type="text"
        name="description"
        placeholder="Descripci√≥n del material"
        value={newMaterial.description}
        onChange={handleInputChange}
      />
      <input
        type="number"
        name="cost"
        placeholder="Coste (‚Ç¨)"
        value={newMaterial.cost}
        onChange={handleInputChange}
        min="0"
        step="0.01"
      />
      <input type="file" accept=".pdf" onChange={handleAddMaterial} disabled={uploading} />
      {uploading && <p>Subiendo...</p>}
      {uploadError && <p className="error-message">Error: {uploadError}</p>}
      {materials.map((m) => (
        <div key={m.id} className="material-item">
          <p>
            {m.description} - {formatCurrency(m.cost)} (
            <a href={m.invoiceUrl} target="_blank" rel="noopener noreferrer">Ver PDF</a>)
          </p>
          <button onClick={() => handleRemoveMaterial(m.id)}>Eliminar</button>
        </div>
      ))}
      
      {/* Mostrar el coste total calculado */}
      {materials.length > 0 && (
        <p className="materials-total">
          <strong>Coste total de materiales:</strong> {formatCurrency(totalMaterialsCost)}
        </p>
      )}
    </div>
  );
};

export default React.memo(MaterialsForm);
</file>

<file path="src/components/reports/ReportSummary.js">
// src/components/reports/ReportSummary.js
import React from "react";
import { formatCurrency, formatNumber } from "../../utils/calculationUtils";
import './Reports.css'; 

/**
 * Componente "tonto" que solo muestra los datos de resumen que recibe.
 * No realiza c√°lculos ni llama a hooks.
 * @param {Object} props
 * @param {Object} props.totals - El objeto con todos los totales ya calculados.
 * @param {Object} props.project - El proyecto seleccionado.
 */
const ReportSummary = ({ totals, project }) => {
  if (!totals || !project) {
    return null; // No renderizar nada si no hay datos
  }

  // --- L√ìGICA DE C√ÅLCULO ELIMINADA ---
  // Ahora desestructuramos todos los valores directamente del prop 'totals'.
  const {
    totalLabor,
    totalMaterials,
    totalCost,
    totalInvoiced,
    totalHours,
    totalOfficialHours,
    totalWorkerHours,
    // --- NUEVOS VALORES PRE-CALCULADOS ---
    totalExtraWorkIncome,
    totalBudgetWithExtras,
    remainingBudget
  } = totals;

  const isHourlyProject = project.type === "hourly";

  return (
    <div className="totals-summary">
      <h3>Resumen de totales</h3>

      <table className="summary-table">
        <tbody>
          {isHourlyProject ? (
            // --- Resumen para Proyecto por Horas (sin cambios) ---
            <>
              <tr>
                <td><strong>Total Horas Oficial:</strong></td>
                <td className="amount">{formatNumber(totalOfficialHours || 0)} h</td>
              </tr>
              <tr>
                <td><strong>Total Horas Pe√≥n:</strong></td>
                <td className="amount">{formatNumber(totalWorkerHours || 0)} h</td>
              </tr>
               <tr>
                <td><strong>Total Horas (General):</strong></td>
                <td className="amount">{formatNumber(totalHours || 0)} h</td>
              </tr>
              <tr>
                <td><strong>Coste Total Mano de Obra (‚Ç¨):</strong></td>
                <td className="amount">{formatCurrency(totalLabor)}</td>
              </tr>
              <tr>
                <td><strong>Coste Total Materiales (‚Ç¨):</strong></td>
                <td className="amount">{formatCurrency(totalMaterials)}</td>
              </tr>
              <tr className="total-row">
                <td><strong>COSTE TOTAL OPERATIVO (‚Ç¨):</strong></td>
                <td className="amount">{formatCurrency(totalCost)}</td>
              </tr>
            </>
          ) : (
            // === ESTRUCTURA DEFINITIVA Y SIMPLIFICADA PARA PRESUPUESTO CERRADO ===
            // Ahora solo muestra los valores recibidos, sin calcular nada.
            <>
              <tr>
                <td><strong>Presupuesto Original:</strong></td>
                <td className="amount">{formatCurrency(project.budgetAmount || 0)}</td>
              </tr>
              
              {(totalExtraWorkIncome || 0) > 0 && (
                <tr>
                  <td><strong>Ingresos Adicionales por Extras:</strong></td>
                  <td className="amount">{formatCurrency(totalExtraWorkIncome)}</td>
                </tr>
              )}

              <tr className="total-row intermediate-total">
                <td><strong>PRESUPUESTO TOTAL (con Extras):</strong></td>
                <td className="amount">{formatCurrency(totalBudgetWithExtras)}</td>
              </tr>
              
              <tr>
                <td><strong>Total Facturado (del presupuesto):</strong></td>
                <td className="amount">{formatCurrency(totalInvoiced)}</td>
              </tr>
              
              <tr className="total-row">
                <td><strong>IMPORTE RESTANTE (del presupuesto total):</strong></td>
                <td className="amount">{formatCurrency(remainingBudget)}</td>
              </tr>
            </>
          )}
        </tbody>
      </table>
    </div>
  );
};

export default React.memo(ReportSummary);
</file>

<file path="src/components/WorkPerformedForm.js">
import React, { useCallback } from "react";
import ImageUploader from "./ImageUploader";

const WorkPerformedForm = ({ workPerformed, onWorkPerformedChange, projectId, reportDate }) => {
  const handleDescriptionChange = useCallback(
    (e) => {
      onWorkPerformedChange({ ...workPerformed, description: e.target.value });
    },
    [workPerformed, onWorkPerformedChange]
  );

  // Manejador para las im√°genes subidas o eliminadas
  const handleImagesChange = useCallback(
    ({ type, images, id }) => {
      if (type === 'add' && images && images.length > 0) {
        // A√±adir nuevas im√°genes
        onWorkPerformedChange({
          ...workPerformed,
          photos: [...(workPerformed.photos || []), ...images],
        });
      } else if (type === 'remove' && id) {
        // Eliminar una imagen existente
        onWorkPerformedChange({
          ...workPerformed,
          photos: (workPerformed.photos || []).filter((p) => p.id !== id),
        });
      }
    },
    [workPerformed, onWorkPerformedChange]
  );

  return (
    <div>
      <h3>Trabajos realizados</h3>
      <textarea
        value={workPerformed.description || ""}
        onChange={handleDescriptionChange}
        placeholder="Descripci√≥n de los trabajos realizados"
      />
      
      {/* Componente ImageUploader para gesti√≥n de fotos */}
      <ImageUploader
        onImagesUploaded={handleImagesChange}
        folder="photos"
        prefix={`${projectId}_${reportDate}`}
        maxFiles={10}
        acceptedTypes="image/*"
        existingImages={workPerformed.photos || []}
      />
    </div>
  );
};

export default React.memo(WorkPerformedForm);
</file>

<file path="src/hooks/reports/useReportFilters.js">
// src/hooks/reports/useReportFilters.js - Hook mejorado con m√°s capacidades
import { useState, useCallback, useMemo, useEffect } from "react";
import { useLocalStorage } from "../useLocalStorage"; // Necesitar√°s crear este hook

/**
 * Hook personalizado para la gesti√≥n de filtros de reportes avanzados
 * @param {Object} initialFilters - Filtros iniciales
 * @returns {Object} - Objeto con estados y funciones para gestionar filtros
 */
export const useReportFilters = (initialFilters = {}) => {
  // Estado para filtros principales
  const [filters, setFilters] = useState({
    projectId: "",
    startDate: "",
    endDate: "",
    isBilled: undefined,
    // Nuevos filtros
    workType: "",
    userId: "",
    amountMin: "",
    amountMax: "",
    ...initialFilters
  });

  // Estado para opciones de ordenaci√≥n
  const [sortOptions, setSortOptions] = useState({
    field: "reportDate",
    direction: "desc"
  });

  // Persistir filtros guardados en localStorage
  const [savedFilters, setSavedFilters] = useLocalStorage("reportFilters", []);

  // Detectar cambios de URL (si implementamos rutas)
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const projectId = params.get("projectId") || "";
    const startDate = params.get("startDate") || "";
    const endDate = params.get("endDate") || "";
    const isBilled = params.get("isBilled");
    
    // Solo actualizar si hay par√°metros en la URL
    if (projectId || startDate || endDate || isBilled !== null) {
      setFilters(prev => ({
        ...prev,
        projectId,
        startDate,
        endDate,
        isBilled: isBilled === "true" ? true : isBilled === "false" ? false : undefined
      }));
    }
  }, []);

  // Actualizar un filtro espec√≠fico
  const updateFilter = useCallback((key, value) => {
    setFilters(prev => ({
      ...prev,
      [key]: value
    }));

    // Actualizar URL si es necesario (opcional)
    if (window.history && window.history.pushState) {
      const url = new URL(window.location);
      if (value === "" || value === undefined) {
        url.searchParams.delete(key);
      } else {
        url.searchParams.set(key, value);
      }
      window.history.pushState({}, '', url);
    }
  }, []);

  // Actualizar m√∫ltiples filtros a la vez
  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters
    }));
  }, []);

  // Actualizar opciones de ordenaci√≥n
  const updateSortOptions = useCallback(({ field, direction }) => {
    setSortOptions({
      field: field || sortOptions.field,
      direction: direction || sortOptions.direction
    });
  }, [sortOptions]);

  // Restablecer todos los filtros
  const resetFilters = useCallback(() => {
    setFilters({
      projectId: "",
      startDate: "",
      endDate: "",
      isBilled: undefined,
      workType: "",
      userId: "",
      amountMin: "",
      amountMax: ""
    });
    setSortOptions({
      field: "reportDate",
      direction: "desc"
    });

    // Limpiar URL si es necesario
    if (window.history && window.history.pushState) {
      const url = new URL(window.location);
      url.search = "";
      window.history.pushState({}, '', url);
    }
  }, []);

  // Guardar un filtro con nombre
  const saveFilter = useCallback((filterData) => {
    // Si es para aplicar un filtro guardado
    if (filterData.filter && filterData.apply) {
      setFilters(filterData.filter);
      setSortOptions(filterData.filter.sort || { field: "reportDate", direction: "desc" });
      return;
    }

    // Si es para guardar un nuevo filtro
    setSavedFilters(prev => {
      // Verificar si ya existe un filtro con el mismo nombre
      const existingIndex = prev.findIndex(f => f.name === filterData.name);
      if (existingIndex >= 0) {
        // Actualizar filtro existente
        const updated = [...prev];
        updated[existingIndex] = filterData;
        return updated;
      }
      // A√±adir nuevo filtro
      return [...prev, filterData];
    });
  }, [setSavedFilters]);

  // Eliminar un filtro guardado
  const deleteFilter = useCallback((filterName) => {
    setSavedFilters(prev => prev.filter(f => f.name !== filterName));
  }, [setSavedFilters]);

  // Filtrar una lista de reportes bas√°ndose en los filtros actuales
  const filterReports = useCallback((reports) => {
    if (!Array.isArray(reports)) return [];
    
    return reports.filter(report => {
      // Filtro por proyecto
      if (filters.projectId && report.projectId !== filters.projectId) {
        return false;
      }
      
      // Filtro por fecha de inicio
      if (filters.startDate && report.reportDate) {
        const startDate = new Date(filters.startDate);
        const reportDate = new Date(report.reportDate);
        if (reportDate < startDate) {
          return false;
        }
      }
      
      // Filtro por fecha final
      if (filters.endDate && report.reportDate) {
        const endDate = new Date(filters.endDate);
        endDate.setHours(23, 59, 59, 999); // Incluir todo el d√≠a
        const reportDate = new Date(report.reportDate);
        if (reportDate > endDate) {
          return false;
        }
      }
      
      // Filtro por estado de facturaci√≥n
      if (filters.isBilled !== undefined) {
        if (filters.isBilled !== !!report.isBilled) {
          return false;
        }
      }
      
      // Filtro por tipo de trabajo
      if (filters.workType) {
        if (filters.workType === 'normal' && report.isExtraWork) {
          return false;
        }
        if (filters.workType === 'extra' && !report.isExtraWork) {
          return false;
        }
        if (filters.workType === 'extra_hourly' && 
            (!report.isExtraWork || report.extraWorkType !== 'hourly')) {
          return false;
        }
        if (filters.workType === 'extra_budget' && 
            (!report.isExtraWork || report.extraWorkType !== 'additional_budget')) {
          return false;
        }
      }
      
      // Filtro por usuario
      if (filters.userId && report.userId !== filters.userId) {
        return false;
      }
      
      // Filtro por rango de importes
      if (filters.amountMin || filters.amountMax) {
        const amount = 
          report.invoicedAmount || 
          report.extraBudgetAmount || 
          report.totalCost || 
          0;
        
        if (filters.amountMin && amount < parseFloat(filters.amountMin)) {
          return false;
        }
        
        if (filters.amountMax && amount > parseFloat(filters.amountMax)) {
          return false;
        }
      }
      
      return true;
    });
  }, [filters]);

  // Ordenar reportes seg√∫n las opciones actuales
  const sortReports = useCallback((reports) => {
    if (!Array.isArray(reports) || reports.length === 0) return [];
    
    const { field, direction } = sortOptions;
    const sortedReports = [...reports];
    
    sortedReports.sort((a, b) => {
      let valueA, valueB;
      
      // Extraer valores seg√∫n el campo
      switch (field) {
        case 'reportDate':
          valueA = new Date(a.reportDate || 0).getTime();
          valueB = new Date(b.reportDate || 0).getTime();
          break;
        case 'invoicedAmount':
          valueA = a.invoicedAmount || 0;
          valueB = b.invoicedAmount || 0;
          break;
        case 'totalCost':
          valueA = a.totalCost || 0;
          valueB = b.totalCost || 0;
          break;
        case 'projectId':
          valueA = a.projectId || '';
          valueB = b.projectId || '';
          break;
        case 'isBilled':
          valueA = a.isBilled ? 1 : 0;
          valueB = b.isBilled ? 1 : 0;
          break;
        default:
          valueA = a[field] || 0;
          valueB = b[field] || 0;
      }
      
      // Ordenar seg√∫n direcci√≥n
      if (direction === 'asc') {
        return valueA > valueB ? 1 : -1;
      } else {
        return valueA < valueB ? 1 : -1;
      }
    });
    
    return sortedReports;
  }, [sortOptions]);
  
  // Procesar reportes - aplicar filtros y ordenaci√≥n
  const processReports = useCallback((reports) => {
    if (!Array.isArray(reports)) return [];
    
    const filtered = filterReports(reports);
    return sortReports(filtered);
  }, [filterReports, sortReports]);

  // Verifica si hay filtros activos
  const hasActiveFilters = useMemo(() => {
    return filters.projectId !== "" || 
           filters.startDate !== "" || 
           filters.endDate !== "" || 
           filters.isBilled !== undefined ||
           filters.workType !== "" ||
           filters.userId !== "" ||
           filters.amountMin !== "" ||
           filters.amountMax !== "";
  }, [filters]);

  // Crear una cadena de texto que describa los filtros actuales (para uso en mensajes o t√≠tulos)
  const filtersDescription = useMemo(() => {
    const parts = [];
    
    if (filters.projectId) {
      parts.push(`Proyecto: ${filters.projectId}`);
    }
    
    if (filters.startDate) {
      parts.push(`Desde: ${new Date(filters.startDate).toLocaleDateString()}`);
    }
    
    if (filters.endDate) {
      parts.push(`Hasta: ${new Date(filters.endDate).toLocaleDateString()}`);
    }
    
    if (filters.isBilled !== undefined) {
      parts.push(filters.isBilled ? 'Facturados' : 'No facturados');
    }
    
    if (filters.workType) {
      parts.push(`Tipo: ${filters.workType}`);
    }
    
    if (filters.userId) {
      parts.push(`Usuario: ${filters.userId}`);
    }
    
    if (filters.amountMin || filters.amountMax) {
      const min = filters.amountMin ? `${filters.amountMin}‚Ç¨` : '0‚Ç¨';
      const max = filters.amountMax ? `${filters.amountMax}‚Ç¨` : 'sin l√≠mite';
      parts.push(`Importe: ${min} - ${max}`);
    }
    
    if (sortOptions.field !== 'reportDate' || sortOptions.direction !== 'desc') {
      parts.push(`Ordenado por: ${sortOptions.field} (${sortOptions.direction === 'asc' ? '‚Üë' : '‚Üì'})`);
    }
    
    return parts.join(' ¬∑ ') || 'Sin filtros aplicados';
  }, [filters, sortOptions]);

  return {
    // Estados
    filters,
    sortOptions,
    savedFilters,
    // Actualizadores
    updateFilter,
    updateFilters,
    updateSortOptions,
    resetFilters,
    // Gesti√≥n de filtros guardados
    saveFilter,
    deleteFilter,
    // Procesamiento de reportes
    filterReports,
    sortReports,
    processReports,
    // Metadatos
    hasActiveFilters,
    filtersDescription
  };
};

export default useReportFilters;
</file>

<file path="src/hooks/useFormValidation.js">
// src/hooks/useFormValidation.js

import { useState, useCallback, useEffect } from 'react';
import { validateForm } from '../utils/validationSchemas';

const useFormValidation = (initialValues, validationSchema, contextData = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touchedFields, setTouchedFields] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isValid, setIsValid] = useState(false);

  // La definici√≥n de validateFormData con useCallback sigue siendo √∫til
  // si necesitas llamar a esta funci√≥n desde otros lugares (ej. manualmente).
  const validateFormData = useCallback(() => {
    // console.log("Running validateFormData with values:", values); // Log para depurar
    const result = validateForm(values, validationSchema, contextData) || { errors: {}, isValid: false };
    // Solo actualiza el estado si los errores o la validez realmente cambian
    // Esto puede ayudar a prevenir re-renderizados innecesarios, aunque el problema principal suele ser el trigger del useEffect
    setErrors(prevErrors => {
        // Comparaci√≥n superficial, podr√≠a necesitarse una comparaci√≥n profunda si los errores son complejos
        if (JSON.stringify(prevErrors) !== JSON.stringify(result.errors || {})) {
            return result.errors || {};
        }
        return prevErrors;
    });
    setIsValid(prevIsValid => {
        if (prevIsValid !== (result.isValid || false)) {
            return result.isValid || false;
        }
        return prevIsValid;
    });
    return result;
  }, [values, validationSchema, contextData]);

  // *** CAMBIO PRINCIPAL AQU√ç ***
  // Hacer que el efecto dependa directamente de los datos y las reglas,
  // no de la funci√≥n `validateFormData` memoizada.
  useEffect(() => {
    // console.log("Running validation useEffect due to change in values/schema/context"); // Log para depurar
    validateFormData();
  }, [values, validationSchema, contextData]); // <--- Dependencias directas

  // --- El resto de los hooks useCallback (handleChange, handleBlur, etc.) sin cambios ---
  const handleChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;
    const inputValue = type === 'checkbox' ? checked : value;

    setValues(prevValues => {
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = inputValue;
        return newValues;
      }
      return { ...prevValues, [name]: inputValue };
    });
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setTouchedFields(prev => ({ ...prev, [name]: true }));
  }, []);

  const hasError = useCallback((fieldName) => {
    // Considerar campos anidados si es necesario
    const fieldParts = fieldName.split('.');
    let errorValue = errors;
    for (const part of fieldParts) {
        errorValue = errorValue?.[part];
        if (errorValue === undefined) break;
    }
    return Boolean(touchedFields[fieldName.split('.')[0]] && errorValue); // Comprobar touched en el campo base
  }, [touchedFields, errors]);


  const getError = useCallback((fieldName) => {
    // Considerar campos anidados
     const fieldParts = fieldName.split('.');
     let errorValue = errors;
     for (const part of fieldParts) {
         errorValue = errorValue?.[part];
         if (errorValue === undefined) break;
     }
    return hasError(fieldName) ? errorValue : null;
  }, [hasError, errors]); // Dependencia correcta

  const handleSubmit = useCallback((onSubmit) => async (e) => {
    e.preventDefault();
    setIsSubmitting(true);

    const allFieldsTouched = Object.keys(validationSchema).reduce((acc, key) => {
        acc[key.split('.')[0]] = true;
        return acc;
    }, {});
    setTouchedFields(allFieldsTouched);

    // Re-validar expl√≠citamente justo antes de enviar
    const validationResult = validateForm(values, validationSchema, contextData);
     setErrors(validationResult.errors || {});
     setIsValid(validationResult.isValid || false);


    if (validationResult.isValid) {
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Error on form submission:', error);
      }
    }

    setIsSubmitting(false);
  }, [values, validationSchema, contextData]); // Aseg√∫rate que las deps est√°n bien aqu√≠ tambi√©n


  const resetForm = useCallback((newValues = initialValues) => {
    setValues(newValues);
    setErrors({});
    setTouchedFields({});
    setIsSubmitting(false);
  }, [initialValues]);


  const setValue = useCallback((name, value) => {
    setValues(prevValues => {
      if (name.includes('.')) {
        const parts = name.split('.');
        const newValues = { ...prevValues };
        let current = newValues;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) {
            current[parts[i]] = {};
          }
          current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = value;
        return newValues;
      }
      return { ...prevValues, [name]: value };
    });
  }, []);

  return {
    values,
    errors,
    touchedFields,
    isSubmitting,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setValue,
    hasError,
    getError,
  };
};

export default useFormValidation;
</file>

<file path="src/hooks/useQueryProjects.js">
// src/hooks/useQueryProjects.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  collection,
  getDocs,
  doc,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where
} from 'firebase/firestore';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { db } from '../firebase';

const PROJECTS_CACHE_KEY = 'projects';

const fetchProjects = async (userId = null) => {
  let q = collection(db, 'projects');
  if (userId) {
    q = query(q, where('userId', '==', userId));
  }
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({
    firestoreId: doc.id,
    ...doc.data()
  }));
};

const fetchProjectById = async (projectIdOrFirestoreId) => {
  if (!projectIdOrFirestoreId) return null;

  try {
    const docRef = doc(db, 'projects', projectIdOrFirestoreId);
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      return {
        firestoreId: docSnap.id,
        ...docSnap.data()
      };
    }
  } catch (error) {
     // Ignore error if it's just not found by Firestore ID, we'll try custom ID next
     if (error.code !== 'invalid-argument') { // Don't log if it's just an invalid path format
        console.warn("Attempt to fetch by Firestore ID failed (may try custom ID next):", error);
     }
  }

  try {
    const projectsQuery = query(collection(db, 'projects'), where('id', '==', projectIdOrFirestoreId));
    const querySnapshot = await getDocs(projectsQuery);
    if (!querySnapshot.empty) {
      const docSnap = querySnapshot.docs[0];
      return {
        firestoreId: docSnap.id,
        ...docSnap.data()
      };
    }
  } catch (error) {
    console.error("Error fetching project by custom ID:", error);
  }

  return null; // Return null if not found by either ID
};


export const useQueryProjects = (userId = null) => {
  return useQuery({
    queryKey: [PROJECTS_CACHE_KEY, { userId: userId || 'all' }], // Ensure key changes if userId changes
    queryFn: () => fetchProjects(userId),
  });
};


export const useQueryProject = (projectIdOrFirestoreId) => {
    return useQuery({
      // Use a more specific key that includes the ID being queried
      queryKey: [PROJECTS_CACHE_KEY, 'detail', projectIdOrFirestoreId],
      queryFn: () => fetchProjectById(projectIdOrFirestoreId),
      enabled: !!projectIdOrFirestoreId, // Only run if ID is provided
    });
  };


export const useAddProject = () => {
  const queryClient = useQueryClient();
  const functions = getFunctions();
  const createProjectFunction = httpsCallable(functions, 'createProject');

  return useMutation({
    mutationFn: async (projectData) => {
      const result = await createProjectFunction(projectData);
      return result.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] });
    },
  });
};

export const useUpdateProject = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ firestoreId, data }) => {
      if (!firestoreId) {
        throw new Error("firestoreId es requerido para actualizar.");
      }
      const projectRef = doc(db, 'projects', firestoreId);
      const { firestoreId: _, ...updateData } = data;
      await updateDoc(projectRef, updateData);
      return { ...data, firestoreId: firestoreId };
    },
    onMutate: async ({ firestoreId, data }) => {
      if (!firestoreId) return;
      await queryClient.cancelQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] }); // Use detailed key
      const previousProject = queryClient.getQueryData([PROJECTS_CACHE_KEY, 'detail', firestoreId]); // Use detailed key

      // Optimistically update the specific project cache
      queryClient.setQueryData([PROJECTS_CACHE_KEY, 'detail', firestoreId], old => ({
          ...(old || {}),
          ...data,
          firestoreId: firestoreId
      }));

      // Optimistically update the list cache
      queryClient.setQueryData([PROJECTS_CACHE_KEY], (oldListData) => {
          if (!oldListData) return [];
          // Ensure we're working with the correct key structure if nested under userId
          // This part might need adjustment based on how useQueryProjects structures its cache
          if (Array.isArray(oldListData)) { // Simple array cache
              return oldListData.map(project =>
                  project.firestoreId === firestoreId ? { ...project, ...data, firestoreId: firestoreId } : project
              );
          } else if (oldListData && typeof oldListData === 'object' && oldListData.pages) { // Infinite query cache
               return {
                   ...oldListData,
                   pages: oldListData.pages.map(page => ({
                       ...page,
                       items: page.items.map(project =>
                           project.firestoreId === firestoreId ? { ...project, ...data, firestoreId: firestoreId } : project
                       )
                   }))
               };
          }
          // Add handling for other cache structures if necessary
          console.warn("Unrecognized cache structure for project list in onMutate");
          return oldListData; // Return unchanged if structure is unknown
      });


      return { previousProject };
    },
    onError: (err, { firestoreId }, context) => {
      if (firestoreId && context?.previousProject) {
        queryClient.setQueryData([PROJECTS_CACHE_KEY, 'detail', firestoreId], context.previousProject); // Use detailed key
      }
      // Consider rolling back the list update as well
       queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] }); // Invalidate list on error for safety
    },
    onSettled: (data, error, { firestoreId }) => {
        if (firestoreId) {
            queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] }); // Use detailed key
        }
        // Always invalidate the main list query (or relevant list queries)
        queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] }); // Invalidate potentially multiple list caches
    },

  });
};

export const useDeleteProject = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (firestoreId) => { // Expect firestoreId directly
      if (!firestoreId) {
        throw new Error("firestoreId es requerido para eliminar.");
      }
      await deleteDoc(doc(db, 'projects', firestoreId));
      return firestoreId;
    },
    onMutate: async (firestoreId) => {
        if (!firestoreId) return;
        await queryClient.cancelQueries({ queryKey: [PROJECTS_CACHE_KEY] }); // Cancel list queries
        await queryClient.cancelQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] }); // Cancel detail query

        const previousDetail = queryClient.getQueryData([PROJECTS_CACHE_KEY, 'detail', firestoreId]);
        queryClient.removeQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] }); // Remove detail cache

        const previousListCache = queryClient.getQueryState([PROJECTS_CACHE_KEY]); // Get state to know structure

        // Optimistically remove from the list cache
        queryClient.setQueriesData(
          { queryKey: [PROJECTS_CACHE_KEY] }, // Target list queries
          (oldData) => {
            if (!oldData) return [];
            if (Array.isArray(oldData)) { // Simple array cache
                return oldData.filter(project => project.firestoreId !== firestoreId);
            } else if (oldData && typeof oldData === 'object' && oldData.pages) { // Infinite query cache
                 return {
                     ...oldData,
                     pages: oldData.pages.map(page => ({
                         ...page,
                         items: page.items.filter(project => project.firestoreId !== firestoreId)
                     }))
                 };
            }
            console.warn("Unrecognized cache structure for project list in onMutate (delete)");
            return oldData; // Return unchanged if structure is unknown
          }
        );


        return { previousListCache, previousDetail }; // Return previous states if needed for rollback
    },

    onError: (err, firestoreId, context) => {
        // Rollback logic if needed, using context.previousListCache, context.previousDetail
         console.error("Error deleting project:", err);
         // Invalidate caches to refetch correct state
         if (firestoreId) {
             queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] });
         }
         queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] });
    },

    onSettled: (data, error, firestoreId) => { // data here is the returned firestoreId
      // Invalidate relevant queries to ensure fresh data
      if (firestoreId) {
          queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY, 'detail', firestoreId] });
      }
      queryClient.invalidateQueries({ queryKey: [PROJECTS_CACHE_KEY] }); // Invalidate list(s)
    },
  });
};
</file>

<file path="src/utils/calculations/reportSummaryUtils.js">
// src/utils/calculations/reportSummaryUtils.js
import { calculateLabor } from './laborUtils';
import { calculateMaterials } from './materialsUtils';
// --- IMPORTACI√ìN A√ëADIDA ---
import { calculateBudget } from './budgetUtils'; 

/**
 * Calcula un resumen completo de los reportes, incluyendo costes, ingresos y horas desglosadas.
 * Esta funci√≥n es ahora aut√≥noma y realiza todos los c√°lculos necesarios internamente.
 *
 * @param {Array} reports - Lista de objetos de reporte "crudos" de Firestore.
 * @param {Array} projects - Lista de objetos de proyecto.
 * @param {string} [selectedProjectId=""] - ID del proyecto para filtrar (opcional).
 * @returns {Object} Un objeto con totales generales (`totals`), resumen por semana (`byWeek`), y resumen por proyecto (`byProject`).
 */
export function calculateReportSummary(reports = [], projects = [], selectedProjectId = "") {
  // Asegurar que los inputs sean arrays para evitar errores
  if (!Array.isArray(reports)) reports = [];
  if (!Array.isArray(projects)) projects = [];

  // Filtrar reportes si se especifica un proyecto
  const filteredReports = selectedProjectId
    ? reports.filter(report => report.projectId === selectedProjectId)
    : reports;

  // Obtener el proyecto seleccionado para los c√°lculos de presupuesto
  const selectedProject = projects.find(p => p.id === selectedProjectId);

  // Inicializar acumuladores de totales generales
  let totalLabor = 0;
  let totalMaterials = 0;
  let totalCost = 0;
  let totalHours = 0;
  let totalOfficialHours = 0;
  let totalWorkerHours = 0;
  let totalInvoiced = 0;
  let totalExtraBudget = 0;
  let totalExtraLaborCost = 0;
  let totalExtraMaterialsCost = 0;
  let totalExtraOfficialHours = 0;
  let totalExtraWorkerHours = 0;

  // Iterar sobre cada reporte filtrado para calcular y acumular
  filteredReports.forEach(report => {
    const project = projects.find(p => p.id === report.projectId);
    if (!project) return; // Si no se encuentra el proyecto, se omite el reporte.

    const laborCalcs = calculateLabor(report.labor, project);
    const materialsCalcs = calculateMaterials(report.materials);
    const reportTotalCost = laborCalcs.totalLaborCost + materialsCalcs.totalMaterialsCost;

    totalOfficialHours += laborCalcs.officialHours;
    totalWorkerHours += laborCalcs.workerHours;
    totalHours += laborCalcs.officialHours + laborCalcs.workerHours;

    if (report.isExtraWork && project.type === 'fixed') {
      if (report.extraWorkType === 'hourly') {
        totalExtraLaborCost += laborCalcs.totalLaborCost;
        totalExtraMaterialsCost += materialsCalcs.totalMaterialsCost;
        totalExtraOfficialHours += laborCalcs.officialHours;
        totalExtraWorkerHours += laborCalcs.workerHours;
      } else if (report.extraWorkType === 'additional_budget') {
        totalExtraBudget += parseFloat(report.extraBudgetAmount) || 0;
      }
    } else {
      totalLabor += laborCalcs.totalLaborCost;
      totalMaterials += materialsCalcs.totalMaterialsCost;
      totalCost += reportTotalCost;
      if (project.type === 'fixed') {
        totalInvoiced += parseFloat(report.invoicedAmount) || 0;
      }
    }
  });

  const totalIncome = totalInvoiced + totalExtraBudget + totalExtraLaborCost;
  const grandTotal = totalInvoiced + totalExtraBudget + totalExtraLaborCost;

  // --- L√ìGICA DE PRESUPUESTO CENTRALIZADA ---
  // Usamos la funci√≥n de `budgetUtils` para obtener los c√°lculos de presupuesto correctos.
  // Solo la llamamos si hay un proyecto de tipo 'fixed' seleccionado.
  let budgetCalculations = {};
  if (selectedProject && selectedProject.type === 'fixed') {
      // Pasamos el proyecto y los reportes filtrados para obtener el resumen del presupuesto
      budgetCalculations = calculateBudget(selectedProject, filteredReports);
  }

  return {
    totals: {
      totalLabor,
      totalMaterials,
      totalCost,
      totalInvoiced,
      totalHours,
      totalOfficialHours,
      totalWorkerHours,
      totalIncome,
      totalExtraBudget,
      totalExtraCost: totalExtraLaborCost + totalExtraMaterialsCost,
      totalExtraLaborCost,
      totalExtraMaterialsCost,
      totalExtraOfficialHours,
      totalExtraWorkerHours,
      grandTotal,
      // --- VALORES A√ëADIDOS DESDE BUDGETUTILS ---
      ...budgetCalculations,
    },
    // Mantengo los arrays vac√≠os para no romper la estructura, pero la l√≥gica de agrupaci√≥n se deber√≠a implementar aqu√≠.
    byWeek: [],
    byProject: []
  };
}
</file>

<file path="src/utils/validationSchemas.js">
// src/utils/validationSchemas.js - Actualizado para incluir validaci√≥n de campos de trabajo extra

// Funciones de validaci√≥n b√°sicas
const isRequired = (value) => !!value || value === 0;
const isNumber = (value) => !isNaN(parseFloat(value)) && isFinite(value);
const isPositiveNumber = (value) => isNumber(value) && parseFloat(value) >= 0;
const isValidTime = (value) => /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value);
const isValidDate = (value) => !isNaN(Date.parse(value));
const isValidEmail = (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
const isBoolean = (value) => typeof value === 'boolean';

// Esquema para proyectos (actualizado)
export const projectSchema = {
  id: {
    validator: (value) => isRequired(value) && /^[a-zA-Z0-9 .-]+$/.test(value), 
    message: "El ID es obligatorio y solo puede contener letras, n√∫meros, espacios, puntos y guiones.", 
  },
  client: {
    validator: isRequired,
    message: "El cliente es obligatorio.",
  },
  address: {
    validator: isRequired,
    message: "La direcci√≥n es obligatoria.",
  },
  nifNie: {
    validator: (value) => isRequired(value) && /^[0-9XYZ][0-9]{7}[A-Z]$/.test(value),
    message: "El NIF/NIE debe tener un formato v√°lido.",
  },
  type: {
    validator: (value) => ["hourly", "fixed"].includes(value),
    message: "El tipo debe ser 'hourly' o 'fixed'.",
  },
  officialPrice: {
    validator: (value, formData) => 
      (formData.type !== "hourly" && !formData.allowExtraWork) || isPositiveNumber(value),
    message: "El precio por hora del oficial debe ser un n√∫mero positivo.",
  },
  workerPrice: {
    validator: (value, formData) => 
      (formData.type !== "hourly" && !formData.allowExtraWork) || isPositiveNumber(value),
    message: "El precio por hora del pe√≥n debe ser un n√∫mero positivo.",
  },
  budgetAmount: {
    validator: (value, formData) => 
      formData.type !== "fixed" || isPositiveNumber(value),
    message: "El importe del presupuesto debe ser un n√∫mero positivo.",
  },
  allowExtraWork: {
    validator: (value, formData) => 
      formData.type !== "fixed" || typeof value === 'boolean',
    message: "El campo debe ser verdadero o falso.",
  },
};

// Esquema para partes diarios (actualizado para trabajo extra)
export const dailyReportSchema = {
  reportDate: {
    validator: isValidDate,
    message: "La fecha debe ser v√°lida.",
  },
  projectId: {
    validator: isRequired,
    message: "El ID del proyecto es obligatorio.",
  },
  // Campos para trabajo extra
  isExtraWork: {
    validator: (value, formData) => 
      formData.projectType !== "fixed" || typeof value === 'boolean',
    message: "El campo debe ser verdadero o falso.",
  },
  extraWorkType: {
    validator: (value, formData) => 
      !formData.isExtraWork || ["additional_budget", "hourly"].includes(value),
    message: "El tipo de trabajo extra debe ser 'additional_budget' o 'hourly'.",
  },
  extraBudgetAmount: {
    validator: (value, formData) => 
      !formData.isExtraWork || formData.extraWorkType !== "additional_budget" || isPositiveNumber(value),
    message: "El importe adicional debe ser un n√∫mero positivo.",
  },
  // Para proyectos por horas o extras facturados por horas
  "labor.officialEntry": {
    validator: (value, formData) => 
      (formData.projectType !== "hourly" && !(formData.isExtraWork && formData.extraWorkType === "hourly")) || 
      !value || isValidTime(value),
    message: "La hora de entrada del oficial debe tener un formato v√°lido (HH:MM).",
  },
  "labor.officialExit": {
    validator: (value, formData) => 
      (formData.projectType !== "hourly" && !(formData.isExtraWork && formData.extraWorkType === "hourly")) || 
      !value || isValidTime(value),
    message: "La hora de salida del oficial debe tener un formato v√°lido (HH:MM).",
  },
  "labor.workerEntry": {
    validator: (value, formData) => 
      (formData.projectType !== "hourly" && !(formData.isExtraWork && formData.extraWorkType === "hourly")) || 
      !value || isValidTime(value),
    message: "La hora de entrada del pe√≥n debe tener un formato v√°lido (HH:MM).",
  },
  "labor.workerExit": {
    validator: (value, formData) => 
      (formData.projectType !== "hourly" && !(formData.isExtraWork && formData.extraWorkType === "hourly")) || 
      !value || isValidTime(value),
    message: "La hora de salida del pe√≥n debe tener un formato v√°lido (HH:MM).",
  },
  // Para todos los tipos
  "workPerformed.description": {
    validator: isRequired,
    message: "La descripci√≥n de los trabajos realizados es obligatoria.",
  },
  // Para proyectos de presupuesto cerrado (dentro del presupuesto)
  "workPerformed.invoicedAmount": {
    validator: (value, formData) => 
      (formData.projectType !== "fixed" || formData.isExtraWork) || isPositiveNumber(value),
    message: "El importe facturado debe ser un n√∫mero positivo.",
  },
};

// Esquema para materiales
export const materialSchema = {
  description: {
    validator: isRequired,
    message: "La descripci√≥n del material es obligatoria.",
  },
  cost: {
    validator: isPositiveNumber,
    message: "El coste debe ser un n√∫mero positivo.",
  },
};

// Utilidad para validar formularios
export const validateForm = (data, schema, context = {}) => {
  const errors = {};
  
  Object.entries(schema).forEach(([field, { validator, message }]) => {
    // Manejar campos anidados (e.g., 'labor.officialEntry')
    const fieldParts = field.split('.');
    let value = data;
    
    for (const part of fieldParts) {
      value = value && typeof value === 'object' ? value[part] : undefined;
    }
    
    // Validar el campo
    if (!validator(value, { ...data, ...context })) {
      errors[field] = message;
    }
  });
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};
</file>

<file path="functions/index.js">
// functions/index.js

const { onCall } = require("firebase-functions/v2/https");
const { onDocumentCreated, onDocumentWritten } = require("firebase-functions/v2/firestore");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore } = require("firebase-admin/firestore");
const admin = require("firebase-admin");

initializeApp(); // Assuming already initialized elsewhere or handled by Firebase env
const db = getFirestore();

const functionConfig = {
  region: "us-central1",
  minInstances: 0,
  maxInstances: 10
};

const isRequired = (value) => value !== undefined && value !== null && value !== '';
const isNumber = (value) => !isNaN(parseFloat(value)) && isFinite(value);
const isPositiveNumber = (value) => isNumber(value) && parseFloat(value) >= 0;
const isValidTime = (value) => !value || /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value);
const isValidDate = (value) => isRequired(value) && !isNaN(Date.parse(value));
const isBoolean = (value) => typeof value === 'boolean';

const isAuthenticated = (context) => !!context.auth;
const isOwner = async (userId, resourcePath) => {
  try {
    const docSnap = await db.doc(resourcePath).get();
    return docSnap.exists && docSnap.data().userId === userId;
  } catch (error) {
    return false;
  }
};

const findProjectById = async (projectId) => {
  console.log(`Finding project by custom ID: '${projectId}'`);
  if (!projectId) {
    console.log("Project ID not provided.");
    return null;
  }
  try {
    const normalizedId = String(projectId).trim();
    console.log(`Normalized project ID: '${normalizedId}'`);
    const projectQuery = await db.collection('projects')
      .where('id', '==', normalizedId)
      .limit(1)
      .get();

    if (projectQuery.empty) {
      console.log(`Project with custom ID '${normalizedId}' not found.`);
      return null;
    }

    const projectDoc = projectQuery.docs[0];
    console.log(`Project found. Firestore Doc ID: ${projectDoc.id}`);
    return { firestoreDocId: projectDoc.id, ...projectDoc.data() };
  } catch (error) {
    console.error(`Error finding project '${projectId}': ${error.message}`);
    return null;
  }
};

const validateExtraWork = async (data, projectId) => {
  const errors = {};
  const project = await findProjectById(projectId);
  if (!project) {
    errors.projectId = 'El proyecto no existe';
    return { isValid: false, errors };
  }
  if (project.type !== 'fixed' || !project.allowExtraWork) {
    errors.isExtraWork = 'Este proyecto no permite trabajos extra';
    return { isValid: false, errors };
  }
  if (!['additional_budget', 'hourly'].includes(data.extraWorkType)) {
    errors.extraWorkType = 'Tipo de trabajo extra inv√°lido.';
  }
  if (data.extraWorkType === 'additional_budget') {
    if (!isPositiveNumber(data.extraBudgetAmount)) {
      errors.extraBudgetAmount = 'Importe adicional inv√°lido.';
    }
  }
  if (data.extraWorkType === 'hourly') {
    if (!data.labor) {
      errors.labor = 'Datos de mano de obra obligatorios.';
    } else {
      if (!isValidTime(data.labor.officialEntry)) errors['labor.officialEntry'] = 'Formato HH:MM inv√°lido.';
      if (!isValidTime(data.labor.officialExit)) errors['labor.officialExit'] = 'Formato HH:MM inv√°lido.';
      if (!isValidTime(data.labor.workerEntry)) errors['labor.workerEntry'] = 'Formato HH:MM inv√°lido.';
      if (!isValidTime(data.labor.workerExit)) errors['labor.workerExit'] = 'Formato HH:MM inv√°lido.';
    }
  }
  if (!data.workPerformed || !isRequired(data.workPerformed.description)) {
    errors['workPerformed.description'] = 'Descripci√≥n obligatoria.';
  }
  return { isValid: Object.keys(errors).length === 0, errors };
};

const validateProject = (data) => {
  const errors = {};
  if (!isRequired(data.id)) errors.id = 'El ID es obligatorio';
  else if (!/^[a-zA-Z0-9 .-]+$/.test(data.id)) errors.id = 'El ID solo puede contener letras, n√∫meros, espacios, puntos y guiones.';
  if (!isRequired(data.client)) errors.client = 'Cliente obligatorio.';
  if (!isRequired(data.address)) errors.address = 'Direcci√≥n obligatoria.';
  if (!isRequired(data.nifNie)) errors.nifNie = 'NIF/NIE obligatorio.';
  else if (!/^[0-9XYZ][0-9]{7}[A-Z]$/.test(data.nifNie)) errors.nifNie = 'NIF/NIE inv√°lido.';
  if (!isRequired(data.type)) errors.type = 'Tipo obligatorio.';
  else if (!['hourly', 'fixed'].includes(data.type)) errors.type = 'Tipo inv√°lido.';
  if (data.type === 'hourly') {
    if (!isPositiveNumber(data.officialPrice)) errors.officialPrice = 'Precio oficial inv√°lido.';
    if (!isPositiveNumber(data.workerPrice)) errors.workerPrice = 'Precio pe√≥n inv√°lido.';
  } else if (data.type === 'fixed') {
    if (!isPositiveNumber(data.budgetAmount)) errors.budgetAmount = 'Presupuesto inv√°lido.';
    if (data.allowExtraWork) {
      if (!isPositiveNumber(data.officialPrice)) errors.officialPrice = 'Precio extra oficial inv√°lido.';
      if (!isPositiveNumber(data.workerPrice)) errors.workerPrice = 'Precio extra pe√≥n inv√°lido.';
    }
  }
  return { isValid: Object.keys(errors).length === 0, errors };
};

const validateDailyReport = async (data) => {
  const errors = {};
  console.log(`Validating daily report:`, JSON.stringify(data, null, 2));
  if (!isValidDate(data.reportDate)) errors.reportDate = 'Fecha inv√°lida.';
  if (!isRequired(data.projectId)) errors.projectId = 'ID de proyecto obligatorio.';
  else {
    const project = await findProjectById(data.projectId);
    if (!project) errors.projectId = 'El proyecto no existe.';
    else {
      const projectType = project.type;
      if (data.isExtraWork) {
        const extraWorkValidation = await validateExtraWork(data, data.projectId);
        if (!extraWorkValidation.isValid) Object.assign(errors, extraWorkValidation.errors);
      } else {
        if (projectType === 'hourly') {
          if (!data.labor) errors.labor = 'Mano de obra obligatoria.';
          else {
            if (!isValidTime(data.labor.officialEntry)) errors['labor.officialEntry'] = 'Formato HH:MM inv√°lido.';
            if (!isValidTime(data.labor.officialExit)) errors['labor.officialExit'] = 'Formato HH:MM inv√°lido.';
            if (!isValidTime(data.labor.workerEntry)) errors['labor.workerEntry'] = 'Formato HH:MM inv√°lido.';
            if (!isValidTime(data.labor.workerExit)) errors['labor.workerExit'] = 'Formato HH:MM inv√°lido.';
          }
        } else if (projectType === 'fixed') {
          if (!isPositiveNumber(data.invoicedAmount)) errors.invoicedAmount = 'Importe facturado inv√°lido.';
        }
      }
    }
  }
  if (!data.workPerformed || !isRequired(data.workPerformed.description)) {
    errors['workPerformed.description'] = 'Descripci√≥n obligatoria.';
  }
  const result = { isValid: Object.keys(errors).length === 0, errors };
  console.log(`Validation result: ${result.isValid ? 'Valid' : 'Invalid'}`, result.errors);
  return result;
};

exports.createProject = onCall(
  functionConfig,
  async (request) => {
    const data = request.data;
    const context = request.auth;
    console.log("Data createProject:", JSON.stringify(data, null, 2));
    if (!context) throw new Error('Authentication required.');
    const validationResult = validateProject(data);
    if (!validationResult.isValid) throw new Error(JSON.stringify({ message: 'Invalid data', details: validationResult.errors }));
    try {
      const normalizedId = String(data.id).trim();
      const existingProjects = await db.collection('projects').where('id', '==', normalizedId).get();
      if (!existingProjects.empty) throw new Error(JSON.stringify({ message: `ID ${normalizedId} already exists` }));
      const projectData = { ...data, id: normalizedId, userId: context.uid, createdAt: new Date() };
      const docRef = await db.collection('projects').add(projectData);
      console.log(`Project created: Doc ID ${docRef.id}, Custom ID ${normalizedId}`);
      return { id: docRef.id, success: true, message: 'Project created.' };
    } catch (error) {
      console.error("Error in createProject:", error);
      try { const errorData = JSON.parse(error.message); throw new Error(errorData.message); }
      catch (parseError) { throw new Error(error.message); }
    }
  }
);

exports.createDailyReport = onCall(
  functionConfig,
  async (request) => {
    const data = request.data;
    const context = request.auth;
    console.log("Data createDailyReport:", JSON.stringify(data, null, 2));
    if (!context) throw new Error('Authentication required.');
    try {
      const validationResult = await validateDailyReport(data);
      if (!validationResult.isValid) throw new Error(JSON.stringify({ message: 'Invalid data', details: validationResult.errors }));
      const reportData = { ...data, userId: context.uid, createdAt: new Date() };
      const docRef = await db.collection('dailyReports').add(reportData);
      console.log(`Daily report created: ${docRef.id}`);
      return { id: docRef.id, success: true, message: 'Daily report created.' };
    } catch (error) {
      console.error("Error in createDailyReport:", error);
      try { const errorData = JSON.parse(error.message); throw new Error(errorData.message); }
      catch (parseError) { throw new Error(error.message); }
    }
  }
);

exports.validateOnCreate = onDocumentCreated(
  { document: '{collection}/{docId}', region: 'us-central1' },
  async (event) => {
    const snapshot = event.data;
    if (!snapshot) return;
    const collection = event.params.collection;
    const data = snapshot.data();
    if (['projects', 'dailyReports'].includes(collection)) {
      let validationResult;
      if (collection === 'projects') validationResult = validateProject(data);
      else if (collection === 'dailyReports') validationResult = await validateDailyReport(data);
      if (validationResult && !validationResult.isValid) {
        console.error(`Validation failed for ${collection}/${snapshot.id}:`, validationResult.errors);
        await snapshot.ref.update({ _validationErrors: validationResult.errors, _validationStatus: 'invalid' });
      }
    }
  }
);

exports.updateProjectInvoicedTotal = onDocumentWritten(
  { document: "dailyReports/{reportId}", region: "us-central1" },
  async (event) => {
    const reportId = event.params.reportId;
    const beforeData = event.data?.before?.data();
    const afterData = event.data?.after?.data();

    const projectIdBefore = beforeData?.projectId;
    const projectIdAfter = afterData?.projectId;
    const affectedProjectIds = new Set();
    if (projectIdBefore) affectedProjectIds.add(projectIdBefore);
    if (projectIdAfter) affectedProjectIds.add(projectIdAfter);

    if (affectedProjectIds.size === 0) {
      console.log(`Report ${reportId}: No projectId found. Exiting.`);
      return null;
    }

    console.log(`Report ${reportId} changed. Affecting project(s): ${[...affectedProjectIds].join(', ')}`);

    const recalculateAndUpdate = async (projectIdToUpdate) => {
      console.log(`Recalculating for project: ${projectIdToUpdate}`);
      try {
        const project = await findProjectById(projectIdToUpdate);
        if (!project) {
          console.log(`Project ${projectIdToUpdate} not found during recalculation.`);
          return;
        }
        if (project.type !== 'fixed') {
          console.log(`Project ${projectIdToUpdate} is type '${project.type}', skipping update.`);
          return;
        }

        const projectDocumentId = project.firestoreDocId;
        if (!projectDocumentId) {
           console.error(`Firestore document ID missing for project custom ID ${projectIdToUpdate}`);
           return;
        }

        const reportsQuery = db.collection('dailyReports')
          .where('projectId', '==', projectIdToUpdate)
          .where('isExtraWork', '==', false);

        const snapshot = await reportsQuery.get();
        let newTotalInvoiced = 0;
        snapshot.forEach(doc => {
          newTotalInvoiced += parseFloat(doc.data().invoicedAmount) || 0;
        });

        console.log(`Recalculated total for ${projectIdToUpdate} (Doc: ${projectDocumentId}): ${newTotalInvoiced}`);

        const projectRef = db.collection('projects').doc(projectDocumentId);
        await projectRef.update({ totalInvoicedAmount: newTotalInvoiced });

        console.log(`Updated totalInvoicedAmount for project ${projectIdToUpdate} (Doc: ${projectDocumentId}).`);

      } catch (error) {
        console.error(`Error updating totalInvoicedAmount for ${projectIdToUpdate}:`, error);
      }
    };

    for (const pid of affectedProjectIds) {
      await recalculateAndUpdate(pid);
    }

    return null;
  }
);
</file>

<file path="package.json">
{
  "name": "partes-diarios",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@react-pdf/renderer": "^4.2.2",
    "@tanstack/react-query": "^5.67.3",
    "buffer": "^6.0.3",
    "file-saver": "^2.0.5",
    "firebase": "^11.4.0",
    "glob": "^11.0.1",
    "html2canvas": "^1.4.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-firebase-hooks": "^5.1.1",
    "react-scripts": "^5.0.1",
    "recharts": "^2.10.3",
    "rimraf": "^6.0.1",
    "svgo": "^3.3.2",
    "uuid": "^11.1.0",
    "workbox-cacheable-response": "^7.3.0",
    "workbox-google-analytics": "^7.3.0"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "eslint-config-react-app": "^7.0.1",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "semver": "^7.5.3",
    "shell-quote": "^1.7.3",
    "web-vitals": "^4.2.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "eject": "react-scripts eject",
    "test": "react-scripts test",
    "test:coverage": "react-scripts test --coverage --watchAll=false",
    "test:calculations": "react-scripts test --testPathPattern=src/utils/calculations/__tests__ --coverage --watchAll=false",
    "test:hooks": "react-scripts test --testPathPattern=src/hooks/__tests__ --coverage --watchAll=false",
    "test:integration": "react-scripts test --testPathPattern=src/tests/integration --coverage --watchAll=false",
    "test:utils": "react-scripts test --testPathPattern=src/utils/__tests__ --coverage --watchAll=false",
    "test:ci": "CI=true react-scripts test --coverage --watchAll=false"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "resolutions": {
    "postcss": "8.4.31",
    "tough-cookie": "4.1.3",
    "webpack-dev-middleware": "5.3.4",
    "request": "2.88.2",
    "shell-quote": "1.7.3",
    "semver": "7.5.3",
    "nth-check": "2.1.1"
  },
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{js,jsx}",
      "!src/index.js",
      "!src/reportWebVitals.js",
      "!src/firebase.js",
      "!src/App.js",
      "src/utils/calculations/**/*.js",
      "src/utils/calculationUtils.js",
      "src/utils/formatters.js",
      "src/hooks/useCalculationsService.js",
      "src/hooks/useFormValidation.js"
    ],
    "coverageThreshold": {
      "global": {
        "statements": 80,
        "branches": 80,
        "functions": 80,
        "lines": 80
      }
    },
    "moduleNameMapper": {
      "\\.(css|less|scss|sass)$": "identity-obj-proxy",
      "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/__mocks__/fileMock.js"
    }
  }
}
</file>

<file path="src/components/dashboard/ProjectCostChart.js">
// src/components/dashboard/ProjectCostChart.js - Refactorizado para usar useCalculationsService
import React, { useState, useCallback } from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer
} from "recharts";
import { formatCurrency } from "../../utils/calculationUtils";

/**
 * Componente que muestra gr√°ficos de barras de costes e ingresos por proyecto
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.data - Datos de los proyectos para mostrar, ya calculados por el servicio
 */
const ProjectCostChart = ({ data }) => {
  const [chartType, setChartType] = useState("income"); // Cambiado por defecto a "income"

  // Manejador para cambiar el tipo de gr√°fico
  const handleChartTypeChange = useCallback((type) => {
    setChartType(type);
  }, []);

  // Si no hay datos, mostrar mensaje
  if (!data || data.length === 0) {
    return (
      <div className="empty-chart-message">
        <p>No hay datos disponibles para mostrar en el gr√°fico.</p>
      </div>
    );
  }

  // Ordenar proyectos por ingresos totales o coste total seg√∫n vista
  const sortedData = [...data]
    .sort((a, b) => {
      if (chartType === "income") {
        return b.totalIncome - a.totalIncome;
      } else if (chartType === "cost") {
        return b.totalCost - a.totalCost;
      } else { // breakdown
        const aTotal = Math.max(
          a.laborCost + a.materialsCost,
          a.invoicedAmount || 0
        );
        const bTotal = Math.max(
          b.laborCost + b.materialsCost,
          b.invoicedAmount || 0
        );
        return bTotal - aTotal;
      }
    })
    .slice(0, 10); // Limitar a los 10 proyectos m√°s importantes

  // Configurar tooltip personalizado
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      // Encontrar el proyecto correspondiente
      const project = data.find((item) => item.projectId === label);
      
      return (
        <div className="custom-tooltip">
          <p className="tooltip-label">{`Proyecto: ${label}`}</p>
          {payload.map((entry, index) => (
            <p key={index} style={{ color: entry.color }}>
              {`${entry.name}: ${formatCurrency(entry.value)}`}
            </p>
          ))}
          {project && (
            <>
              <p className="tooltip-client">
                {`Cliente: ${project.client || "Desconocido"}`}
              </p>
              <p className="tooltip-type">
                {`Tipo: ${project.type === 'hourly' ? 'Por horas' : 'Presupuesto cerrado'}`}
              </p>
            </>
          )}
        </div>
      );
    }
    return null;
  };

  // Ajuste para visualizaci√≥n correcta de datos con valores peque√±os
  const getYAxisDomain = () => {
    if (chartType === "income") {
      const maxValue = Math.max(...sortedData.map(item => item.totalIncome || 0));
      return [0, maxValue * 1.1]; // 10% m√°s para mejor visualizaci√≥n
    } else if (chartType === "cost") {
      const maxValue = Math.max(...sortedData.map(item => item.totalCost || 0));
      return [0, maxValue * 1.1];
    } else {
      const maxValues = sortedData.map(item => {
        return Math.max(
          item.laborCost + item.materialsCost, 
          item.invoicedAmount || 0
        );
      });
      const maxValue = Math.max(...maxValues);
      return [0, maxValue * 1.1];
    }
  };

  return (
    <div className="chart-wrapper">
      <div className="chart-controls">
        <button
          className={chartType === "income" ? "active" : ""}
          onClick={() => handleChartTypeChange("income")}
        >
          Ingresos Totales
        </button>
        <button
          className={chartType === "cost" ? "active" : ""}
          onClick={() => handleChartTypeChange("cost")}
        >
          Coste Total
        </button>
        <button
          className={chartType === "breakdown" ? "active" : ""}
          onClick={() => handleChartTypeChange("breakdown")}
        >
          Desglose
        </button>
      </div>

      <ResponsiveContainer width="100%" height={400}>
        <BarChart
          data={sortedData}
          margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis
            dataKey="projectId"
            angle={-45}
            textAnchor="end"
            height={80}
            interval={0}
          />
          <YAxis
            tickFormatter={(value) => `‚Ç¨${value}`}
            width={70}
            domain={getYAxisDomain()}
          />
          <Tooltip content={<CustomTooltip />} />
          <Legend />

          {chartType === "income" ? (
            <Bar
              dataKey="totalIncome"
              name="Ingresos Totales"
              fill="#27AE60"
              radius={[4, 4, 0, 0]}
              minPointSize={3}
            />
          ) : chartType === "cost" ? (
            <Bar
              dataKey="totalCost"
              name="Coste Total"
              fill="#8D432D"
              radius={[4, 4, 0, 0]}
              minPointSize={3}
            />
          ) : (
            <>
              {/* Para proyectos por horas mostramos mano de obra y materiales */}
              <Bar
                dataKey="laborCost"
                name="Mano de Obra"
                stackId="a"
                fill="#8D432D"
                minPointSize={3}
              />
              <Bar
                dataKey="materialsCost"
                name="Materiales"
                stackId="a"
                fill="#2C3E50"
                minPointSize={3}
              />
              {/* Bar separada para invoicedAmount (proyectos de presupuesto cerrado) */}
              <Bar
                dataKey="invoicedAmount"
                name="Facturado"
                fill="#27AE60"
                radius={[4, 4, 0, 0]}
                minPointSize={3}
              />
            </>
          )}
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
};

export default React.memo(ProjectCostChart);
</file>

<file path="src/components/dashboard/TimelineChart.js">
// src/components/dashboard/TimelineChart.js - Refactorizado para usar useCalculationsService
import React, { useState, useCallback } from "react";
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer
} from "recharts";
import { formatCurrency } from "../../utils/calculationUtils";

/**
 * Componente que muestra gr√°ficos de l√≠nea temporal para datos de proyectos
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.data - Datos temporales para visualizar, ya calculados por el servicio
 */
const TimelineChart = ({ data }) => {
  const [chartType, setChartType] = useState("line"); // 'line' o 'area'
  const [metricType, setMetricType] = useState("income"); // Cambiado a 'income' por defecto

  // Manejadores para cambiar tipo de gr√°fico y m√©trica
  const handleChartTypeChange = useCallback((type) => {
    setChartType(type);
  }, []);

  const handleMetricTypeChange = useCallback((type) => {
    setMetricType(type);
  }, []);

  // Si no hay datos, mostrar mensaje
  if (!data || data.length === 0) {
    return (
      <div className="empty-chart-message">
        <p>No hay datos disponibles para mostrar en el gr√°fico.</p>
      </div>
    );
  }

  // Configurar tooltip personalizado
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div className="custom-tooltip">
          <p className="tooltip-label">{`${label}`}</p>
          {payload.map((entry, index) => (
            <p key={index} style={{ color: entry.color }}>
              {`${entry.name}: ${formatCurrency(entry.value)}`}
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  // Determinaci√≥n del dominio del eje Y para mejor visualizaci√≥n
  const getYAxisDomain = () => {
    if (metricType === "income") {
      const maxIncome = Math.max(...data.map(item => item.totalIncome || 0));
      return [0, maxIncome * 1.1]; // A√±adir 10% para mejor visualizaci√≥n
    } else if (metricType === "cost") {
      const maxCost = Math.max(
        ...data.map(item => Math.max(item.totalCost || 0, item.laborCost + item.materialsCost))
      );
      return [0, maxCost * 1.1];
    } else {
      const maxInvoiced = Math.max(...data.map(item => item.invoicedAmount || 0));
      return [0, maxInvoiced * 1.1];
    }
  };

  return (
    <div className="chart-wrapper">
      <div className="chart-controls">
        <div className="chart-type-buttons">
          <button
            className={chartType === "line" ? "active" : ""}
            onClick={() => handleChartTypeChange("line")}
          >
            L√≠neas
          </button>
          <button
            className={chartType === "area" ? "active" : ""}
            onClick={() => handleChartTypeChange("area")}
          >
            √Årea
          </button>
        </div>
        <div className="metric-type-buttons">
          <button
            className={metricType === "income" ? "active" : ""}
            onClick={() => handleMetricTypeChange("income")}
          >
            Ingresos
          </button>
          <button
            className={metricType === "cost" ? "active" : ""}
            onClick={() => handleMetricTypeChange("cost")}
          >
            Costes
          </button>
        </div>
      </div>

      <ResponsiveContainer width="100%" height={400}>
        {chartType === "line" ? (
          <LineChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="weekLabel" />
            <YAxis
              tickFormatter={(value) => `‚Ç¨${value}`}
              width={70}
              domain={getYAxisDomain()}
            />
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            
            {metricType === "income" ? (
              <>
                <Line
                  type="monotone"
                  dataKey="totalIncome"
                  name="Ingresos Totales"
                  stroke="#27AE60"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                  activeDot={{ r: 6 }}
                  connectNulls={true}
                />
              </>
            ) : metricType === "cost" ? (
              <>
                <Line
                  type="monotone"
                  dataKey="totalCost"
                  name="Coste Total"
                  stroke="#8D432D"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                  activeDot={{ r: 6 }}
                  connectNulls={true}
                />
                <Line
                  type="monotone"
                  dataKey="laborCost"
                  name="Mano de Obra"
                  stroke="#2C3E50"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                  connectNulls={true}
                />
                <Line
                  type="monotone"
                  dataKey="materialsCost"
                  name="Materiales"
                  stroke="#3498DB"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                  connectNulls={true}
                />
              </>
            ) : (
              <Line
                type="monotone"
                dataKey="invoicedAmount"
                name="Facturado"
                stroke="#27AE60"
                strokeWidth={2}
                dot={{ r: 4 }}
                activeDot={{ r: 6 }}
                connectNulls={true}
              />
            )}
          </LineChart>
        ) : (
          <AreaChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="weekLabel" />
            <YAxis
              tickFormatter={(value) => `‚Ç¨${value}`}
              width={70}
              domain={getYAxisDomain()}
            />
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            
            {metricType === "income" ? (
              <Area
                type="monotone"
                dataKey="totalIncome"
                name="Ingresos Totales"
                stroke="#27AE60"
                fill="#27AE60"
                connectNulls={true}
              />
            ) : metricType === "cost" ? (
              <>
                <Area
                  type="monotone"
                  dataKey="laborCost"
                  name="Mano de Obra"
                  stackId="1"
                  stroke="#2C3E50"
                  fill="#2C3E50"
                  connectNulls={true}
                />
                <Area
                  type="monotone"
                  dataKey="materialsCost"
                  name="Materiales"
                  stackId="1"
                  stroke="#3498DB"
                  fill="#3498DB"
                  connectNulls={true}
                />
              </>
            ) : (
              <Area
                type="monotone"
                dataKey="invoicedAmount"
                name="Facturado"
                stroke="#27AE60"
                fill="#27AE60"
                connectNulls={true}
              />
            )}
          </AreaChart>
        )}
      </ResponsiveContainer>
    </div>
  );
};

export default React.memo(TimelineChart);
</file>

<file path="src/components/reports/ReportEditForm.js">
// src/components/reports/ReportEditForm.js
import React, { useState, useEffect, useCallback } from "react";
import { doc, getDoc, updateDoc } from "firebase/firestore";
import { db } from "../../firebase";
import { getWeekNumber } from "../../utils/calculationUtils";
import { useStorage } from "../../hooks/useStorage";
import { useCalculationsService } from "../../hooks/useCalculationsService";
import { useQueryClient } from '@tanstack/react-query'; // Importaci√≥n a√±adida
import MaterialsEditor from "./MaterialsEditor";
import PhotosEditor from "./PhotosEditor";

const ReportEditForm = ({ reportId, projects, onCancel, onComplete }) => {
  // Hook useQueryClient llamado correctamente en el nivel superior
  const queryClient = useQueryClient();
  
  const [editedReport, setEditedReport] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { uploadFile } = useStorage();
  const { calculateLabor, calculateMaterials } = useCalculationsService();

  // Efecto para bloquear scroll cuando el modal est√° abierto
  useEffect(() => {
    const handleEscKey = (e) => {
      if (e.key === "Escape") {
        onCancel();
      }
    };

    document.body.classList.add('body-no-scroll');
    document.addEventListener("keydown", handleEscKey);

    return () => {
      document.body.classList.remove('body-no-scroll');
      document.removeEventListener("keydown", handleEscKey);
    };
  }, [onCancel]);

  // Cargar datos del reporte
  useEffect(() => {
    const loadReport = async () => {
      try {
        setLoading(true);
        const reportRef = doc(db, "dailyReports", reportId);
        const reportSnap = await getDoc(reportRef);

        if (reportSnap.exists()) {
          setEditedReport({ id: reportSnap.id, ...reportSnap.data() });
        } else {
          setError("El reporte no existe");
        }
      } catch (err) {
        setError(`Error al cargar el reporte: ${err.message}`);
      } finally {
        setLoading(false);
      }
    };

    loadReport();
  }, [reportId]);

  // Manejador de cambios para inputs (incluyendo isBilled)
  const handleInputChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;

    setEditedReport(prev => {
      if (!prev) return prev;

      let updatedValue = value;
      if (type === "checkbox") {
        updatedValue = checked; // Para checkboxes, usa el valor de 'checked'
      }

      if (name.includes(".")) {
        const [parent, field] = name.split(".")
        if (parent === "labor") {
          return { ...prev, labor: { ...prev.labor, [field]: updatedValue } };
        } else if (parent === "workPerformed") {
          updatedValue = field === 'invoicedAmount' ? parseFloat(value) : value;
          return { ...prev, workPerformed: { ...prev.workPerformed, [field]: updatedValue } };
        }
      }
      return { ...prev, [name]: updatedValue };
    });
  }, []);

  // Ahora podemos usar queryClient dentro de handleSubmit
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!editedReport) return;

    try {
      setLoading(true);
      const reportRef = doc(db, "dailyReports", reportId);

      // Preparar los datos a actualizar
      const updatedData = {
        reportDate: editedReport.reportDate,
        weekNumber: getWeekNumber(editedReport.reportDate),
        materials: editedReport.materials || [],
        workPerformed: {
          ...editedReport.workPerformed,
          description: editedReport.workPerformed.description,
          photos: editedReport.workPerformed.photos || [],
        },
        isBilled: !!editedReport.isBilled, // Asegura que sea booleano
      };

      // L√≥gica espec√≠fica por tipo de proyecto
      const project = projects.find((p) => p.id === editedReport.projectId);

      if (editedReport.labor) {
        const laborData = calculateLabor(editedReport.labor, project);
        updatedData.labor = { ...editedReport.labor, ...laborData };
      }

      if (editedReport.workPerformed?.invoicedAmount !== undefined) {
        updatedData.invoicedAmount = editedReport.workPerformed.invoicedAmount;
      }

      if (project && project.type === "hourly") {
        const materialsData = calculateMaterials(editedReport.materials);
        updatedData.totalMaterialsCost = materialsData.totalMaterialsCost;

        if (editedReport.labor) {
          const laborData = calculateLabor(editedReport.labor, project);
          updatedData.totalCost = laborData.totalLaborCost + materialsData.totalMaterialsCost;
        }
      }

      await updateDoc(reportRef, updatedData);
      
      // Invalidar la cach√© para forzar una actualizaci√≥n de la UI
      await queryClient.invalidateQueries({ queryKey: ['reports'] });
      
      onComplete();
    } catch (err) {
      setError(`Error al guardar cambios: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  // Manejadores para materiales y fotos
  const handleMaterialsChange = useCallback((materials) => {
    setEditedReport(prev => ({
      ...prev,
      materials
    }));
  }, []);

  const handlePhotosChange = useCallback((photos) => {
    setEditedReport(prev => ({
      ...prev,
      workPerformed: {
        ...prev.workPerformed,
        photos
      }
    }));
  }, []);

  if (loading && !editedReport) return <p>Cargando reporte...</p>;
  if (error) return <p className="error-message">{error}</p>;
  if (!editedReport) return <p>No se encontr√≥ el reporte</p>;

  const project = projects.find(p => p.id === editedReport.projectId) || {};
  const isHourlyProject = project.type === "hourly";

  return (
    <form onSubmit={handleSubmit} className="edit-form">
      {error && <p className="error-message">{error}</p>}

      <label>Fecha del parte:</label>
      <input
        type="date"
        name="reportDate"
        value={editedReport.reportDate}
        onChange={handleInputChange}
        required
      />

      {/* Checkbox para isBilled con mejor estilo */}
      <div className="billing-checkbox-container">
        <label className="billing-checkbox-label">
          <input
            type="checkbox"
            name="isBilled"
            className="billing-checkbox"
            checked={!!editedReport.isBilled}
            onChange={handleInputChange}
          />
          <span className="billing-checkbox-text">Facturado</span>
        </label>
      </div>

      {isHourlyProject ? (
        <>
          <h4>Mano de obra</h4>
          <div className="labor-row">
            <div className="labor-field">
              <label>Hora entrada oficial</label>
              <input
                type="time"
                name="labor.officialEntry"
                value={editedReport.labor?.officialEntry || ""}
                onChange={handleInputChange}
                className="time-input"
              />
            </div>
            <div className="labor-field">
              <label>Hora salida oficial</label>
              <input
                type="time"
                name="labor.officialExit"
                value={editedReport.labor?.officialExit || ""}
                onChange={handleInputChange}
                className="time-input"
              />
            </div>
          </div>

          <div className="labor-row">
            <div className="labor-field">
              <label>Hora entrada pe√≥n</label>
              <input
                type="time"
                name="labor.workerEntry"
                value={editedReport.labor?.workerEntry || ""}
                onChange={handleInputChange}
                className="time-input"
              />
            </div>
            <div className="labor-field">
              <label>Hora salida pe√≥n</label>
              <input
                type="time"
                name="labor.workerExit"
                value={editedReport.labor?.workerExit || ""}
                onChange={handleInputChange}
                className="time-input"
              />
            </div>
          </div>
        </>
      ) : null}

      <h4>Descripci√≥n de trabajos</h4>
      <textarea
        name="workPerformed.description"
        value={editedReport.workPerformed?.description || ""}
        onChange={handleInputChange}
        placeholder="Descripci√≥n de los trabajos realizados"
      />

      {!isHourlyProject && (
        <>
          <label>Importe Facturado (‚Ç¨)</label>
          <input
            type="number"
            name="workPerformed.invoicedAmount"
            min="0"
            step="0.01"
            value={editedReport.workPerformed?.invoicedAmount || 0}
            onChange={handleInputChange}
          />
        </>
      )}

      {isHourlyProject && (
        <MaterialsEditor
          materials={editedReport.materials || []}
          onMaterialsChange={handleMaterialsChange}
          projectId={editedReport.projectId}
          reportDate={editedReport.reportDate}
          uploadFile={uploadFile}
        />
      )}

      <PhotosEditor
        photos={editedReport.workPerformed?.photos || []}
        onPhotosChange={handlePhotosChange}
        projectId={editedReport.projectId}
        reportDate={editedReport.reportDate}
        uploadFile={uploadFile}
      />

      <div className="form-actions">
        <button type="submit" disabled={loading}>
          {loading ? "Guardando..." : "Guardar cambios"}
        </button>
        <button
          type="button"
          onClick={onCancel}
          disabled={loading}
          className="cancel-button"
        >
          Cancelar
        </button>
      </div>
    </form>
  );
};

export default React.memo(ReportEditForm);
</file>

<file path="src/components/reports/ReportFilters.js">
// src/components/reports/ReportFilters.js
import React, { useCallback, useState, useMemo } from "react"; // Importar useMemo
import { formatCurrency } from "../../utils/calculationUtils";

const ReportFilters = ({
  projects, // Recibe la lista de proyectos como prop
  selectedProjectId,
  dateRange,
  onProjectChange,
  onDateRangeChange,
  onBilledStatusChange,
  billedStatus,
  onWorkTypeChange,
  workType,
  onUserChange,
  selectedUserId,
  users = [],
  onAmountRangeChange,
  amountRange = { min: "", max: "" },
  onSortChange,
  sortField = "reportDate",
  sortDirection = "desc",
  onSaveFilter,
  onResetFilters,
  savedFilters = []
}) => {
  const [isExpanded, setIsExpanded] = useState(false);

  // Ordenar los proyectos alfab√©ticamente descendente por ID
  const sortedProjects = useMemo(() => {
    return [...projects].sort((a, b) => {
      return (b.id || "").localeCompare(a.id || "");
    });
  }, [projects]); // Dependencia: reordenar solo si 'projects' cambia

  // --- Manejadores existentes (sin cambios) ---
  const handleProjectSelect = useCallback((e) => {
    onProjectChange(e.target.value);
  }, [onProjectChange]);

  const handleDateChange = useCallback((e) => {
    const { name, value } = e.target;
    onDateRangeChange({
      ...dateRange,
      [name]: value
    });
  }, [dateRange, onDateRangeChange]);

  const handleBilledStatusSelect = useCallback((e) => {
    onBilledStatusChange(e.target.value);
  }, [onBilledStatusChange]);

  const handleWorkTypeSelect = useCallback((e) => {
    if (onWorkTypeChange) {
      onWorkTypeChange(e.target.value);
    }
  }, [onWorkTypeChange]);

  const handleUserSelect = useCallback((e) => {
    if (onUserChange) {
      onUserChange(e.target.value);
    }
  }, [onUserChange]);

  const handleAmountChange = useCallback((e) => {
    const { name, value } = e.target;
    if (onAmountRangeChange) {
      onAmountRangeChange({
        ...amountRange,
        [name.replace("amount", "")]: value
      });
    }
  }, [amountRange, onAmountRangeChange]);

  const handleSortChangeInternal = useCallback((e) => { // Renombrado para evitar conflicto
    if (onSortChange) {
      onSortChange({
        field: e.target.value,
        direction: sortDirection
      });
    }
  }, [onSortChange, sortDirection]);

  const handleSortDirectionChange = useCallback((e) => {
    if (onSortChange) {
      onSortChange({
        field: sortField,
        direction: e.target.value
      });
    }
  }, [onSortChange, sortField]);

  const toggleExpand = () => setIsExpanded(!isExpanded);

  const handleSaveCurrentFilter = () => {
    if (onSaveFilter) {
      const filterName = prompt("Nombre para guardar este filtro:");
      if (filterName) {
        onSaveFilter({
          name: filterName,
          filter: {
            projectId: selectedProjectId,
            dateRange,
            billedStatus,
            workType,
            selectedUserId,
            amountRange,
            sort: { field: sortField, direction: sortDirection }
          }
        });
      }
    }
  };

  const handleReset = () => {
    if (onResetFilters) {
      onResetFilters();
    }
  };

  const handleApplySavedFilter = useCallback((filterData) => {
      if (onSaveFilter) {
          onSaveFilter(filterData, true); // true indica aplicar
      }
  }, [onSaveFilter]);


  const hasActiveFilters =
    selectedProjectId ||
    dateRange.startDate ||
    dateRange.endDate ||
    billedStatus !== undefined || // Comprobar undefined en lugar de falsy
    workType ||
    selectedUserId ||
    amountRange.min ||
    amountRange.max;

  return (
    <div className={`filter-section ${hasActiveFilters ? 'has-active-filters' : ''}`}>
      <div className="filter-header">
        <h3>Filtros</h3>
        <div className="filter-actions">
          <button
            type="button"
            className="filter-action-button"
            onClick={toggleExpand}
          >
            {isExpanded ? 'Contraer filtros' : 'Expandir filtros'}
          </button>
          <button
            type="button"
            className="filter-action-button save-button"
            onClick={handleSaveCurrentFilter}
            disabled={!hasActiveFilters}
          >
            Guardar filtro
          </button>
          <button
            type="button"
            className="filter-action-button reset-button"
            onClick={handleReset}
            disabled={!hasActiveFilters}
          >
            Limpiar filtros
          </button>
        </div>
      </div>

      {/* Filtros b√°sicos siempre visibles */}
      <div className="basic-filters">
        <div className="filter-group">
          <label htmlFor="filter-project-select">Proyecto: </label>
          {/* Usar la lista ordenada */}
          <select id="filter-project-select" value={selectedProjectId || ""} onChange={handleProjectSelect}>
            <option value="">Todos los proyectos</option>
            {sortedProjects.map((project) => (
              <option key={project.firestoreId} value={project.id}>
                {project.id} - {project.client}
              </option>
            ))}
          </select>
        </div>

        <div className="date-range">
          <div className="date-field">
            <label htmlFor="filter-startDate">Fecha de inicio:</label>
            <input
              id="filter-startDate"
              type="date"
              name="startDate"
              value={dateRange.startDate || ""}
              onChange={handleDateChange}
            />
          </div>
          <div className="date-field">
            <label htmlFor="filter-endDate">Fecha de fin:</label>
            <input
              id="filter-endDate"
              type="date"
              name="endDate"
              value={dateRange.endDate || ""}
              onChange={handleDateChange}
            />
          </div>
        </div>

        <div className="filter-group">
          <label htmlFor="filter-billedStatus">Facturaci√≥n:</label>
          <select id="filter-billedStatus" value={billedStatus === undefined ? "" : String(billedStatus)} onChange={handleBilledStatusSelect}>
            <option value="">Todos</option>
            <option value="true">Facturados</option>
            <option value="false">No facturados</option>
          </select>
        </div>
      </div>

      {/* Filtros avanzados (expandibles) */}
      {isExpanded && (
        <div className="advanced-filters">
          <div className="filter-row">
            <div className="filter-group">
              <label htmlFor="filter-workType">Tipo de trabajo:</label>
              <select id="filter-workType" value={workType || ""} onChange={handleWorkTypeSelect}>
                <option value="">Todos los tipos</option>
                <option value="normal">Trabajo normal</option>
                <option value="extra">Trabajo extra (todos)</option>
                <option value="extra_hourly">Extra por horas</option>
                <option value="extra_budget">Extra con presupuesto</option>
              </select>
            </div>

            {users.length > 0 && (
              <div className="filter-group">
                <label htmlFor="filter-user">Usuario:</label>
                <select id="filter-user" value={selectedUserId || ""} onChange={handleUserSelect}>
                  <option value="">Todos los usuarios</option>
                  {users.map((user) => (
                    <option key={user.id} value={user.id}>
                      {user.name || user.email} {/* Mostrar nombre si existe */}
                    </option>
                  ))}
                </select>
              </div>
            )}
          </div>

          <div className="filter-row">
            <div className="filter-group amount-range">
              <label>Rango de importes:</label>
              <div className="amount-inputs">
                <div className="amount-field">
                   <label htmlFor="filter-amount-min" className="sr-only">Importe m√≠nimo</label> {/* Label oculto para accesibilidad */}
                  <input
                    id="filter-amount-min"
                    type="number"
                    name="amountmin"
                    placeholder="M√≠nimo ‚Ç¨"
                    value={amountRange.min || ""}
                    onChange={handleAmountChange}
                    min="0"
                    step="0.01"
                  />
                </div>
                <span className="amount-separator">a</span>
                <div className="amount-field">
                  <label htmlFor="filter-amount-max" className="sr-only">Importe m√°ximo</label> {/* Label oculto para accesibilidad */}
                  <input
                    id="filter-amount-max"
                    type="number"
                    name="amountmax"
                    placeholder="M√°ximo ‚Ç¨"
                    value={amountRange.max || ""}
                    onChange={handleAmountChange}
                    min="0"
                    step="0.01"
                  />
                </div>
              </div>
            </div>
          </div>

          <div className="filter-row sorting-options">
            <div className="filter-group">
              <label htmlFor="filter-sortField">Ordenar por:</label>
              <select id="filter-sortField" value={sortField} onChange={handleSortChangeInternal}>
                <option value="reportDate">Fecha</option>
                <option value="invoicedAmount">Importe facturado</option>
                <option value="totalCost">Coste total</option>
                <option value="projectId">Proyecto</option>
                <option value="isBilled">Estado de facturaci√≥n</option>
              </select>
            </div>
            <div className="filter-group">
              <label htmlFor="filter-sortDirection">Direcci√≥n:</label>
              <select id="filter-sortDirection" value={sortDirection} onChange={handleSortDirectionChange}>
                <option value="asc">Ascendente</option>
                <option value="desc">Descendente</option>
              </select>
            </div>
          </div>

          {/* Secci√≥n de filtros guardados */}
          {savedFilters.length > 0 && (
            <div className="saved-filters">
              <h4>Filtros guardados</h4>
              <div className="saved-filters-list">
                {savedFilters.map((filterData, index) => (
                  <button
                    key={index}
                    className="saved-filter-button"
                    onClick={() => handleApplySavedFilter(filterData)} // Usar handler espec√≠fico
                    title={`Aplicar filtro: ${filterData.name}`}
                  >
                    {filterData.name}
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Indicador de filtros activos */}
      {hasActiveFilters && (
        <div className="active-filters-indicator">
          <p>Filtros activos: </p>
          <div className="active-filter-tags">
            {selectedProjectId && (
              <span className="filter-tag">
                Proyecto: {projects.find(p => p.id === selectedProjectId)?.client || selectedProjectId}
              </span>
            )}
            {dateRange.startDate && (
              <span className="filter-tag">
                Desde: {new Date(dateRange.startDate).toLocaleDateString()}
              </span>
            )}
            {dateRange.endDate && (
              <span className="filter-tag">
                Hasta: {new Date(dateRange.endDate).toLocaleDateString()}
              </span>
            )}
            {billedStatus !== undefined && ( // Comprobar undefined
              <span className="filter-tag">
                {billedStatus === true ? "Facturados" : "No facturados"}
              </span>
            )}
            {workType && (
              <span className="filter-tag">
                Tipo: {workType === "normal" ? "Normal" : `Extra (${workType.replace('extra_','')})`}
              </span>
            )}
            {selectedUserId && (
              <span className="filter-tag">
                Usuario: {users.find(u => u.id === selectedUserId)?.name || selectedUserId}
              </span>
            )}
            {(amountRange.min || amountRange.max) && (
              <span className="filter-tag">
                Importe: {amountRange.min ? formatCurrency(amountRange.min) : "0‚Ç¨"} -
                {amountRange.max ? formatCurrency(amountRange.max) : "sin l√≠mite"}
              </span>
            )}
            {(sortField !== "reportDate" || sortDirection !== "desc") && (
              <span className="filter-tag">
                Ordenado por: {sortField} ({sortDirection === "asc" ? "‚Üë" : "‚Üì"})
              </span>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

// A√±adir clase sr-only a tu CSS si no la tienes
/*
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
*/

export default React.memo(ReportFilters);
</file>

<file path="src/components/reports/ReportItem.js">
// src/components/reports/ReportItem.js (Completo)
import React, { useCallback } from "react";
import { formatNumber, formatCurrency } from "../../utils/calculationUtils";
import { useCalculationsService } from "../../hooks/useCalculationsService";
import { useUpdateReport } from "../../hooks/useQueryReports"; // Importar useUpdateReport
import "../../components/ExtraWork.css"; // Aseg√∫rate de que esta ruta sea correcta

const ReportItem = ({ report, project, onEdit, onDelete }) => {
  const { calculateLabor, calculateMaterials } = useCalculationsService();
  const calculatedLabor = report.labor ? calculateLabor(report.labor, project) : null;
  const calculatedMaterials = report.materials ? calculateMaterials(report.materials) : null;

  const isHourlyProject = project.type === "hourly";
  const reportDate = new Date(report.reportDate).toLocaleDateString();
  const isExtraWork = report.isExtraWork;
  const extraWorkType = isExtraWork ? report.extraWorkType : null;

  // Usar el hook useUpdateReport
  const updateReportMutation = useUpdateReport();

  // Funci√≥n para manejar el cambio del checkbox de facturaci√≥n
  const handleBilledChange = useCallback(async (e) => {
    const isBilled = e.target.checked;
    try {
      await updateReportMutation.mutateAsync({
        reportId: report.id,
        data: { isBilled }, // Solo actualizamos isBilled
      });
    } catch (error) {
      console.error("Error al actualizar el estado de facturaci√≥n:", error);
      // Aqu√≠ podr√≠as mostrar un mensaje de error al usuario si lo deseas
    }
  }, [report.id, updateReportMutation]);

  const renderWorkType = () => {
    if (isHourlyProject) {
      return "Trabajo por horas";
    } else if (isExtraWork) {
      if (extraWorkType === "additional_budget") {
        return "Trabajo extra - Presupuesto adicional";
      } else {
        return "Trabajo extra - Por horas";
      }
    } else {
      return "Trabajo dentro de presupuesto";
    }
  };

  const cardStyle = isExtraWork ? { borderLeft: '4px solid #E67E22' } : {};
  const badgeStyle = isExtraWork ? {
    backgroundColor: '#E67E22',
    color: 'white',
    padding: '2px 6px',
    borderRadius: '4px',
    fontSize: '0.8rem',
    fontWeight: 'bold',
    display: 'inline-block',
    marginBottom: '8px'
  } : null;

  return (
    <div className="report-card" style={cardStyle}>
      <h4>Parte del {reportDate}</h4>
      {isExtraWork && <span style={badgeStyle}>TRABAJO EXTRA</span>}

      <div className="report-details">
        <p><strong>Semana:</strong> {report.weekNumber}</p>
        <p><strong>Proyecto:</strong> {report.projectId}</p>
        <p><strong>Cliente:</strong> {project.client || "No disponible"}</p>
        <p><strong>Direcci√≥n:</strong> {project.address || "No disponible"}</p>
        <p><strong>Tipo:</strong> {renderWorkType()}</p>
        {/* Checkbox de facturaci√≥n */}
        <div className="billing-checkbox-container">
  <label className="billing-checkbox-label">
    <input
      type="checkbox"
      className="billing-checkbox"
      checked={report.isBilled || false}
      onChange={handleBilledChange}
      disabled={updateReportMutation.isPending}
    />
    <span className="billing-checkbox-text">Facturado</span>
  </label>
</div>
      </div>

      {isHourlyProject || (isExtraWork && extraWorkType === "hourly") ? (
        <div className="labor-details">
          <h5>Mano de obra</h5>
          <p>Oficial: {formatNumber(calculatedLabor?.officialHours || 0)} h - {formatCurrency(calculatedLabor?.officialCost || 0)}</p>
          <p>Pe√≥n: {formatNumber(calculatedLabor?.workerHours || 0)} h - {formatCurrency(calculatedLabor?.workerCost || 0)}</p>
          <p>Total mano de obra: {formatCurrency(calculatedLabor?.totalLaborCost || 0)}</p>

          <h5>Materiales</h5>
          {renderMaterials(report.materials)}
          <p>Total materiales: {formatCurrency(calculatedMaterials?.totalMaterialsCost || 0)}</p>
        </div>
      ) : (
        <div className="fixed-budget-details">
          {isExtraWork && extraWorkType === "additional_budget" ? (
            <p><strong>Importe adicional presupuestado:</strong> {formatCurrency(report.extraBudgetAmount || 0)}</p>
          ) : (
            <p><strong>Importe facturado:</strong> {formatCurrency(report.invoicedAmount || 0)}</p>
          )}
        </div>
      )}

      <div className="work-details">
        <h5>Trabajos realizados</h5>
        <p>{report.workPerformed?.description || "Sin descripci√≥n"}</p>
        {renderPhotos(report.workPerformed?.photos)}
      </div>

      {(isHourlyProject || (isExtraWork && extraWorkType === "hourly")) && (
        <p className="report-total">
          <strong>Total:</strong> {formatCurrency(
            (calculatedLabor?.totalLaborCost || 0) + (calculatedMaterials?.totalMaterialsCost || 0)
          )}
        </p>
      )}

      <div className="report-actions">
        <button onClick={onEdit} className="edit-button">Editar</button>
        <button onClick={onDelete} className="delete-button">Eliminar</button>
      </div>
    </div>
  );
};

// Funciones auxiliares para renderizado (sin cambios)
function renderMaterials(materials = []) {
  if (!materials || materials.length === 0) {
    return <p>No hay materiales registrados.</p>;
  }

  return (
    <div className="materials-list">
      {materials.map((material, index) => (
        <p key={material.id || index}>
          {material.description} - {formatCurrency(material.cost)} (
          <a href={material.invoiceUrl} target="_blank" rel="noopener noreferrer">
            Ver factura
          </a>
          )
        </p>
      ))}
    </div>
  );
}

function renderPhotos(photos = []) {
  if (!photos || photos.length === 0) {
    return null;
  }

  return (
    <div className="photos-container">
      {photos.map((photo, index) => (
        <img
          key={photo.id || index}
          src={photo.url}
          alt={`Foto ${index + 1}`}
          style={{ width: "100px", marginRight: "10px" }}
        />
      ))}
    </div>
  );
}

export default React.memo(ReportItem);
</file>

<file path="src/components/reports/Reports.css">
/* Estilos para la tabla de resumen */
.summary-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

.summary-table td {
  padding: 8px 10px;
  border-bottom: 1px solid #eee;
}

.summary-table td.amount {
  text-align: right;
  font-weight: 500;
}

.summary-table tr.total-row {
  border-top: 2px solid #ddd;
  font-weight: bold;
  color: #333;
}

.summary-table tr.total-row td {
  padding-top: 12px;
}

/* Estilos para el bot√≥n PDF */
.pdf-button-container {
  margin-bottom: 20px;
}

.pdf-button {
  display: block;
  width: 100%;
  padding: 12px 20px;
  background-color: #8D432D;
  color: white;
  text-align: center;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  transition: background-color 0.3s;
}

.pdf-button:hover {
  background-color: #7A3624;
}

.pdf-button.error-button {
  background-color: #e74c3c;
}

.pdf-disabled-message {
  color: #666;
  font-style: italic;
  margin-bottom: 20px;
  text-align: center;
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

/* CREANDO CLASES ESPEC√çFICAS PARA EVITAR CONFLICTOS CON APP.CSS */
/* Estilo para el overlay del modal */
.modal-overlay {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  background-color: rgba(0, 0, 0, 0.5) !important;
  display: flex !important;
  justify-content: center !important;
  align-items: center !important;
  z-index: 1000 !important;
  animation: fadeIn 0.3s ease;
}

/* Estilo para nuestro modal personalizado (usando una clase diferente) */
.custom-modal {
  position: relative !important;
  background-color: white !important;
  border-radius: 8px !important;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3) !important;
  width: 90% !important;
  max-width: 800px !important;
  height: auto !important;
  max-height: 80vh !important;
  overflow-y: auto !important;
  padding: 30px !important;
  margin: 0 auto !important;
  animation: slideIn 0.3s ease;
  
  /* Aseguramos que no herede los estilos problem√°ticos del .modal en App.css */
  top: auto !important;
  left: auto !important;
  transform: none !important;
}

/* Mantenemos la clase edit-modal para aplicar estilos espec√≠ficos del formulario de edici√≥n */
.edit-modal {
  scrollbar-width: thin;
  scrollbar-color: #d4d4d4 #f5f5f5;
}

/* Para Chrome, Safari, y Edge: estilizar la barra de desplazamiento */
.edit-modal::-webkit-scrollbar {
  width: 8px;
}

.edit-modal::-webkit-scrollbar-track {
  background: #f5f5f5;
}

.edit-modal::-webkit-scrollbar-thumb {
  background-color: #d4d4d4;
  border-radius: 4px;
}

/* T√≠tulo del modal */
.custom-modal h3 {
  margin-top: 0 !important;
  margin-bottom: 20px !important;
  border-bottom: 1px solid #ddd !important;
  padding-bottom: 10px !important;
  font-family: "Cormorant", serif !important;
  color: #2c3e50 !important;
  position: sticky !important;
  top: 0 !important;
  background-color: white !important;
  z-index: 1 !important;
  padding-top: 5px !important;
}

/* Bot√≥n de cerrar en la esquina superior derecha */
.custom-modal .close-button {
  position: absolute !important;
  top: 20px !important;
  right: 20px !important;
  background: none !important;
  border: none !important;
  font-size: 24px !important;
  cursor: pointer !important;
  color: #7f8c8d !important;
  padding: 5px !important;
  transition: color 0.3s ease !important;
  z-index: 2 !important;
}

.custom-modal .close-button:hover {
  color: #e74c3c !important;
}

/* Ajustar botones del formulario */
.custom-modal .form-actions {
  display: flex !important;
  justify-content: flex-end !important;
  gap: 10px !important;
  margin-top: 20px !important;
  padding-top: 15px !important;
  border-top: 1px solid #eee !important;
  position: sticky !important;
  bottom: 0 !important;
  background-color: white !important;
  padding-bottom: 5px !important;
  z-index: 1 !important;
}

/* Estilo para prevenir el scroll en el body cuando el modal est√° abierto */
.body-no-scroll {
  overflow: hidden !important;
}

/* Animaciones */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(-30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Estilos para el interior del formulario */
.edit-form {
  display: flex !important;
  flex-direction: column !important;
  gap: 15px !important;
  padding-bottom: 20px !important;
}

.edit-form label {
  font-weight: 500 !important;
  display: block !important;
  margin-bottom: 5px !important;
}

.edit-form input,
.edit-form textarea,
.edit-form select {
  padding: 10px !important;
  border: 1px solid #ddd !important;
  border-radius: 4px !important;
  font-size: 14px !important;
  width: 100% !important;
}

.edit-form textarea {
  min-height: 100px !important;
  resize: vertical !important;
}

.edit-form h4 {
  margin-top: 15px !important;
  margin-bottom: 8px !important;
  color: #2c3e50 !important;
  font-family: "Cormorant", serif !important;
}

/* Estilos responsivos para el modal */
@media (max-width: 768px) {
  .custom-modal {
    width: 95% !important;
    max-height: 85vh !important;
    padding: 20px 15px !important;
  }
  
  .custom-modal .form-actions {
    flex-direction: column !important;
  }
  
  .custom-modal .form-actions button {
    width: 100% !important;
  }
}

/* Estilos para controlar el tama√±o de las im√°genes en el modal de edici√≥n */

/* Contenedor de fotos con grid responsivo */
.photos-container {
  display: grid !important;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
  gap: 15px !important;
  margin-top: 15px !important;
  width: 100% !important;
}

/* Contenedor individual de cada foto */
.photo-container {
  position: relative !important;
  width: 100% !important;
  height: 120px !important;
  border: 1px solid #ddd !important;
  border-radius: 4px !important;
  overflow: hidden !important;
}

/* Estilos para las im√°genes dentro de los contenedores */
.photo-container img,
.photo-thumbnail {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
  transition: transform 0.2s ease !important;
}

.photo-container:hover img {
  transform: scale(1.05) !important;
}

/* Bot√≥n para eliminar foto */
.remove-photo-button {
  position: absolute !important;
  top: 5px !important;
  right: 5px !important;
  background-color: rgba(0, 0, 0, 0.5) !important;
  color: white !important;
  border: none !important;
  border-radius: 50% !important;
  width: 25px !important;
  height: 25px !important;
  font-size: 14px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  cursor: pointer !important;
  opacity: 0.8 !important;
  transition: opacity 0.3s ease !important;
}

.remove-photo-button:hover {
  opacity: 1 !important;
}

/* Estilos para el contenedor de im√°genes existentes */
.existing-images {
  margin-top: 20px !important;
}

/* Estilos para vista previa de im√°genes */
.preview-item {
  position: relative !important;
  width: 140px !important;
  height: 120px !important;
  border-radius: 4px !important;
  overflow: hidden !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
  background-color: white !important;
}

.preview-item img {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  display: block !important;
}

/* Estilos responsivos para pantallas peque√±as */
@media (max-width: 768px) {
  .photos-container {
    grid-template-columns: repeat(2, 1fr) !important;
  }
}

/* Vista m√°s limpia para muchas im√°genes */
.photos-editor {
  margin-bottom: 20px !important;
  padding-bottom: 10px !important;
  border-bottom: 1px solid #eee !important;
}

/* Estilos espec√≠ficos para el ImageUploader */
.image-uploader .previews {
  display: grid !important;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
  gap: 15px !important;
  margin-top: 10px !important;
  margin-bottom: 15px !important;
}

.image-uploader .existing-images .previews {
  display: grid !important;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
  gap: 15px !important;
}

/* A√±adir estos estilos a src/components/reports/Reports.css */

/* Espaciado para los botones de acci√≥n en los partes diarios */
.report-actions {
  display: flex;
  gap: 10px; /* Espacio entre los botones */
  margin-top: 15px;
}

.report-actions button {
  padding: 8px 15px;
  min-width: 100px;
  border: none;
  border-radius: 0px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s ease;
}

.report-actions .edit-button {
  background-color: #8D432D;
  color: white;
}

.report-actions .edit-button:hover {
  background-color: #7A3624;
}

.report-actions .delete-button {
  background-color: #e74c3c;
  color: white;
}

.report-actions .delete-button:hover {
  background-color: #c0392b;
}

/* Eliminar subrayado del enlace de descarga PDF */
.pdf-button-container a {
  text-decoration: none;
}

/* Estilos para mejorar el checkbox de facturaci√≥n */
.billing-checkbox-container {
  margin: 10px 0;
  padding: 8px 10px;
  background-color: #f9f9f9;
  border-radius: 5px;
  border-left: 3px solid #8D432D;
  display: flex;
  align-items: center;
}

.billing-checkbox-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

.billing-checkbox {
  margin: 0;
  margin-right: 8px;
  width: 16px;
  height: 16px;
}

.billing-checkbox-text {
  font-weight: 500;
  color: #2c3e50;
}

/* Estilos adicionales para los nuevos filtros en Reports.css */

/* Mejoras al contenedor de filtros */
.filter-section {
  margin-bottom: 20px;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border-left: 4px solid #8D432D;
  transition: all 0.3s ease;
}

.filter-section.has-active-filters {
  background-color: #f2f6fa;
  border-left-color: #3498db;
}

/* Encabezado de filtros con botones de acci√≥n */
.filter-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.filter-header h3 {
  margin: 0;
  font-family: "Cormorant", serif;
  color: #2c3e50;
}

.filter-actions {
  display: flex;
  gap: 8px;
}

.filter-action-button {
  background-color: #f0f0f0;
  color: #333;
  border: none;
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.filter-action-button:hover {
  background-color: #e0e0e0;
}

.filter-action-button.save-button {
  background-color: #2ecc71;
  color: white;
}

.filter-action-button.save-button:hover {
  background-color: #27ae60;
}

.filter-action-button.reset-button {
  background-color: #e74c3c;
  color: white;
}

.filter-action-button.reset-button:hover {
  background-color: #c0392b;
}

.filter-action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Secciones de filtros */
.basic-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 15px;
}

.advanced-filters {
  background-color: #f5f5f5;
  padding: 15px;
  border-radius: 6px;
  margin-top: 10px;
  border-left: 3px solid #3498db;
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.filter-row {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 15px;
}

/* Grupo de filtros espec√≠ficos */
.filter-group {
  flex: 1;
  min-width: 200px;
}

.filter-group label {
  display: block;
  margin-bottom: 5px;
  color: #7f8c8d;
  font-size: 14px;
}

.filter-group select,
.filter-group input {
  width: 100%;
  padding: 8px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

/* Filtro de rango de importes */
.amount-range {
  display: flex;
  flex-direction: column;
}

.amount-inputs {
  display: flex;
  align-items: center;
  gap: 10px;
}

.amount-field {
  flex: 1;
}

.amount-separator {
  font-size: 14px;
  color: #7f8c8d;
}

/* Opciones de ordenaci√≥n */
.sorting-options {
  background-color: #f0f8ff;
  padding: 10px;
  border-radius: 6px;
}

/* Filtros guardados */
.saved-filters {
  margin-top: 20px;
}

.saved-filters h4 {
  margin-top: 0;
  margin-bottom: 10px;
  font-family: "Cormorant", serif;
  font-size: 16px;
  color: #2c3e50;
}

.saved-filters-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.saved-filter-button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.saved-filter-button:hover {
  background-color: #2980b9;
}

/* Indicador de filtros activos */
.active-filters-indicator {
  margin-top: 15px;
  padding: 10px;
  background-color: #f0f9ff;
  border-radius: 6px;
  border-left: 3px solid #3498db;
}

.active-filters-indicator p {
  margin: 0 0 5px 0;
  font-weight: 500;
  color: #2c3e50;
}

.active-filter-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.filter-tag {
  background-color: #e1f0fa;
  color: #2980b9;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  display: inline-block;
}

/* Resumen de filtros */
.filters-summary {
  margin-bottom: 15px;
  font-style: italic;
  color: #7f8c8d;
}

/* Contenedor para el bot√≥n de cargar m√°s */
.load-more-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
  margin-bottom: 20px;
}

.load-more-button {
  background-color: #8D432D;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.load-more-button:hover {
  background-color: #7A3624;
}

.load-more-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

/* Adaptaciones para m√≥viles */
@media (max-width: 768px) {
  .filter-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }
  
  .filter-actions {
    width: 100%;
    justify-content: space-between;
  }
  
  .basic-filters,
  .filter-row {
    flex-direction: column;
    gap: 10px;
  }
  
  .filter-group {
    width: 100%;
  }
  
  .amount-inputs {
    flex-direction: column;
    gap: 5px;
    align-items: stretch;
  }
  
  .amount-separator {
    display: none;
  }
  
  .active-filter-tags {
    flex-direction: column;
    gap: 4px;
  }
}

.summary-table tr.intermediate-total td {
  font-weight: bold;
  background-color: #f5f5f5;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}
</file>

<file path="src/components/dashboard/KPICards.js">
// src/components/dashboard/KPICards.js
import React from "react";
import { useCalculationsService } from "../../hooks/useCalculationsService";
// Importar formatNumber para las horas y formatCurrency para los euros
import { formatNumber, formatCurrency } from "../../utils/calculationUtils";

/**
 * Componente que muestra tarjetas de m√©tricas clave (KPIs)
 * @param {Object} props - Propiedades del componente
 * @param {Array} props.reports - Lista de reportes filtrados
 * @param {Array} props.projects - Lista de proyectos
 * @param {string} props.selectedProjectId - ID del proyecto seleccionado (puede ser "" para todos)
 */
const KPICards = ({ reports, projects, selectedProjectId }) => {
  // Usamos el servicio centralizado de c√°lculos para obtener las m√©tricas
  const { calculateReportSummary } = useCalculationsService();

  // Obtenemos todas las m√©tricas calculadas del servicio
  // Pasamos selectedProjectId (puede ser "" si es "all")
  const { totals } = calculateReportSummary(reports, projects, selectedProjectId);

  // Desestructuramos las m√©tricas que necesitamos, incluyendo las nuevas horas
  const {
    totalLabor,
    totalMaterials,
    totalCost,
    totalInvoiced,
    totalHours, // Horas totales generales
    totalOfficialHours, // Horas Oficial totales
    totalWorkerHours,   // Horas Pe√≥n totales
    totalIncome, // Ingreso total (calculado seg√∫n tipo y extras)
    totalExtraBudget,
    totalExtraCost,
    totalExtraLaborCost, // <--- A√ëADIDO AQU√ç
    grandTotal // Ingreso total general (Facturado Normal + Presupuesto Extra + MO Extra)
  } = totals;

  // Determinar el n√∫mero de proyectos activos (si se filtra o todos)
  const activeProjectCount = selectedProjectId && selectedProjectId !== "all"
    ? 1
    : projects.length;

  return (
    <div className="metrics-container">
      {/* Proyectos */}
      <div className="metric-card">
        <div className="metric-icon">üìä</div>
        <div className="metric-value">{activeProjectCount}</div>
        <div className="metric-label">Proyectos Activos</div>
      </div>

      {/* Partes */}
      <div className="metric-card">
        <div className="metric-icon">üìù</div>
        <div className="metric-value">{reports.length}</div>
        <div className="metric-label">Partes Mostrados</div>
      </div>

      {/* Horas Oficial */}
      <div className="metric-card">
        <div className="metric-icon">üë∑üèª‚Äç‚ôÇÔ∏è</div> {/* Icono para oficial */}
        <div className="metric-value">{formatNumber(totalOfficialHours || 0)}</div>
        <div className="metric-label">Horas Oficial</div>
      </div>

      {/* Horas Pe√≥n */}
      <div className="metric-card">
        <div className="metric-icon">üë∑üèº</div> {/* Icono para pe√≥n */}
        <div className="metric-value">{formatNumber(totalWorkerHours || 0)}</div>
        <div className="metric-label">Horas Pe√≥n</div>
      </div>

      {/* Horas Totales */}
      <div className="metric-card">
        <div className="metric-icon">‚è±Ô∏è</div>
        <div className="metric-value">{formatNumber(totalHours || 0)}</div>
        <div className="metric-label">Horas Totales</div>
      </div>

      {/* Ingresos Totales (Usando grandTotal) */}
      <div className="metric-card" style={{ backgroundColor: "#e8f7eb" }}>
        <div className="metric-icon">üíµ</div>
        {/* Usamos grandTotal que representa el ingreso total esperado */}
        <div className="metric-value">{formatCurrency(grandTotal || 0)}</div>
        <div className="metric-label">Ingresos Totales</div>
      </div>

      {/* Coste Mano de Obra (Solo partes normales o hourly) */}
      <div className="metric-card">
        <div className="metric-icon">üë∑</div>
        <div className="metric-value">{formatCurrency(totalLabor || 0)}</div>
        <div className="metric-label">Coste M. Obra</div>
      </div>

      {/* Facturado (Solo partes normales 'fixed') */}
      <div className="metric-card" style={{ backgroundColor: "#e0f7fa" }}>
        <div className="metric-icon">üìã</div>
        <div className="metric-value">{formatCurrency(totalInvoiced || 0)}</div>
        <div className="metric-label">Facturado (Presup.)</div>
      </div>

      {/* Costes Totales (MO+Mat para hourly, no aplica directo a fixed) */}
      {/* Podr√≠amos mostrar totalLabor + totalMaterials si queremos un coste operativo */}
      <div className="metric-card">
        <div className="metric-icon">üí∞</div>
        <div className="metric-value">{formatCurrency((totalLabor || 0) + (totalMaterials || 0))}</div>
        <div className="metric-label">Coste Operativo</div>
      </div>

      {/* Materiales */}
      <div className="metric-card">
        <div className="metric-icon">üîß</div>
        <div className="metric-value">{formatCurrency(totalMaterials || 0)}</div>
        <div className="metric-label">Coste Materiales</div>
      </div>

      {/* Trabajos extra (si hay) */}
      {(totalExtraBudget > 0 || totalExtraCost > 0) && (
        <div className="metric-card" style={{ backgroundColor: "#fff8e1" }}>
          <div className="metric-icon">‚ö†Ô∏è</div>
          {/* Mostramos el ingreso total de los extras */}
          <div className="metric-value">{formatCurrency((totalExtraBudget || 0) + (totalExtraLaborCost || 0))}</div>
          <div className="metric-label">Ingreso Trab. Extra</div>
        </div>
      )}
    </div>
  );
};

export default React.memo(KPICards);
</file>

<file path="src/components/ProjectSelector.js">
import React, { useMemo } from "react"; // Importar useMemo
import { useQueryProjects } from "../hooks/useQueryProjects";
import { formatCurrency } from "../utils/calculationUtils"; // Aseg√∫rate que la ruta sea correcta

const ProjectSelector = ({ onProjectSelect, selectedProject }) => {
  // Usamos el hook de React Query para obtener proyectos
  const { data: projects = [], isLoading, error } = useQueryProjects();

  // Ordenar los proyectos alfab√©ticamente descendente por ID
  // Usamos useMemo para que solo se reordene si la lista de 'projects' cambia
  const sortedProjects = useMemo(() => {
    // Creamos una copia antes de ordenar para no mutar el estado original de React Query
    return [...projects].sort((a, b) => {
      // localeCompare para comparaci√≥n de strings segura
      // b.id.localeCompare(a.id) para orden descendente
      return (b.id || "").localeCompare(a.id || "");
    });
  }, [projects]); // Dependencia: reordenar solo si 'projects' cambia

  const handleChange = (e) => {
    const selectedProjectId = e.target.value;
    // Buscamos el proyecto usando el ID personalizado
    const project = projects.find((p) => p.id === selectedProjectId);
    onProjectSelect(project); // Pasar el objeto proyecto completo
  };

  if (isLoading) return <p>Cargando proyectos...</p>;
  if (error) return <p className="error-message">Error: {error.message}</p>;

  return (
    <div className="project-selector-container"> {/* A√±adido un contenedor si es necesario */}
      <label htmlFor="project-select-main">ID del Proyecto</label>
      <select
        id="project-select-main" // A√±adido un ID para el label
        onChange={handleChange}
        value={selectedProject?.id || ""}
        required
        className="project-selector" // Clase para estilos si es necesario
      >
        <option value="">Selecciona un proyecto</option>
        {/* Mapear sobre la lista ordenada */}
        {sortedProjects.map((p) => (
          <option key={p.firestoreId} value={p.id}>
            {/* Mostrar ID y Cliente para mejor identificaci√≥n */}
            {p.id} - {p.client}
          </option>
        ))}
      </select>

      {/* Detalles del proyecto seleccionado (sin cambios en esta parte) */}
      {selectedProject && (
        <div className="project-details">
          <h4 className="project-details-title">Detalles del Proyecto</h4>
          <p>
            <span className="detail-label">Direcci√≥n:</span>
            <span className="detail-value">{selectedProject.address}</span>
          </p>
          <p>
            <span className="detail-label">Cliente:</span>
            <span className="detail-value">{selectedProject.client}</span>
          </p>
          <p>
            <span className="detail-label">NIF/NIE:</span>
            <span className="detail-value">{selectedProject.nifNie}</span>
          </p>
          {selectedProject.type === "hourly" ? (
            <>
              <p>
                <span className="detail-label">Precio oficial:</span>
                <span className="detail-value">{formatCurrency(selectedProject.officialPrice)} /h</span>
              </p>
              <p>
                <span className="detail-label">Precio pe√≥n:</span>
                <span className="detail-value">{formatCurrency(selectedProject.workerPrice)} /h</span>
              </p>
            </>
          ) : (
            <>
              <p>
                <span className="detail-label">Presupuesto:</span>
                <span className="detail-value">{formatCurrency(selectedProject.budgetAmount)}</span>
              </p>
              {selectedProject.allowExtraWork && (
                <>
                    <p className="extra-work-info">Este proyecto permite trabajos extra</p>
                    <p>
                        <span className="detail-label">‚Ç¨ Oficial (Extras):</span>
                        <span className="detail-value">{formatCurrency(selectedProject.officialPrice)}/h</span>
                    </p>
                    <p>
                        <span className="detail-label">‚Ç¨ Pe√≥n (Extras):</span>
                        <span className="detail-value">{formatCurrency(selectedProject.workerPrice)}/h</span>
                    </p>
                </>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default React.memo(ProjectSelector);
</file>

<file path="src/components/Dashboard.js">
// src/components/Dashboard.js - Refactorizado para usar useCalculationsService
import React, { useState } from "react";
import { useQueryProjects } from "../hooks/useQueryProjects";
import { useQueryReportsInfinite } from "../hooks/useQueryReports";
import useReportFilters from "../hooks/reports/useReportFilters";

// Componentes
import KPICards from "./dashboard/KPICards";
import DashboardFilters from "./dashboard/DashboardFilters";
import DashboardCharts from "./dashboard/DashboardCharts";
import DashboardSummary from "./dashboard/DashboardSummary";
import DashboardSkeleton from "./dashboard/DashboardSkeleton";
import ErrorDisplay from "./common/ErrorDisplay";
import EmptyState from "./common/EmptyState";

// Estilos
import "./Dashboard.css";

/**
 * Dashboard principal que muestra KPIs, gr√°ficos y res√∫menes de proyectos/reportes
 */
const Dashboard = () => {
  // Estados de UI
  const [selectedProject, setSelectedProject] = useState("all");
  const [dateRange, setDateRange] = useState({ 
    startDate: "", 
    endDate: new Date().toISOString().split("T")[0]
  });
  const [activeView, setActiveView] = useState("costes");
  
  // Obtener proyectos usando React Query
  const { 
    data: projects = [], 
    isLoading: projectsLoading, 
    error: projectsError 
  } = useQueryProjects();
  
  // Hook de filtros
  const { updateFilters, filters, filterReports } = useReportFilters({
    projectId: selectedProject !== "all" ? selectedProject : "",
    startDate: dateRange.startDate,
    endDate: dateRange.endDate
  });

  // Obtener reportes usando React Query con paginaci√≥n infinita
  const { 
    data, 
    isLoading: reportsLoading, 
    fetchNextPage,
    hasNextPage,
    error: reportsError,
    refetch
  } = useQueryReportsInfinite({
    pageSize: 100, // Obtener bastantes reportes por p√°gina
    startDate: dateRange.startDate || undefined,
    endDate: dateRange.endDate || undefined,
    projectId: selectedProject !== "all" ? selectedProject : undefined
  });
  
  // Transformar los datos paginados a un arreglo plano
  const reports = React.useMemo(() => {
    if (!data) return [];
    return data.pages.flatMap(page => page.items || []);
  }, [data]);

  // Filtrar reportes basados en filtros actuales (si hay alguno adicional que no maneje ya la consulta)
  const filteredReports = filterReports(reports);

  // Manejar cambios en los filtros
  const handleFiltersChange = (newFilters) => {
    if (newFilters.projectId !== undefined) {
      setSelectedProject(newFilters.projectId === "" ? "all" : newFilters.projectId);
    }
    
    if (newFilters.startDate !== undefined || newFilters.endDate !== undefined) {
      setDateRange(prev => ({
        ...prev,
        ...(newFilters.startDate !== undefined && { startDate: newFilters.startDate }),
        ...(newFilters.endDate !== undefined && { endDate: newFilters.endDate })
      }));
    }
    
    updateFilters(newFilters);
  };

  // Manejar cambio de vista
  const handleViewChange = (view) => {
    setActiveView(view);
  };

  // Estado de carga combinado
  const isLoading = projectsLoading || (reportsLoading && reports.length === 0);
  
  // Condiciones de renderizado
  if (isLoading) {
    return <DashboardSkeleton />;
  }
  
  if (projectsError || reportsError) {
    return (
      <ErrorDisplay 
        error={projectsError || reportsError} 
        message="No se pudieron cargar los datos para el dashboard" 
        onRetry={() => refetch()} // React Query proporciona refetch
      />
    );
  }

  if (projects.length === 0 || reports.length === 0) {
    return (
      <EmptyState
        title="No hay datos disponibles"
        message="A√±ade proyectos y reportes para comenzar a visualizar m√©tricas en el dashboard."
        icon="üìä"
        action={() => refetch()}
        actionLabel="Actualizar datos"
      />
    );
  }

  return (
    <div className="dashboard" role="region" aria-label="Panel de control">
      <h2 className="section-title">Dashboard</h2>
      
      {/* Tarjetas de KPIs */}
      <KPICards 
        reports={filteredReports}
        projects={projects}
        selectedProjectId={selectedProject !== "all" ? selectedProject : ""}
      />
      
      {/* Filtros */}
      <DashboardFilters 
        projects={projects}
        selectedProject={selectedProject}
        dateRange={dateRange}
        onFiltersChange={handleFiltersChange}
      />
      
      {/* Gr√°ficos */}
      <DashboardCharts 
        reports={filteredReports}
        projects={projects}
        selectedProject={selectedProject}
        dateRange={dateRange}
        activeView={activeView}
        onViewChange={handleViewChange}
      />
      
      {/* Resumen de datos */}
      <DashboardSummary 
        reports={filteredReports}
        projects={projects}
        selectedProject={selectedProject}
        isLoading={false}
      />
      
      {/* Cargar m√°s datos si es necesario */}
      {hasNextPage && (
        <div className="load-more-container">
          <button 
            onClick={() => fetchNextPage()} 
            disabled={!hasNextPage}
            className="load-more-button"
          >
            {reportsLoading ? "Cargando m√°s datos..." : "Cargar m√°s datos"}
          </button>
        </div>
      )}
    </div>
  );
};

export default React.memo(Dashboard);
</file>

<file path="src/components/reports/ReportsViewer.js">
// src/components/reports/ReportsViewer.js
import React, { useState, useCallback, useMemo } from "react";
import { useQueryProjects } from "../../hooks/useQueryProjects";
import { useQueryUser } from "../../hooks/useQueryUser";
import {
  useQueryReportsInfinite,
  useDeleteReport,
} from "../../hooks/useQueryReports";
import useReportFilters from "../../hooks/reports/useReportFilters";
import useReportSummary from "../../hooks/reports/useReportSummary";

import ReportFilters from "./ReportFilters";
import ReportsList from "./ReportsList";
import ReportEditForm from "./ReportEditForm";
import ReportDeleteModal from "./ReportDeleteModal";
import ReportSummary from "./ReportSummary";
import PDFButton from "../common/PDFButton";
import EmptyState from "../common/EmptyState";
import './Reports.css';

const ReportsViewer = () => {
  // Estados locales para UI y modales
  const [editingReportId, setEditingReportId] = useState(null);
  const [reportToDelete, setReportToDelete] = useState(null);
  const [pdfKey, setPdfKey] = useState(Date.now());
  
  // Hook de filtrado avanzado
  const {
    filters,
    updateFilter,
    updateFilters,
    processReports, // Usamos la funci√≥n de procesamiento que filtra y ordena
    hasActiveFilters,
    filtersDescription,
    sortOptions,
    updateSortOptions,
    resetFilters,
    saveFilter,
    savedFilters,
  } = useReportFilters({
    projectId: "",
    startDate: "",
    endDate: "",
    isBilled: undefined,
    workType: "",
    userId: "",
    amountMin: "",
    amountMax: "",
  });

  // Consultar proyectos y usuarios
  const { data: projects = [] } = useQueryProjects();
  const { data: users = [] } = useQueryUser();

  // Consulta de reportes con React Query
  const {
    data,
    isLoading,
    fetchNextPage,
    hasNextPage,
    refetch,
  } = useQueryReportsInfinite({
    projectId: filters.projectId || undefined,
    startDate: filters.startDate || undefined,
    endDate: filters.endDate || undefined,
    isBilled: filters.isBilled,
    userId: filters.userId || undefined,
    orderBy: sortOptions.field,
    orderDirection: sortOptions.direction,
    pageSize: 100,
  });

  // Mutaci√≥n para eliminar un reporte
  const deleteReportMutation = useDeleteReport();

  // Extraer y procesar reportes
  const allReports = useMemo(() => {
    if (!data) return [];
    return data.pages.flatMap(page => page.items || []);
  }, [data]);

  const filteredAndSortedReports = useMemo(() => {
    return processReports(allReports);
  }, [allReports, processReports]);
  
  // Usar el hook de resumen (ahora corregido) para calcular totales
  // Se le pasa la lista COMPLETA de reportes para que los totales sean siempre correctos
  const { totals } = useReportSummary(
    allReports,
    projects,
    filters.projectId
  );

  // Manejadores para cambios en filtros
  const handleProjectChange = useCallback((projectId) => {
    updateFilter("projectId", projectId);
    setPdfKey(Date.now());
  }, [updateFilter]);

  const handleDateRangeChange = useCallback((newDateRange) => {
    updateFilters({
      startDate: newDateRange.startDate || "",
      endDate: newDateRange.endDate || ""
    });
    setPdfKey(Date.now());
  }, [updateFilters]);
  
  const handleBilledStatusChange = useCallback((status) => {
    updateFilter("isBilled", status === "" ? undefined : status === "true");
  }, [updateFilter]);

  const handleWorkTypeChange = useCallback((type) => {
    updateFilter("workType", type);
  }, [updateFilter]);

  const handleUserChange = useCallback((userId) => {
    updateFilter("userId", userId);
  }, [updateFilter]);

  const handleAmountRangeChange = useCallback((range) => {
    updateFilters({
      amountMin: range.min || "",
      max: range.max || ""
    });
  }, [updateFilters]);

  const handleSortChange = useCallback((sortData) => {
    updateSortOptions(sortData);
  }, [updateSortOptions]);

  const handleResetFilters = useCallback(() => {
    resetFilters();
  }, [resetFilters]);

  const handleSaveFilter = useCallback((filterData, apply = false) => {
    saveFilter({ ...filterData, apply });
    if (apply) {
      const { filter } = filterData;
      updateFilters(filter);
      updateSortOptions(filter.sort || { field: "reportDate", direction: "desc" });
    }
  }, [saveFilter, updateFilters, updateSortOptions]);

  // Manejadores para edici√≥n y eliminaci√≥n
  const handleEditReport = useCallback((reportId) => {
    setEditingReportId(reportId);
  }, []);

  const handleCancelEdit = useCallback(() => {
    setEditingReportId(null);
  }, []);

  const handleModalOverlayClick = useCallback((e) => {
    if (e.target.className === 'modal-overlay') {
      handleCancelEdit();
    }
  }, [handleCancelEdit]);

  const handleEditComplete = useCallback(() => {
    setEditingReportId(null);
    refetch();
  }, [refetch]);

  const handleDeleteRequest = useCallback((reportId) => {
    setReportToDelete(reportId);
  }, []);

  const handleDeleteCancel = useCallback(() => {
    setReportToDelete(null);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (!reportToDelete) return;
    await deleteReportMutation.mutateAsync(reportToDelete);
    setReportToDelete(null);
  }, [reportToDelete, deleteReportMutation]);

  const isLoadingData = isLoading && allReports.length === 0;

  return (
    <div className="reports-viewer">
      <h2>Informes</h2>

      <ReportFilters
        projects={projects}
        selectedProjectId={filters.projectId}
        dateRange={{ startDate: filters.startDate, endDate: filters.endDate }}
        onProjectChange={handleProjectChange}
        onDateRangeChange={handleDateRangeChange}
        onBilledStatusChange={handleBilledStatusChange}
        billedStatus={filters.isBilled === undefined ? "" : String(filters.isBilled)}
        onWorkTypeChange={handleWorkTypeChange}
        workType={filters.workType}
        onUserChange={handleUserChange}
        selectedUserId={filters.userId}
        users={users}
        onAmountRangeChange={handleAmountRangeChange}
        amountRange={{ min: filters.amountMin, max: filters.amountMax }}
        onSortChange={handleSortChange}
        sortField={sortOptions.field}
        sortDirection={sortOptions.direction}
        onSaveFilter={handleSaveFilter}
        onResetFilters={handleResetFilters}
        savedFilters={savedFilters}
      />

      {hasActiveFilters && (
        <div className="filters-summary">
          <p>Mostrando resultados para: {filtersDescription}</p>
        </div>
      )}

      {/* --- SECCI√ìN DE RESUMEN CORREGIDA --- */}
      {/* Se renderiza si hay un proyecto seleccionado, para mostrar su resumen financiero */}
      {filters.projectId && (
        <ReportSummary
          totals={totals}
          project={projects.find(p => p.id === filters.projectId)}
        />
      )}

      <PDFButton
        key={pdfKey}
        reports={filteredAndSortedReports}
        projects={projects}
        selectedProjectId={filters.projectId}
        dateRange={{ startDate: filters.startDate, endDate: filters.endDate }}
        disabled={!filters.projectId || filteredAndSortedReports.length === 0}
      />

      <h3 className="section-title">Partes Diarios</h3>

      {isLoadingData ? (
        <p>Cargando informes...</p>
      ) : filteredAndSortedReports.length === 0 ? (
        <EmptyState 
          title="No se encontraron partes"
          message={hasActiveFilters ? 
            "No hay partes que coincidan con los filtros aplicados. Prueba a cambiarlos o limpiarlos." : 
            "No hay partes creados a√∫n en este proyecto o rango de fechas."
          }
          icon="üìä"
          action={hasActiveFilters ? resetFilters : null}
          actionLabel={hasActiveFilters ? "Limpiar filtros" : null}
        />
      ) : (
        <>
          <ReportsList
            reports={filteredAndSortedReports}
            projects={projects}
            onEdit={handleEditReport}
            onDelete={handleDeleteRequest}
          />
          {hasNextPage && (
            <div className="load-more-container">
              <button 
                onClick={() => fetchNextPage()} 
                disabled={isLoading}
                className="load-more-button"
              >
                {isLoading ? "Cargando m√°s..." : "Cargar m√°s partes"}
              </button>
            </div>
          )}
        </>
      )}

      {editingReportId && (
        <div className="modal-overlay" onClick={handleModalOverlayClick}>
          <div className="custom-modal edit-modal">
            <h3>Editar Parte</h3>
            <button type="button" className="close-button" onClick={handleCancelEdit} aria-label="Cerrar">√ó</button>
            <ReportEditForm
              reportId={editingReportId}
              projects={projects}
              onCancel={handleCancelEdit}
              onComplete={handleEditComplete}
            />
          </div>
        </div>
      )}

      {reportToDelete && (
        <ReportDeleteModal
          onConfirm={handleDeleteConfirm}
          onCancel={handleDeleteCancel}
        />
      )}
    </div>
  );
};

export default React.memo(ReportsViewer);
</file>

<file path="src/components/DailyReportForm.js">
// src/components/DailyReportForm.js - Refactorizado para usar useCalculationsService
import React, { useState, useCallback } from "react";
import { useQueryProjects } from "../hooks/useQueryProjects";
import { useAddReport } from "../hooks/useQueryReports";
import { useCalculationsService } from "../hooks/useCalculationsService";
import ProjectSelector from "./ProjectSelector";
import LaborForm from "./LaborForm";
import MaterialsForm from "./MaterialsForm";
import WorkPerformedForm from "./WorkPerformedForm";
import FixedReportForm from "./FixedReportForm";
import ExtraWorkForm from "./ExtraWorkForm";
import { getWeekNumber } from "../utils/calculationUtils";
import "./ExtraWork.css";

const DailyReportForm = ({ userId }) => {
  const [selectedProject, setSelectedProject] = useState(null);
  const [report, setReport] = useState({
    reportDate: new Date().toISOString().split("T")[0],
    labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
    materials: [],
    workPerformed: { description: "", photos: [], invoicedAmount: 0 },
    isExtraWork: false,
    extraWorkType: "additional_budget",
    extraBudgetAmount: 0,
    extraWorkData: {
      labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
      materials: [],
      workPerformed: { description: "", photos: [] },
      extraBudgetAmount: 0,
      extraWorkType: "additional_budget"
    }
  });
  
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");
  
  // Usar el hook de React Query para proyectos
  const { data: projects = [] } = useQueryProjects();
  
  // Usar el hook de React Query para a√±adir reportes
  const addReportMutation = useAddReport();
  
  // Usar el servicio centralizado de c√°lculos
  const { calculateLabor, calculateMaterials } = useCalculationsService();
  
  // Obtener los c√°lculos actualizados
  const laborData = calculateLabor(report.labor, selectedProject);
  const materialsData = calculateMaterials(report.materials);
  
  // C√°lculos para trabajos extra
  const extraLaborData = report.isExtraWork && report.extraWorkData.extraWorkType === "hourly" 
    ? calculateLabor(report.extraWorkData.labor, selectedProject) 
    : null;
  const extraMaterialsData = report.isExtraWork && report.extraWorkData.extraWorkType === "hourly"
    ? calculateMaterials(report.extraWorkData.materials)
    : null;

  // Manejadores de cambios
  const handleDateChange = useCallback((e) => {
    setReport((prev) => ({ ...prev, [e.target.name]: e.target.value }));
  }, []);

  const handleLaborChange = useCallback((newLabor) => {
    setReport((prev) => ({ ...prev, labor: newLabor }));
  }, []);

  const handleMaterialsChange = useCallback((newMaterials) => {
    setReport((prev) => ({ ...prev, materials: newMaterials }));
  }, []);

  const handleWorkPerformedChange = useCallback((newWorkPerformed) => {
    setReport((prev) => ({ ...prev, workPerformed: { ...prev.workPerformed, ...newWorkPerformed } }));
  }, []);

  const handleInvoicedChange = useCallback((e) => {
    const value = parseFloat(e.target.value) || 0;
    setReport((prev) => ({
      ...prev,
      workPerformed: { ...prev.workPerformed, invoicedAmount: value },
    }));
  }, []);
  
  const handleExtraWorkToggle = useCallback((e) => {
    const isChecked = e.target.checked;
    setReport((prev) => ({
      ...prev,
      isExtraWork: isChecked
    }));
  }, []);
  
  const handleExtraWorkDataChange = useCallback((newData) => {
    setReport((prev) => ({
      ...prev,
      extraWorkData: newData
    }));
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!selectedProject || !report.reportDate) {
      setErrorMessage("Por favor, completa todos los campos requeridos.");
      setSuccessMessage("");
      return;
    }

    setErrorMessage("");
    setSuccessMessage("");

    try {
      // Datos base del parte diario
      let reportData = {
        // MODIFICADO: Usar el campo id personalizado del proyecto, no firestoreId
        projectId: selectedProject.id, // Importante: debe coincidir con el campo 'id' en Firestore
        weekNumber: getWeekNumber(report.reportDate),
        reportDate: report.reportDate,
        workPerformed: report.workPerformed,
        userId: userId,
        isExtraWork: report.isExtraWork
      };

      if (selectedProject.type === "hourly") {
        // Proyecto por horas
        // Usar los datos pre-calculados del servicio centralizado
        reportData = {
          ...reportData,
          labor: { ...report.labor, ...laborData },
          materials: report.materials,
          totalMaterialsCost: materialsData.totalMaterialsCost,
          totalCost: laborData.totalLaborCost + materialsData.totalMaterialsCost,
        };
      } else if (selectedProject.type === "fixed") {
        if (!report.isExtraWork) {
          // Proyecto normal de presupuesto cerrado
          reportData = {
            ...reportData,
            invoicedAmount: report.workPerformed.invoicedAmount || 0,
          };
        } else {
          // Trabajo extra
          reportData.extraWorkType = report.extraWorkData.extraWorkType;
          
          if (report.extraWorkData.extraWorkType === "additional_budget") {
            reportData.extraBudgetAmount = report.extraWorkData.extraBudgetAmount || 0;
          } else {
            // Usar los datos pre-calculados del servicio centralizado para trabajos extra
            reportData = {
              ...reportData,
              labor: { ...report.extraWorkData.labor, ...extraLaborData },
              materials: report.extraWorkData.materials,
              totalMaterialsCost: extraMaterialsData.totalMaterialsCost,
              totalCost: extraLaborData.totalLaborCost + extraMaterialsData.totalMaterialsCost,
            };
          }
          
          reportData.workPerformed = report.extraWorkData.workPerformed;
        }
      }

      // Usar la mutaci√≥n de React Query para crear el reporte
      await addReportMutation.mutateAsync(reportData);
      
      setSuccessMessage("Parte guardado correctamente!");
      
      // Resetear el formulario
      setReport({
        reportDate: new Date().toISOString().split("T")[0],
        labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
        materials: [],
        workPerformed: { description: "", photos: [], invoicedAmount: 0 },
        isExtraWork: false,
        extraWorkType: "additional_budget",
        extraBudgetAmount: 0,
        extraWorkData: {
          labor: { officialEntry: "", officialExit: "", workerEntry: "", workerExit: "" },
          materials: [],
          workPerformed: { description: "", photos: [] },
          extraBudgetAmount: 0,
          extraWorkType: "additional_budget"
        }
      });
      
      setSelectedProject(null);
    } catch (err) {
      console.error("Error al guardar parte:", err);
      setErrorMessage(`Error al guardar: ${err.message}`);
    }
  };

  // Obtener el objeto proyecto completo
  const project = projects.find((p) => p.id === selectedProject?.id);
  
  // Verificar si el proyecto permite trabajos extra
  const allowsExtraWork = project?.type === "fixed" && project?.allowExtraWork;

  return (
    <form onSubmit={handleSubmit}>
      {errorMessage && <p className="error-message">{errorMessage}</p>}
      {successMessage && <p className="success-message">{successMessage}</p>}
      {addReportMutation.isPending && <p>Guardando parte...</p>}
      
      <ProjectSelector onProjectSelect={setSelectedProject} selectedProject={selectedProject} />
      
      {selectedProject && (
        <>
          <div className="form-group">
            <label>Fecha del parte</label>
            <input
              type="date"
              name="reportDate"
              value={report.reportDate}
              onChange={handleDateChange}
              required
            />
          </div>
          
          {allowsExtraWork && (
            <div className="form-group checkbox-group">
              <input
                id="is-extra-work"
                type="checkbox"
                name="isExtraWork"
                checked={report.isExtraWork}
                onChange={handleExtraWorkToggle}
                className="checkbox-input"
              />
              <label htmlFor="is-extra-work" className="checkbox-label">
                Es un trabajo extra fuera de presupuesto
              </label>
            </div>
          )}
          
          {/* Formularios condicionales */}
          {project.type === "hourly" ? (
            <>
              <LaborForm labor={report.labor} onLaborChange={handleLaborChange} project={selectedProject} />
              <MaterialsForm
                materials={report.materials}
                onMaterialsChange={handleMaterialsChange}
                projectId={selectedProject.id}
                reportDate={report.reportDate}
              />
              <WorkPerformedForm
                workPerformed={report.workPerformed}
                onWorkPerformedChange={handleWorkPerformedChange}
                projectId={selectedProject.id}
                reportDate={report.reportDate}
              />
            </>
          ) : (
            report.isExtraWork ? (
              <ExtraWorkForm
                extraWorkData={report.extraWorkData}
                onExtraWorkChange={handleExtraWorkDataChange}
                project={selectedProject}
                reportDate={report.reportDate}
              />
            ) : (
              <FixedReportForm
                workPerformed={report.workPerformed}
                onWorkPerformedChange={handleWorkPerformedChange}
                projectId={selectedProject.id}
                reportDate={report.reportDate}
                onInvoicedChange={handleInvoicedChange}
                invoicedAmount={report.workPerformed.invoicedAmount}
              />
            )
          )}
          
          <button type="submit" disabled={addReportMutation.isPending}>
            {addReportMutation.isPending ? "Guardando..." : "Guardar parte"}
          </button>
        </>
      )}
    </form>
  );
};

export default DailyReportForm;
</file>

<file path="src/components/ProjectsViewer.js">
// src/components/ProjectsViewer.js
import React, { useState, useCallback, useEffect } from "react";
// Importar formatNumber para las horas y formatCurrency para los euros
import { formatCurrency, formatNumber } from "../utils/calculationUtils"; // Aseg√∫rate que la ruta sea correcta
import ProjectForm from "./ProjectForm";
import {
  useQueryProjects,
  useAddProject,
  useUpdateProject,
  useDeleteProject
} from "../hooks/useQueryProjects";
import { useQueryReportsInfinite } from "../hooks/useQueryReports";
import { projectSchema } from "../utils/validationSchemas";
import useFormValidation from "../hooks/useFormValidation";
import ConfirmModal from "./common/ConfirmModal"; // Importar el modal de confirmaci√≥n

const ProjectsViewer = () => {
  const [editingProjectId, setEditingProjectId] = useState(null); // Stores firestoreId
  const [editedProject, setEditedProject] = useState(null); // Stores the full project object being edited
  const [projectToDelete, setProjectToDelete] = useState(null); // Stores the project object to delete
  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");

  // Hook de validaci√≥n para el formulario de edici√≥n
  const {
    values: editedValues,
    handleChange: handleEditChange,
    handleBlur: handleEditBlur,
    handleSubmit: handleEditSubmitInternal,
    resetForm: resetEditForm,
    isValid: isEditFormValid,
    errors: editErrors,
    hasError: editHasError,
    getError: editGetError,
    setValues: setEditedValues // Para inicializar el form al editar
  } = useFormValidation({}, projectSchema); // Inicializar vac√≠o, se llenar√° al editar

  // Hooks de React Query
  const { data: projects = [], isLoading: projectsLoading, error: projectsError } = useQueryProjects();
  const { data: reportsData } = useQueryReportsInfinite({ pageSize: 1000 }); // Fetch reports for calculations
  const addProjectMutation = useAddProject();
  const updateProjectMutation = useUpdateProject();
  const deleteProjectMutation = useDeleteProject();

  // Efecto para inicializar el formulario de edici√≥n cuando se selecciona un proyecto
  useEffect(() => {
    if (editedProject) {
      setEditedValues(editedProject); // Usar setValues del hook de validaci√≥n
    } else {
      resetEditForm({}); // Resetear si no hay proyecto edit√°ndose
    }
  }, [editedProject, setEditedValues, resetEditForm]);

  // Efecto para limpiar mensajes despu√©s de un tiempo
  useEffect(() => {
    if (errorMessage || successMessage) {
      const timer = setTimeout(() => {
        setErrorMessage("");
        setSuccessMessage("");
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [errorMessage, successMessage]);

  // Extraer reportes de los datos paginados
  const reports = React.useMemo(() => {
    if (!reportsData) return [];
    return reportsData.pages.flatMap(page => page.items || []);
  }, [reportsData]);

  // Iniciar edici√≥n
  const startEditing = useCallback((project) => {
    if (!project || !project.firestoreId) {
      setErrorMessage("Error al iniciar edici√≥n: Faltan datos del proyecto.");
      return;
    }
    setEditingProjectId(project.firestoreId);
    setEditedProject({ ...project }); // Guardar el proyecto completo para el form
  }, []);

  // Cancelar edici√≥n
  const cancelEditing = useCallback(() => {
    setEditingProjectId(null);
    setEditedProject(null);
  }, []);

  // Manejar env√≠o del formulario de edici√≥n (funci√≥n interna que llama a la mutaci√≥n)
  const handleEditSubmit = useCallback(async (formDataFromHook) => {
    const projectToUpdate = {
      ...formDataFromHook,
      // Asegurarse de que los campos num√©ricos sean n√∫meros
      officialPrice: parseFloat(formDataFromHook.officialPrice) || 0,
      workerPrice: parseFloat(formDataFromHook.workerPrice) || 0,
      budgetAmount: parseFloat(formDataFromHook.budgetAmount) || 0,
      firestoreId: editingProjectId // Usar el ID guardado en el estado
    };

    if (!projectToUpdate.firestoreId) {
      setErrorMessage("Error cr√≠tico: No se encontr√≥ el ID interno para actualizar.");
      return;
    }

    try {
      setSuccessMessage("");
      setErrorMessage("");
      await updateProjectMutation.mutateAsync({
        firestoreId: projectToUpdate.firestoreId,
        data: projectToUpdate // Enviar los datos validados
      });
      cancelEditing();
      setSuccessMessage("Proyecto actualizado correctamente!");
    } catch (err) {
      console.error("Error en handleEditSubmit:", err);
      setErrorMessage(`Error al actualizar proyecto: ${err.message || 'Error desconocido'}`);
    }
  }, [editingProjectId, updateProjectMutation, cancelEditing]);

  // Crear el handler que el formulario usar√°, conectando validaci√≥n y env√≠o
  const actualEditFormSubmitHandler = handleEditSubmitInternal(handleEditSubmit);

  // Iniciar proceso de eliminaci√≥n (mostrar modal)
  const handleDeleteRequest = useCallback((project) => {
    if (!project || !project.firestoreId) {
      setErrorMessage("Error: No se puede eliminar, falta informaci√≥n del proyecto.");
      return;
    }
    setProjectToDelete(project); // Guardar el proyecto completo para el modal
  }, []);

  // Cancelar eliminaci√≥n (cerrar modal)
  const handleDeleteCancel = useCallback(() => {
    setProjectToDelete(null);
  }, []);

  // Confirmar y ejecutar eliminaci√≥n
  const handleDeleteConfirm = useCallback(async () => {
    if (!projectToDelete || !projectToDelete.firestoreId) return;

    try {
      setSuccessMessage("");
      setErrorMessage("");
      await deleteProjectMutation.mutateAsync(projectToDelete.firestoreId);
      setProjectToDelete(null); // Cerrar modal
      setSuccessMessage("Proyecto eliminado.");
    } catch (err) {
      console.error("Error en handleDeleteConfirm:", err);
      setErrorMessage(`Error al eliminar: ${err.message || 'Error desconocido'}`);
      setProjectToDelete(null); // Cerrar modal incluso si hay error
    }
  }, [projectToDelete, deleteProjectMutation]);

  // Calcular costos y horas para proyectos por horas
  const calculateProjectCostsAndHours = useCallback((projectId, projectType) => {
    if (projectType !== "hourly") return { laborCost: 0, materialsCost: 0, totalCost: 0, officialHours: 0, workerHours: 0 };
    const projectReports = reports.filter((report) => report.projectId === projectId && !report.isExtraWork);
    let laborCost = 0;
    let materialsCost = 0;
    let officialHours = 0;
    let workerHours = 0;

    projectReports.forEach((report) => {
      laborCost += report.labor?.totalLaborCost || 0;
      materialsCost += report.totalMaterialsCost || 0;
      officialHours += report.labor?.officialHours || 0;
      workerHours += report.labor?.workerHours || 0;
    });
    return { laborCost, materialsCost, totalCost: laborCost + materialsCost, officialHours, workerHours };
  }, [reports]);

  // Calcular total facturado para proyectos de presupuesto cerrado
  const calculateInvoicedTotal = useCallback((project) => {
      if (project?.type !== "fixed") return 0;
      // Priorizar el valor precalculado si existe
      if (project.totalInvoicedAmount !== undefined && project.totalInvoicedAmount !== null) {
          return project.totalInvoicedAmount;
      }
      // Fallback: calcular sumando reportes (menos eficiente)
      console.warn(`Fallback calculation for invoicedTotal on project ${project.id}`);
      const projectReports = reports.filter((report) => report.projectId === project.id && !report.isExtraWork && report.invoicedAmount);
      return projectReports.reduce((sum, report) => sum + (parseFloat(report.invoicedAmount) || 0), 0);
  }, [reports]);

  // Calcular totales de trabajos extra
  const calculateExtraWorkTotal = useCallback((projectId) => {
    const extraReports = reports.filter(
      (report) => report.projectId === projectId && report.isExtraWork
    );
    let totalExtraBudget = 0;
    let totalExtraCost = 0; // Costo total de extras por horas (MO+Mat)
    let totalExtraLaborCost = 0; // Costo MO de extras por horas
    let extraOfficialHours = 0;
    let extraWorkerHours = 0;

    extraReports.forEach(report => {
      if (report.extraWorkType === "additional_budget") {
        totalExtraBudget += parseFloat(report.extraBudgetAmount) || 0;
      } else if (report.extraWorkType === "hourly") {
        const labor = parseFloat(report.labor?.totalLaborCost) || 0;
        const mats = parseFloat(report.totalMaterialsCost) || 0;
        totalExtraCost += parseFloat(report.totalCost) || (labor + mats);
        totalExtraLaborCost += labor; // Acumular coste MO extra
        extraOfficialHours += report.labor?.officialHours || 0;
        extraWorkerHours += report.labor?.workerHours || 0;
      }
    });
    // El ingreso total extra es la suma del presupuesto adicional y el coste de MO de los extras por horas
    const totalExtraIncome = totalExtraBudget + totalExtraLaborCost;
    return {
        totalExtraBudget,
        totalExtraCost,
        totalExtraIncome,
        extraOfficialHours,
        extraWorkerHours,
        count: extraReports.length
    };
  }, [reports]);

  // Estado de carga general o mutaci√≥n en progreso
  const isMutating = addProjectMutation.isPending || updateProjectMutation.isPending || deleteProjectMutation.isPending;

  // Renderizado condicional de carga y error
  if (projectsLoading) return <p>Cargando proyectos...</p>;
  if (projectsError) return <p className="error-message">Error al cargar proyectos: {projectsError.message}</p>;

  return (
    <div className="projects-viewer">
      <h2>Proyectos</h2>
      {errorMessage && <p className="error-message">{errorMessage}</p>}
      {successMessage && <p className="success-message">{successMessage}</p>}

      {/* Formulario para a√±adir nuevos proyectos */}
      <ProjectForm onProjectAdded={() => setSuccessMessage("Proyecto a√±adido correctamente!")} />

      <h3 className="section-title">Lista de Proyectos</h3>
      <div className="projects-list">
        {projects.map((project) => {
          // Calcular datos derivados para cada proyecto
          const { laborCost, materialsCost, totalCost, officialHours, workerHours } = calculateProjectCostsAndHours(project.id, project.type);
          const invoicedTotal = calculateInvoicedTotal(project);
          const extraWork = project.type === "fixed" ? calculateExtraWorkTotal(project.id) : { totalExtraIncome: 0, count: 0, extraOfficialHours: 0, extraWorkerHours: 0 };
          const isEditing = editingProjectId === project.firestoreId;

          return (
            <div key={project.firestoreId} className={`project-card ${isEditing ? 'editing' : ''}`}>
              {isEditing ? (
                // --- Formulario de Edici√≥n ---
                <form onSubmit={actualEditFormSubmitHandler} className="edit-form project-form">
                   {/* ID no editable */}
                   <div className="form-group">
                     <label>ID Proyecto (No editable)</label>
                     <input type="text" value={editedValues.id || ''} disabled />
                   </div>
                   {/* Cliente */}
                   <div className="form-group">
                     <label htmlFor={`edit-client-${project.firestoreId}`}>Cliente</label>
                     <input
                       id={`edit-client-${project.firestoreId}`}
                       type="text"
                       name="client"
                       value={editedValues.client || ''}
                       onChange={handleEditChange}
                       onBlur={handleEditBlur}
                       className={editHasError('client') ? 'input-error' : ''}
                     />
                     {editHasError('client') && <p className="error-message">{editGetError('client')}</p>}
                   </div>
                   {/* Direcci√≥n */}
                    <div className="form-group">
                     <label htmlFor={`edit-address-${project.firestoreId}`}>Direcci√≥n</label>
                     <input
                       id={`edit-address-${project.firestoreId}`}
                       type="text"
                       name="address"
                       value={editedValues.address || ''}
                       onChange={handleEditChange}
                       onBlur={handleEditBlur}
                       className={editHasError('address') ? 'input-error' : ''}
                     />
                     {editHasError('address') && <p className="error-message">{editGetError('address')}</p>}
                   </div>
                   {/* NIF/NIE */}
                    <div className="form-group">
                     <label htmlFor={`edit-nifNie-${project.firestoreId}`}>NIF/NIE</label>
                     <input
                       id={`edit-nifNie-${project.firestoreId}`}
                       type="text"
                       name="nifNie"
                       value={editedValues.nifNie || ''}
                       onChange={handleEditChange}
                       onBlur={handleEditBlur}
                       className={editHasError('nifNie') ? 'input-error' : ''}
                     />
                     {editHasError('nifNie') && <p className="error-message">{editGetError('nifNie')}</p>}
                   </div>
                   {/* Tipo */}
                   <div className="form-group">
                     <label htmlFor={`edit-type-${project.firestoreId}`}>Tipo</label>
                     <select
                        id={`edit-type-${project.firestoreId}`}
                        name="type"
                        value={editedValues.type || 'hourly'}
                        onChange={handleEditChange}
                        onBlur={handleEditBlur}
                        className={editHasError('type') ? 'input-error' : ''}
                     >
                       <option value="hourly">Por horas</option>
                       <option value="fixed">Presupuesto cerrado</option>
                     </select>
                      {editHasError('type') && <p className="error-message">{editGetError('type')}</p>}
                   </div>
                   {/* Campos condicionales seg√∫n tipo */}
                   {editedValues.type === "hourly" ? (
                     <>
                       <div className="form-group">
                         <label htmlFor={`edit-officialPrice-${project.firestoreId}`}>Precio oficial (‚Ç¨/h)</label>
                         <input
                           id={`edit-officialPrice-${project.firestoreId}`}
                           type="number" name="officialPrice" min="0" step="0.01"
                           value={editedValues.officialPrice || 0} onChange={handleEditChange} onBlur={handleEditBlur}
                           className={editHasError('officialPrice') ? 'input-error' : ''} />
                         {editHasError('officialPrice') && <p className="error-message">{editGetError('officialPrice')}</p>}
                       </div>
                       <div className="form-group">
                         <label htmlFor={`edit-workerPrice-${project.firestoreId}`}>Precio pe√≥n (‚Ç¨/h)</label>
                         <input
                           id={`edit-workerPrice-${project.firestoreId}`}
                           type="number" name="workerPrice" min="0" step="0.01"
                           value={editedValues.workerPrice || 0} onChange={handleEditChange} onBlur={handleEditBlur}
                           className={editHasError('workerPrice') ? 'input-error' : ''} />
                         {editHasError('workerPrice') && <p className="error-message">{editGetError('workerPrice')}</p>}
                       </div>
                     </>
                   ) : ( // Tipo 'fixed'
                     <>
                       <div className="form-group">
                         <label htmlFor={`edit-budgetAmount-${project.firestoreId}`}>Importe presupuestado (‚Ç¨)</label>
                         <input
                           id={`edit-budgetAmount-${project.firestoreId}`}
                           type="number" name="budgetAmount" min="0" step="0.01"
                           value={editedValues.budgetAmount || 0} onChange={handleEditChange} onBlur={handleEditBlur}
                           className={editHasError('budgetAmount') ? 'input-error' : ''} />
                         {editHasError('budgetAmount') && <p className="error-message">{editGetError('budgetAmount')}</p>}
                       </div>
                       {/* Checkbox para permitir extras */}
                       <div className="form-group checkbox-group">
                         <input
                            type="checkbox"
                            name="allowExtraWork"
                            id={`edit-allowExtraWork-${project.firestoreId}`}
                            checked={editedValues.allowExtraWork || false}
                            onChange={handleEditChange} // Usa el mismo handler, detecta tipo checkbox
                            className="checkbox-input"
                         />
                         <label htmlFor={`edit-allowExtraWork-${project.firestoreId}`} className="checkbox-label">
                           Permitir trabajos extra
                         </label>
                       </div>
                       {/* Precios para extras si est√° permitido */}
                       {editedValues.allowExtraWork && (
                         <div className="extra-work-section">
                           <h4>Tarifas para trabajos extra por horas</h4>
                           <div className="form-group">
                             <label htmlFor={`edit-extra-officialPrice-${project.firestoreId}`}>Precio oficial extras (‚Ç¨/h)</label>
                             <input
                                id={`edit-extra-officialPrice-${project.firestoreId}`}
                                type="number" name="officialPrice" min="0" step="0.01"
                                value={editedValues.officialPrice || 0} onChange={handleEditChange} onBlur={handleEditBlur}
                                className={editHasError('officialPrice') ? 'input-error' : ''} />
                             {editHasError('officialPrice') && <p className="error-message">{editGetError('officialPrice')}</p>}
                           </div>
                           <div className="form-group">
                             <label htmlFor={`edit-extra-workerPrice-${project.firestoreId}`}>Precio pe√≥n extras (‚Ç¨/h)</label>
                             <input
                                id={`edit-extra-workerPrice-${project.firestoreId}`}
                                type="number" name="workerPrice" min="0" step="0.01"
                                value={editedValues.workerPrice || 0} onChange={handleEditChange} onBlur={handleEditBlur}
                                className={editHasError('workerPrice') ? 'input-error' : ''} />
                             {editHasError('workerPrice') && <p className="error-message">{editGetError('workerPrice')}</p>}
                           </div>
                         </div>
                       )}
                     </>
                   )}
                   {/* Botones de acci√≥n del formulario de edici√≥n */}
                   <div className="form-actions">
                     <button type="submit" disabled={!isEditFormValid || updateProjectMutation.isPending}>
                       {updateProjectMutation.isPending ? "Guardando..." : "Guardar Cambios"}
                     </button>
                     <button type="button" onClick={cancelEditing} disabled={updateProjectMutation.isPending} className="button-secondary">
                       Cancelar
                     </button>
                   </div>
                </form>
              ) : (
                // --- Vista de Detalles del Proyecto ---
                <>
                  <p><strong>ID:</strong> {project.id}</p>
                  <p><strong>Cliente:</strong> {project.client}</p>
                  <p><strong>Direcci√≥n:</strong> {project.address}</p>
                  <p><strong>NIF/NIE:</strong> {project.nifNie}</p>
                  <p><strong>Tipo:</strong> {project.type === "hourly" ? "Por horas" : "Presupuesto cerrado"}</p>
                  {/* Detalles espec√≠ficos por tipo */}
                  {project.type === "hourly" ? (
                    <>
                      <p><strong>Precio oficial:</strong> {formatCurrency(project.officialPrice)}/h</p>
                      <p><strong>Precio pe√≥n:</strong> {formatCurrency(project.workerPrice)}/h</p>
                      <p><strong>Horas Oficial Acumuladas:</strong> {formatNumber(officialHours)} h</p>
                      <p><strong>Horas Pe√≥n Acumuladas:</strong> {formatNumber(workerHours)} h</p>
                    </>
                  ) : ( // Tipo 'fixed'
                    <>
                      <p><strong>Presupuestado:</strong> {formatCurrency(project.budgetAmount)}</p>
                      <p><strong>Facturado Total (Presup.):</strong> {formatCurrency(invoicedTotal)}</p>
                      {project.allowExtraWork && <p><strong>Permite Extras:</strong> S√≠</p>}
                      {/* Mostrar precios de extras si est√°n definidos y permitidos */}
                      {project.allowExtraWork && (
                          <>
                           <p><strong>‚Ç¨ Oficial (Extras):</strong> {formatCurrency(project.officialPrice)}/h</p>
                           <p><strong>‚Ç¨ Pe√≥n (Extras):</strong> {formatCurrency(project.workerPrice)}/h</p>
                          </>
                      )}
                    </>
                  )}
                  {/* Resumen de costos/progreso */}
                  <h5>Resumen Actual</h5>
                  {project.type === "hourly" ? (
                    <>
                      <p>M.Obra: {formatCurrency(laborCost)} | Materiales: {formatCurrency(materialsCost)} | <strong>Total: {formatCurrency(totalCost)}</strong></p>
                      <p>Horas Totales: {formatNumber(officialHours + workerHours)} h</p>
                    </>
                  ) : ( // Tipo 'fixed'
                    <>
                      <p>Progreso (Presup.): {
    (() => {
        const totalBudget = (project.budgetAmount || 0) + (extraWork.totalExtraIncome || 0);
        return totalBudget > 0 ? ((invoicedTotal / totalBudget) * 100).toFixed(1) : 0;
    })()
}%</p>
                      {extraWork.count > 0 && (
                        <p>Trabajos Extra: {extraWork.count} partes | Ingreso Extra: {formatCurrency(extraWork.totalExtraIncome)} | Horas Extra: {formatNumber(extraWork.extraOfficialHours + extraWork.extraWorkerHours)} h</p>
                      )}
                    </>
                  )}
                  {/* Botones de acci√≥n para vista de detalles */}
                  <div className="project-actions">
                    <button onClick={() => startEditing(project)} disabled={isMutating}>
                      Editar
                    </button>
                    <button onClick={() => handleDeleteRequest(project)} // Cambiado para mostrar modal
                            style={{ backgroundColor: "#e74c3c", marginLeft: "10px" }}
                            disabled={isMutating}>
                      Eliminar
                    </button>
                  </div>
                </>
              )}
            </div>
          );
        })}
      </div>

       {/* Modal de Confirmaci√≥n de Eliminaci√≥n */}
       {projectToDelete && (
        <ConfirmModal
          title="Confirmar Eliminaci√≥n"
          message={`¬øEst√°s seguro de que quieres eliminar el proyecto "${projectToDelete.id || 'proyecto sin ID'}"? Esta acci√≥n no se puede deshacer.`}
          confirmText="S√≠, eliminar"
          cancelText="Cancelar"
          onConfirm={handleDeleteConfirm}
          onCancel={handleDeleteCancel}
          isDangerous={true} // Estilo de bot√≥n de confirmaci√≥n peligroso
          confirmButtonClass={deleteProjectMutation.isPending ? 'button-loading' : ''} // A√±adir clase si est√° cargando
        />
      )}
    </div>
  );
};

export default React.memo(ProjectsViewer);
</file>

<file path="src/components/ReportPDFGenerator.js">
// src/components/ReportPDFGenerator.js
import React, { useMemo } from "react";
import { Document, Page, Text, View, StyleSheet, Image, Link, Font } from "@react-pdf/renderer";
import CompressedImage from "./CompressedImage";
import { formatNumber, formatCurrency } from "../utils/calculationUtils";
import { useCalculationsService } from "../hooks/useCalculationsService";

// Registrar las fuentes personalizadas
Font.register({
  family: 'AtkinsonHyperlegible',
  fonts: [
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'normal', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'normal', fontStyle: 'italic' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'bold', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Atkinson-Hyperlegible-Regular-102.ttf`, fontWeight: 'bold', fontStyle: 'italic' }
  ]
});

Font.register({
  family: 'Cormorant',
  fonts: [
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'normal', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'normal', fontStyle: 'italic' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'bold', fontStyle: 'normal' },
    { src: `${process.env.PUBLIC_URL}/fonts/Cormorant-Bold.ttf`, fontWeight: 'bold', fontStyle: 'italic' }
  ]
});

const styles = StyleSheet.create({
  // Estilo optimizado para la p√°gina
  page: { 
    padding: 18, 
    fontSize: 11, 
    fontFamily: "AtkinsonHyperlegible", 
    flexDirection: "column", 
    height: "100%" 
  },
  // Portada con estructura optimizada
  coverPage: {
    padding: 20,
    display: "flex",
    flexDirection: "column",
    height: "100%",
    justifyContent: "space-between",
    fontFamily: "AtkinsonHyperlegible"
  },
  logoSection: {
    flex: 1,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
  },
  logo: { 
    width: 100, 
    height: 36
  },
  contentContainer: {
    marginTop: "auto",
  },
  title: { 
    fontSize: 20, 
    fontWeight: "bold", 
    marginBottom: 25, 
    textAlign: "center", 
    fontFamily: "Cormorant" 
  },
  detailsTable: { display: "table", width: "100%", marginBottom: 18 },
  detailsRow: { flexDirection: "row" },
  detailsColLeft: { width: "50%", padding: 4, fontSize: 11 },
  detailsColRight: { width: "50%", padding: 4, textAlign: "right", fontSize: 11 },
  footer: { fontSize: 11, textAlign: "right", marginTop: 10 },
  
  // Secciones con margen vertical optimizado
  section: { marginBottom: 12 },
  sectionTitle: { 
    fontSize: 16, 
    fontWeight: "bold", 
    marginTop: 16, 
    marginBottom: 8, 
    fontFamily: "Cormorant" 
  },
  text: { fontSize: 11, marginBottom: 4 },
  link: { color: "#007bff", textDecoration: "underline", fontSize: 11 },
  
  // Im√°genes que respetan el aspect ratio
  image: { height: 150, objectFit: "contain", margin: 4, border: "1px solid #000" },
  imageRow: { flexDirection: "row", flexWrap: "wrap", justifyContent: "flex-start" },
  
  // Tablas mejor espaciadas
  table: { display: "table", width: "100%", borderStyle: "solid", borderWidth: 1, borderColor: "#000", marginTop: 8, marginBottom: 8 },
  tableRow: { flexDirection: "row", borderBottomWidth: 1, borderBottomColor: "#000" },
  tableHeader: { backgroundColor: "#f0f0f0", fontWeight: "bold", fontSize: 11 },
  tableCol: { width: "25%", borderRightWidth: 1, borderRightColor: "#000", padding: 4, fontSize: 11 },
  tableColWide: { width: "50%", borderRightWidth: 1, borderRightColor: "#000", padding: 4, fontSize: 11 },
  tableColLast: { width: "25%", padding: 4, fontSize: 11 },
  
  // Resumen de costos
  costSummary: { display: "table", width: "100%", borderStyle: "solid", borderWidth: 1, borderColor: "#000", marginTop: 12, marginBottom: 12 },
  costRow: { flexDirection: "row", borderBottomWidth: 1, borderBottomColor: "#000" },
  costColLabel: { width: "70%", padding: 4, fontWeight: "bold", fontSize: 11 },
  costColValue: { width: "30%", padding: 4, textAlign: "right", fontSize: 11 },
  
  // Mensajes de error de imagen
  errorImage: { width: 180, height: 150, backgroundColor: "#f0f0f0", textAlign: "center", padding: 5, fontSize: 10 },
  
  // Tabla de presupuesto
  budgetTable: {
    display: "table",
    width: "100%",
    borderStyle: "solid",
    borderWidth: 1,
    borderColor: "#000",
    marginTop: 8,
    marginBottom: 8
  },
  budgetRow: {
    flexDirection: "row",
    borderBottomWidth: 1,
    borderBottomColor: "#000",
  },
  budgetTableHeader: {
    backgroundColor: "#f0f0f0",
    fontWeight: "bold",
    fontSize: 11,
    padding: 4,
    textAlign: "center",
    width: "50%",
  },
  budgetTableCell: {
    padding: 4,
    fontSize: 11,
    width: "50%",
    textAlign: "left",
  },
  budgetTableCellAmount: {
    padding: 4,
    fontSize: 11,
    width: "50%",
    textAlign: "right",
  },
  
  // P√°gina de resumen
  summaryPage: { 
    padding: 20, 
    fontSize: 11, 
    fontFamily: "AtkinsonHyperlegible", 
    flexDirection: "column" 
  },
  summaryTitle: { 
    fontSize: 20, 
    fontWeight: "bold", 
    marginBottom: 20, 
    textAlign: "center", 
    fontFamily: "Cormorant" 
  },
  summaryTable: { 
    display: "table", 
    width: "100%", 
    borderStyle: "solid", 
    borderWidth: 1, 
    borderColor: "#000", 
    marginBottom: 20 
  },
  summaryRow: { 
    flexDirection: "row", 
    borderBottomWidth: 1, 
    borderBottomColor: "#000" 
  },
  summaryLastRow: { 
    flexDirection: "row" 
  },
  summaryColLabel: { 
    width: "70%", 
    padding: 6, 
    fontSize: 11, 
    borderRightWidth: 1, 
    borderRightColor: "#000", 
    backgroundColor: "#f9f9f9" 
  },
  summaryColValue: { 
    width: "30%", 
    padding: 6, 
    fontSize: 11, 
    textAlign: "right" 
  },
  summaryHeaderRow: { 
    flexDirection: "row", 
    borderBottomWidth: 1, 
    borderBottomColor: "#000", 
    backgroundColor: "#f0f0f0" 
  },
  summaryHeaderCol: { 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    textAlign: "center" 
  },
  summaryTotalRow: { 
    flexDirection: "row", 
    backgroundColor: "#f0f0f0" 
  },
  summaryTotalLabel: { 
    width: "70%", 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    borderRightWidth: 1, 
    borderRightColor: "#000" 
  },
  summaryTotalValue: { 
    width: "30%", 
    padding: 6, 
    fontSize: 11, 
    fontWeight: "bold", 
    textAlign: "right" 
  },
  summaryNote: {
    fontSize: 10,
    fontStyle: "normal",
    marginTop: 15,
    textAlign: "center",
    color: "#666"
  },
  
  // Estilos para el nuevo dise√±o de 2 columnas
  mainHeader: {
    marginBottom: 10,
  },
  twoColumns: {
    flexDirection: "row",
    marginBottom: 12,
  },
  leftColumn: {
    width: "48%",
    marginRight: "2%",
  },
  rightColumn: {
    width: "48%",
    marginLeft: "2%",
  },
  fullWidth: {
    width: "100%",
    marginBottom: 12,
  },
  subSectionTitle: {
    fontSize: 14,
    fontWeight: "bold",
    marginTop: 6,
    marginBottom: 4,
    fontFamily: "Cormorant"
  },
  materialsList: {
    marginTop: 4,
    marginBottom: 4,
  },
  materialItem: {
    fontSize: 11,
    marginBottom: 2,
  },
  workDescription: {
    marginTop: 4,
    marginBottom: 8,
  },
  
  // Estilos para trabajos extra
  extraWorkBadge: {
    backgroundColor: '#fff8e1',
    padding: 5,
    marginBottom: 5,
    borderRadius: 3
  },
  extraWorkText: {
    fontSize: 10,
    color: '#e67e22',
    fontWeight: 'bold'
  },
  extraWorkSection: {
    backgroundColor: '#fff8e1',
    borderBottomWidth: 1,
    borderBottomColor: '#e67e22',
  }
});

// Componente principal del PDF
const ReportPDFGenerator = ({ reports, projects }) => {
  // Usar el servicio centralizado de c√°lculos
  const { 
    calculateLabor, 
    calculateMaterials, 
    calculateReportSummary, 
    calculateBudget 
  } = useCalculationsService();

  // Ordenar los reportes por fecha (del m√°s antiguo al m√°s nuevo)
  const sortedReports = useMemo(() => {
    return [...reports].sort((a, b) => {
      const dateA = new Date(a.reportDate);
      const dateB = new Date(b.reportDate);
      return dateA - dateB; // Orden ascendente (antiguo a nuevo)
    });
  }, [reports]);

  const firstReport = sortedReports[0];
  const project = projects.find((p) => p.id === firstReport?.projectId) || {};
  const currentDate = new Date().toLocaleDateString("es-ES", { weekday: "long", day: "numeric", month: "long", year: "numeric" });

  // Obtener totales calculados desde el servicio
  const { totals } = calculateReportSummary(sortedReports, projects, firstReport?.projectId);

  // Funci√≥n para generar el t√≠tulo con soporte para m√∫ltiples semanas
  const renderTitle = () => {
    if (!reports || reports.length === 0) {
      return "Acta de obra";
    }
    
    // Obtener todos los n√∫meros de semana √∫nicos
    const uniqueWeeks = [...new Set(reports.map(report => report.weekNumber))].sort((a, b) => a - b);
    const year = new Date(firstReport.reportDate).getFullYear();
    
    // Si hay una sola semana
    if (uniqueWeeks.length === 1) {
      return `Acta semanal de obra - Semana ${uniqueWeeks[0]} - A√±o ${year}`;
    }
    
    // Si son semanas consecutivas
    if (uniqueWeeks.length === uniqueWeeks[uniqueWeeks.length - 1] - uniqueWeeks[0] + 1) {
      return `Acta semanal de obra - Semanas ${uniqueWeeks[0]} a ${uniqueWeeks[uniqueWeeks.length - 1]} - A√±o ${year}`;
    }
    
    // Si son semanas no consecutivas
    return `Acta semanal de obra - Semanas ${uniqueWeeks.join(', ')} - A√±o ${year}`;
  };

  // Funci√≥n para renderizar im√°genes
  const renderImage = (src) => {
    try {
      if (!src || typeof src !== "string" || !src.startsWith("http")) {
        return (
          <View style={styles.errorImage}>
            <Text>Imagen no disponible</Text>
          </View>
        );
      }
      // Usar el componente CompressedImage en lugar de Image directamente
      return <CompressedImage 
              src={src} 
              style={styles.image} 
              maxWidth={600} 
              maxHeight={500} 
              quality={0.5} // Puedes ajustar la calidad aqu√≠ (0.1 a 1)
            />;
    } catch (error) {
      console.error("Error al cargar imagen en PDF:", error);
      return (
        <View style={styles.errorImage}>
          <Text>Imagen no disponible</Text>
        </View>
      );
    }
  };

  // Verificar si hay trabajos extra
  const hasExtraWork = sortedReports.some(report => report.isExtraWork);

  return (
    <Document>
      {/* Portada */}
      <Page size="A4" style={styles.coverPage}>
        <View style={styles.logoSection}>
          <Image src={`${process.env.PUBLIC_URL}/assets/logo.png`} style={styles.logo} />
        </View>
        <View style={styles.contentContainer}>
          <Text style={styles.title}>
            {renderTitle()}
          </Text>
          <View style={styles.detailsTable}>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>Promotor: {project.client || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>Redactado por: Jes√∫s Moral Ab√°solo</Text>
            </View>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>NIF/NIE: {project.nifNie || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>NIF: 75902042H</Text>
            </View>
            <View style={styles.detailsRow}>
              <Text style={styles.detailsColLeft}>Proyecto: {project.id || "No disponible"}</Text>
              <Text style={styles.detailsColRight}>Arquitecto t√©cnico y artesano</Text>
            </View>
              <Text style={styles.detailsColLeft}>Direcci√≥n: {project.address || "No disponible"}</Text>
          </View>
          <Text style={styles.footer}>{currentDate}</Text>
        </View>
      </Page>

      {/* P√°ginas por parte diario */}
      {sortedReports.map((report, index) => {
        const project = projects.find((p) => p.id === report.projectId) || {};
        const isHourly = project.type === "hourly";
        
        // Usar servicios centralizados para c√°lculos
        // **CORRECCI√ìN**: Usamos la funci√≥n de budgetUtils corregida
        const budgetSummary = project.type === "fixed" 
          ? calculateBudget(project, reports) // Pasamos todos los reportes para el c√°lculo correcto
          : { budgetAmount: 0, invoicedTotal: 0, remainingBudget: 0 };
          
        // Calcular datos de labor y materiales si aplica
        const laborCalcs = report.labor ? calculateLabor(report.labor, project) : null;
        const materialsCalcs = report.materials ? calculateMaterials(report.materials) : null;
        
        // Determinar si es un trabajo extra y su tipo
        const isExtraWork = report.isExtraWork;
        const extraWorkType = isExtraWork ? report.extraWorkType : null;

        return (
          <Page key={`report-${index}`} size="A4" style={styles.page}>
            {/* Cabecera del parte */}
            <View style={styles.mainHeader}>
              <Text style={styles.sectionTitle}>Fecha: {new Date(report.reportDate).toLocaleDateString("es-ES", { weekday: "long", day: "numeric", month: "long", year: "numeric" })}</Text>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                <Text style={{ fontSize: 11, marginRight: 20 }}>Semana: {report.weekNumber}</Text>
                <Text style={{ fontSize: 11, marginRight: 20 }}>Proyecto: {report.projectId || "No disponible"}</Text>
                <Text style={{ fontSize: 11 }}>Cliente: {project.client || "No disponible"}</Text>
              </View>
              <Text style={{ fontSize: 11 }}>Direcci√≥n: {project.address || "No disponible"}</Text>
              
              {/* Indicador de trabajo extra */}
              {isExtraWork && (
                <View style={styles.extraWorkBadge}>
                  <Text style={styles.extraWorkText}>
                    {extraWorkType === "hourly" 
                      ? "TRABAJO EXTRA POR HORAS" 
                      : "TRABAJO EXTRA CON PRESUPUESTO ADICIONAL"}
                  </Text>
                </View>
              )}
            </View>

            {/* Distribuci√≥n en dos columnas */}
            <View style={styles.twoColumns}>
              {/* Columna izquierda - Mano de obra o presupuesto */}
              <View style={styles.leftColumn}>
                {isHourly || (isExtraWork && extraWorkType === "hourly") ? (
                  <>
                    <Text style={styles.subSectionTitle}>Mano de obra</Text>
                    <View style={styles.table}>
                      <View style={[styles.tableRow, styles.tableHeader]}>
                        <Text style={styles.tableColWide}> </Text>
                        <Text style={styles.tableCol}>Oficial</Text>
                        <Text style={styles.tableCol}>Pe√≥n</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Hora de entrada</Text>
                        <Text style={styles.tableCol}>{report.labor?.officialEntry || "--:--"}</Text>
                        <Text style={styles.tableCol}>{report.labor?.workerEntry || "--:--"}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Hora de salida</Text>
                        <Text style={styles.tableCol}>{report.labor?.officialExit || "--:--"}</Text>
                        <Text style={styles.tableCol}>{report.labor?.workerExit || "--:--"}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Horas trabajadas</Text>
                        <Text style={styles.tableCol}>{formatNumber(laborCalcs?.officialHours || 0)}</Text>
                        <Text style={styles.tableCol}>{formatNumber(laborCalcs?.workerHours || 0)}</Text>
                      </View>
                      <View style={styles.tableRow}>
                        <Text style={styles.tableColWide}>Coste</Text>
                        <Text style={styles.tableCol}>{formatCurrency(laborCalcs?.officialCost || 0)}</Text>
                        <Text style={styles.tableCol}>{formatCurrency(laborCalcs?.workerCost || 0)}</Text>
                      </View>
                    </View>
                    <Text style={{ fontSize: 11, marginTop: 4 }}>Coste total mano de obra: {formatCurrency(laborCalcs?.totalLaborCost || 0)}</Text>
                  </>
                ) : (
                  <>
                    <Text style={styles.subSectionTitle}>
                      {isExtraWork ? "Presupuesto adicional (extra)" : "Presupuesto cerrado"}
                    </Text>
                    <View style={styles.budgetTable}>
                      <View style={styles.budgetRow}>
                        <Text style={styles.budgetTableHeader}>Concepto</Text>
                        <Text style={styles.budgetTableHeader}>Importe</Text>
                      </View>
                      
                      {isExtraWork ? (
                        <View style={styles.budgetRow}>
                          <Text style={styles.budgetTableCell}>Importe extra presupuestado</Text>
                          <Text style={styles.budgetTableCellAmount}>{formatCurrency(report.extraBudgetAmount || 0)}</Text>
                        </View>
                      ) : (
                        <>
                          <View style={styles.budgetRow}>
                            <Text style={styles.budgetTableCell}>Importe presupuestado</Text>
                            <Text style={styles.budgetTableCellAmount}>{formatCurrency(budgetSummary.budgetAmount)}</Text>
                          </View>
                          <View style={styles.budgetRow}>
                            <Text style={styles.budgetTableCell}>Importe facturado (de este parte)</Text>
                            <Text style={styles.budgetTableCellAmount}>{formatCurrency(report.invoicedAmount || 0)}</Text>
                          </View>
                          <View style={styles.budgetRow}>
                            <Text style={styles.budgetTableCell}>Total facturado (acumulado)</Text>
                            <Text style={styles.budgetTableCellAmount}>{formatCurrency(budgetSummary.invoicedTotal)}</Text>
                          </View>
                        </>
                      )}
                    </View>
                  </>
                )}
              </View>

              {/* Columna derecha - Materiales */}
              <View style={styles.rightColumn}>
                <Text style={styles.subSectionTitle}>Materiales</Text>
                <View style={styles.materialsList}>
                  {report.materials && report.materials.length > 0 ? (
                    <>
                      <Text style={{ fontSize: 11, marginBottom: 4 }}>Descripci√≥n materiales comprados:</Text>
                      {report.materials.map((m, i) => (
                        <Text key={`material-desc-${i}`} style={styles.materialItem}>
                          - {m.description || "Sin descripci√≥n"}
                        </Text>
                      ))}
                      <Text style={{ fontSize: 11, marginTop: 6, marginBottom: 2 }}>Albaranes/facturas:</Text>
                      {report.materials.map((m, i) => (
                        <Text key={`material-invoice-${i}`} style={styles.materialItem}>
                          Factura {i + 1} (
                          <Link src={m.invoiceUrl} style={styles.link}>
                            Descargar PDF
                          </Link>
                          )
                        </Text>
                      ))}
                    </>
                  ) : (
                    <Text style={{ fontSize: 11 }}>No hay materiales registrados.</Text>
                  )}
                  <Text style={{ fontSize: 11, marginTop: 6 }}>Coste total de materiales: {formatCurrency(materialsCalcs?.totalMaterialsCost || 0)}</Text>
                </View>
              </View>
            </View>

            {/* Resumen de costes (ancho completo) */}
            {(isHourly || (isExtraWork && extraWorkType === "hourly")) && (
              <View style={styles.fullWidth}>
                <Text style={styles.subSectionTitle}>Coste total MO + materiales</Text>
                <View style={styles.costSummary}>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total mano de obra</Text>
                    <Text style={styles.costColValue}>{formatCurrency(laborCalcs?.totalLaborCost || 0)}</Text>
                  </View>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total de materiales</Text>
                    <Text style={styles.costColValue}>{formatCurrency(materialsCalcs?.totalMaterialsCost || 0)}</Text>
                  </View>
                  <View style={styles.costRow}>
                    <Text style={styles.costColLabel}>Coste total MO + materiales</Text>
                    <Text style={styles.costColValue}>{formatCurrency(
                      (laborCalcs?.totalLaborCost || 0) + (materialsCalcs?.totalMaterialsCost || 0)
                    )}</Text>
                  </View>
                </View>
              </View>
            )}

            {/* Trabajos realizados (ancho completo) */}
            <View style={styles.fullWidth}>
              <Text style={styles.subSectionTitle}>Trabajos realizados</Text>
              <View style={styles.workDescription}>
                <Text style={{ fontSize: 11 }}>{report.workPerformed?.description || "Sin descripci√≥n"}</Text>
              </View>
            </View>

            {/* Fotograf√≠as (ancho completo) */}
            <View style={styles.fullWidth}>
              <Text style={styles.subSectionTitle}>Fotograf√≠as</Text>
              <View style={styles.imageRow}>
                {report.workPerformed?.photos?.map((photo, i) => (
                  <View key={`photo-${i}`}>{renderImage(photo.url)}</View>
                ))}
                {(!report.workPerformed?.photos || report.workPerformed.photos.length === 0) && (
                  <Text style={{ fontSize: 11 }}>No hay fotograf√≠as disponibles</Text>
                )}
              </View>
            </View>
          </Page>
        );
      })}

      {/* P√°gina de resumen de totales */}
      <Page size="A4" style={styles.summaryPage}>
        <Text style={styles.summaryTitle}>
          Resumen de Totales - Proyecto {project.id}
        </Text>
        
        <View style={styles.detailsTable}>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Promotor: {project.client || "No disponible"}</Text>
            <Text style={styles.detailsColRight}>Fecha: {currentDate}</Text>
          </View>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Proyecto: {project.address || "No disponible"}</Text>
            <Text style={styles.detailsColRight}>Tipo: {project.type === "hourly" ? "Por horas" : "Presupuesto cerrado"}</Text>
          </View>
          <View style={styles.detailsRow}>
            <Text style={styles.detailsColLeft}>Per√≠odo: {renderTitle().replace('Acta semanal de obra - ', '')}</Text>
            <Text style={styles.detailsColRight}>Total partes: {reports.length}</Text>
          </View>
        </View>

        {project.type === "hourly" ? (
          <View style={styles.summaryTable}>
            <View style={styles.summaryHeaderRow}>
              <Text style={{...styles.summaryHeaderCol, width: "70%"}}>Concepto</Text>
              <Text style={{...styles.summaryHeaderCol, width: "30%"}}>Importe</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Total mano de obra (Ingresos)</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(totals.totalLabor)}</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryColLabel}>Total materiales (Coste)</Text>
              <Text style={styles.summaryColValue}>{formatCurrency(totals.totalMaterials)}</Text>
            </View>
            <View style={styles.summaryTotalRow}>
              <Text style={styles.summaryTotalLabel}>TOTAL COSTE OPERATIVO</Text>
              <Text style={styles.summaryTotalValue}>{formatCurrency(totals.totalCost)}</Text>
            </View>
          </View>
        ) : ( // L√≥gica para proyectos de presupuesto cerrado
          (() => {
            // **CORRECCI√ìN**: Usamos la funci√≥n de budgetUtils corregida para obtener los valores correctos
            const finalBudget = calculateBudget(project, sortedReports);

            return (
              <View style={styles.summaryTable}>
                <View style={styles.summaryHeaderRow}>
                  <Text style={{ ...styles.summaryHeaderCol, width: "70%" }}>Concepto</Text>
                  <Text style={{ ...styles.summaryHeaderCol, width: "30%" }}>Importe</Text>
                </View>
                <View style={styles.summaryRow}>
                  <Text style={styles.summaryColLabel}>Presupuesto Original</Text>
                  <Text style={styles.summaryColValue}>{formatCurrency(finalBudget.budgetAmount)}</Text>
                </View>
                
                {/* Mostramos la secci√≥n de extras solo si existen */}
                {finalBudget.totalExtraWorkIncome > 0 && (
                  <>
                    <View style={[styles.summaryRow, styles.extraWorkSection]}>
                        <Text style={[styles.summaryColLabel, { color: '#e67e22', fontWeight: 'bold' }]}>
                            Ingresos por Trabajos Extra
                        </Text>
                        <Text style={[styles.summaryColValue, { color: '#e67e22', fontWeight: 'bold' }]}>
                            {formatCurrency(finalBudget.totalExtraWorkIncome)}
                        </Text>
                    </View>
                  </>
                )}
                
                <View style={styles.summaryTotalRow}>
                  <Text style={styles.summaryTotalLabel}>PRESUPUESTO TOTAL (CON EXTRAS)</Text>
                  <Text style={styles.summaryTotalValue}>{formatCurrency(finalBudget.totalBudgetWithExtras)}</Text>
                </View>

                <View style={styles.summaryRow}>
                  <Text style={styles.summaryColLabel}>Total Facturado (del presupuesto original)</Text>
                  <Text style={styles.summaryColValue}>{formatCurrency(finalBudget.invoicedTotal)}</Text>
                </View>

                <View style={styles.summaryTotalRow}>
                  <Text style={styles.summaryTotalLabel}>IMPORTE RESTANTE</Text>
                  <Text style={styles.summaryTotalValue}>{formatCurrency(finalBudget.remainingBudget)}</Text>
                </View>
              </View>
            );
          })()
        )}

        <Text style={styles.summaryNote}>
          Este resumen incluye todos los partes diarios seleccionados en el rango de fechas especificado.
          {hasExtraWork ? " Los trabajos extra se muestran sumados al presupuesto original para calcular el total real del proyecto." : ""}
        </Text>
      </Page>
    </Document>
  );
};

export default ReportPDFGenerator;
</file>

<file path="src/firebase.js">
// firebase.js
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
};

const app = initializeApp(firebaseConfig);

export const db = getFirestore(app);
export const storage = getStorage(app);
export { app }; // Exporta la instancia de la app
</file>

<file path="src/App.js">
// src/App.js (Modificado para integrar el Dashboard)
import React, { useState, useEffect } from "react";
import DailyReportForm from "./components/DailyReportForm";
import ReportsViewer from "./components/reports/ReportsViewer"; // <-- Ruta actualizada
import ProjectsViewer from "./components/ProjectsViewer";
import Dashboard from "./components/Dashboard"; // Importar el nuevo componente
import LoginForm from "./components/LoginForm";
import { getAuth, onAuthStateChanged } from "firebase/auth";
import { app } from './firebase';
import "./components/ExtraWork.css"; // Importar archivo CSS de trabajos extra
import "./App.css";
import "./components/ProjectForm.css";  


function App() {
  const [activeTab, setActiveTab] = useState("partes"); // Cambiado a "partes" como tab inicial
  const [user, setUser] = useState(null);

  const auth = getAuth(app);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
    });
    return () => unsubscribe();
  }, [auth]);

  return (
    <div className="App">
      <header className="app-header">
        <img src="/assets/logo.png" alt="Logo" className="app-logo" />
      </header>
      <div className="app-container">
        <nav className="tab-buttons">
  <button
    className={activeTab === "partes" ? "active" : ""}
    onClick={() => setActiveTab("partes")}
  >
    Partes
  </button>
  <button
    className={activeTab === "informes" ? "active" : ""}
    onClick={() => setActiveTab("informes")}
  >
    Informes
  </button>
  <button
    className={activeTab === "proyectos" ? "active" : ""}
    onClick={() => setActiveTab("proyectos")}
  >
    Proyectos
  </button>
  <button
    className={activeTab === "dashboard" ? "active" : ""}
    onClick={() => setActiveTab("dashboard")}
  >
    Dashboard
  </button>
</nav>
        <main>
          {user ? (
            <>
              {activeTab === "dashboard" ? (
                <Dashboard />
              ) : activeTab === "partes" ? (
                <DailyReportForm userId={user.uid} />
              ) : activeTab === "informes" ? (
                <ReportsViewer />
              ) : (
                <ProjectsViewer />
              )}
            </>
          ) : (
            <LoginForm />
          )}
        </main>
      </div>
    </div>
  );
}

export default App;
</file>

</files>
